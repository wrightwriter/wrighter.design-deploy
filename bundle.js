/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 602:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `wbr.svelte-1r35zme.svelte-1r35zme{display:block;height:0.02rem;margin:none}.description.svelte-1r35zme.svelte-1r35zme{margin-top:3rem;display:flex;flex-direction:column;font-weight:var(--text-font-weight)}.description.svelte-1r35zme .svelte-1r35zme{font-weight:var(--text-font-weight);font-size:1rem}main.svelte-1r35zme.svelte-1r35zme{width:100%;max-width:40rem;min-height:100%;height:fit-content;display:flex;flex-direction:column;max-width:var(--main-max-width)}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJvdXQuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRDpcXFByb2dyYW1taW5nXFxXZWIgRGV2ZWxvcG1lbnRcXHdyaWdodGVyLmRlc2lnblxcc3JjXFxjb21wb25lbnRzXFxBYm91dC5zdmVsdGUiXX0=*/`, "",{"version":3,"sources":["webpack://./src/components/About.svelte"],"names":[],"mappings":"AAAA,kCAAkC,aAAa,CAAC,cAAc,CAAC,WAAW,CAAC,2CAA2C,eAAe,CAAC,YAAY,CAAC,qBAAqB,CAAC,mCAAmC,CAAC,4CAA4C,mCAAmC,CAAC,cAAc,CAAC,mCAAmC,UAAU,CAAC,eAAe,CAAC,eAAe,CAAC,kBAAkB,CAAC,YAAY,CAAC,qBAAqB,CAAC,+BAA+B;AAC/c,iRAAiR","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 435:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `*{font-family:"Petrona";font-weight:400;color:black}*::selection{background:black;color:white}a{text-decoration:underline;text-decoration-style:dashed;text-underline-offset:0.2rem}a:hover{color:white !important;background:black;text-decoration:none}a:hover *{color:white !important;text-decoration:none}.menu-item{text-decoration:none;font-weight:900}#logo{text-decoration:none}::-webkit-scrollbar{background:black}::-webkit-scrollbar-track{background:white}::-webkit-scrollbar-thumb{background:black}main>*{margin-left:1rem}main{width:100%;max-width:40rem;height:100%;display:flex;flex-direction:column;max-width:var(--main-max-width);margin-right:auto;margin-left:auto}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXBwLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEyRGtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkFwcC5zdmVsdGUiXX0=*/`, "",{"version":3,"sources":["webpack://./src/components/App.svelte"],"names":[],"mappings":"AA2DkB,EAAA,qBAAA,CAAA,eAAA,CAAA,WAAA,CAAA,aAAA,gBAAA,CAAA,WAAA,CAAA,EAAA,yBAAA,CAAA,4BAAA,CAAA,4BAAA,CAAA,QAAA,sBAAA,CAAA,gBAAA,CAAA,oBAAA,CAAA,UAAA,sBAAA,CAAA,oBAAA,CAAA,WAAA,oBAAA,CAAA,eAAA,CAAA,MAAA,oBAAA,CAAA,oBAAA,gBAAA,CAAA,0BAAA,gBAAA,CAAA,0BAAA,gBAAA,CAAA,OAAA,gBAAA,CAAA,KAAA,UAAA,CAAA,eAAA,CAAA,WAAA,CAAA,YAAA,CAAA,qBAAA,CAAA,+BAAA,CAAA,iBAAA,CAAA,gBAAA;AA1DlB,yLAAyL","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 582:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#bar.svelte-19glm00.svelte-19glm00{width:100%;margin-top:1rem;margin-bottom:1rem;display:flex;flex-wrap:wrap;width:100%}#bar.svelte-19glm00 mark.svelte-19glm00{background:black}#bar.svelte-19glm00 .logo.svelte-19glm00{font-size:4rem;margin-left:1rem;height:fit-content;text-decoration:none}#bar.svelte-19glm00 .logo.logo-behind.svelte-19glm00{position:absolute}#bar.svelte-19glm00 .logo.hovered.svelte-19glm00{color:black !important}#bar.svelte-19glm00 .logo.hovered.hover-effect-0.svelte-19glm00{animation:svelte-19glm00-glitch-anim3 10s infinite linear alternate-reverse}@keyframes svelte-19glm00-distort1{0%{transform:translate(0.5rem, 0.5rem)}12.5%{transform:translate(0.5rem, 0rem)}25%{transform:translate(0.5rem, 1.5rem)}37.5%{transform:translate(0rem, 0.5rem)}50%{transform:translate(0.5rem, 0.5rem)}62.5%{transform:translate(0.5rem, 0rem)}75%{transform:translate(0.5rem, 0.5rem)}87.5%{transform:translate(0rem, 0.5rem)}100%{transform:translate(1.5rem, 0.5rem)}}@keyframes svelte-19glm00-distort2{0%{transform:translate(0.5rem, 0.5rem)}12.5%{transform:translate(0rem, 0.5rem)}25%{transform:translate(1.5rem, 0.5rem)}37.5%{transform:translate(1.5rem, 0rem)}50%{transform:translate(1.5rem, 0.5rem)}62.5%{transform:translate(0rem, 1.5rem)}75%{transform:translate(0.5rem, 0.5rem)}87.5%{transform:translate(0.5rem, 0rem)}100%{transform:translate(0.5rem, 0.5rem)}}@keyframes svelte-19glm00-glitch-anim3{0%{clip:rect(3.3rem, 9999px, 2rem, 0);transform-origin:center}2%{clip:rect(3.4rem, 9999px, 2rem, 0);transform-origin:center}4%{clip:rect(2.5rem, 9999px, 3rem, 0);transform-origin:center}6%{clip:rect(3rem, 9999px, 2.5rem, 0);transform-origin:center}8%{clip:rect(0.7rem, 9999px, 1.5rem, 0);transform-origin:center}10%{clip:rect(3rem, 9999px, 4.5rem, 0);transform-origin:center}12%{clip:rect(3.6rem, 9999px, 0.5rem, 0);transform-origin:center}14%{clip:rect(2.2rem, 9999px, 3.5rem, 0);transform-origin:center}16%{clip:rect(2.9rem, 9999px, 4rem, 0);transform-origin:center}18%{clip:rect(0.1rem, 9999px, 2.5rem, 0);transform-origin:center}20%{clip:rect(1.8rem, 9999px, 4.5rem, 0);transform-origin:center}22%{clip:rect(3.2rem, 9999px, 0.5rem, 0);transform-origin:center}24%{clip:rect(2.8rem, 9999px, 4rem, 0);transform-origin:center}26%{clip:rect(2.9rem, 9999px, 1.5rem, 0);transform-origin:center}28%{clip:rect(3.9rem, 9999px, 1rem, 0);transform-origin:center}30%{clip:rect(0.9rem, 9999px, 1rem, 0);transform-origin:center}32%{clip:rect(2.3rem, 9999px, 4.5rem, 0);transform-origin:center}34%{clip:rect(2.9rem, 9999px, 1.5rem, 0);transform-origin:center}36%{clip:rect(0.8rem, 9999px, 4rem, 0);transform-origin:center}38%{clip:rect(1.1rem, 9999px, 3rem, 0);transform-origin:center}40%{clip:rect(0.8rem, 9999px, 2rem, 0);transform-origin:center}42%{clip:rect(1.2rem, 9999px, 4.5rem, 0);transform-origin:center}44%{clip:rect(2.8rem, 9999px, 4.5rem, 0);transform-origin:center}46%{clip:rect(1.6rem, 9999px, 3rem, 0);transform-origin:center}48%{clip:rect(3.2rem, 9999px, 4.5rem, 0);transform-origin:center}50%{clip:rect(3.2rem, 9999px, 2rem, 0);transform-origin:center}52%{clip:rect(1.5rem, 9999px, 2.5rem, 0);transform-origin:center}54%{clip:rect(0.6rem, 9999px, 3rem, 0);transform-origin:center}56%{clip:rect(3.2rem, 9999px, 4rem, 0);transform-origin:center}58%{clip:rect(3.5rem, 9999px, 2rem, 0);transform-origin:center}60%{clip:rect(0.5rem, 9999px, 1rem, 0);transform-origin:center}62%{clip:rect(4rem, 9999px, 1rem, 0);transform-origin:center}64%{clip:rect(3.2rem, 9999px, 4.5rem, 0);transform-origin:center}66%{clip:rect(0.9rem, 9999px, 5rem, 0);transform-origin:center}68%{clip:rect(0.9rem, 9999px, 1rem, 0);transform-origin:center}70%{clip:rect(3.9rem, 9999px, 1rem, 0);transform-origin:center}72%{clip:rect(3.9rem, 9999px, 5rem, 0);transform-origin:center}74%{clip:rect(1.8rem, 9999px, 2.5rem, 0);transform-origin:center}76%{clip:rect(1.5rem, 9999px, 2rem, 0);transform-origin:center}78%{clip:rect(2.7rem, 9999px, 5rem, 0);transform-origin:center}80%{clip:rect(3.5rem, 9999px, 3.5rem, 0);transform-origin:center}82%{clip:rect(3.1rem, 9999px, 0.5rem, 0);transform-origin:center}84%{clip:rect(1rem, 9999px, 2.5rem, 0);transform-origin:center}86%{clip:rect(1.3rem, 9999px, 3.5rem, 0);transform-origin:center}88%{clip:rect(3.4rem, 9999px, 5rem, 0);transform-origin:center}90%{clip:rect(3.1rem, 9999px, 3.5rem, 0);transform-origin:center}92%{clip:rect(1.8rem, 9999px, 1rem, 0);transform-origin:center}94%{clip:rect(1.3rem, 9999px, 4rem, 0);transform-origin:center}96%{clip:rect(0.7rem, 9999px, 3rem, 0);transform-origin:center}98%{clip:rect(2.6rem, 9999px, 5rem, 0);transform-origin:center}}@keyframes svelte-19glm00-cooool{0%{color:red !important}2%{color:red !important}4%{color:red !important}6%{color:red !important}8%{color:red !important}10%{color:red !important}12%{color:red !important}14%{color:red !important}16%{color:red !important}18%{color:red !important}20%{color:red !important}22%{color:red !important}24%{color:red !important}26%{color:red !important}28%{color:red !important}30%{color:red !important}32%{color:red !important}34%{color:red !important}36%{color:red !important}38%{color:red !important}40%{color:red !important}42%{color:red !important}44%{color:red !important}46%{color:red !important}48%{color:red !important}50%{color:red !important}52%{color:red !important}54%{color:red !important}56%{color:red !important}58%{color:red !important}60%{color:red !important}62%{color:red !important}64%{color:red !important}66%{color:red !important}68%{color:red !important}70%{color:red !important}72%{color:red !important}74%{color:red !important}76%{color:red !important}78%{color:red !important}80%{color:red !important}82%{color:red !important}84%{color:red !important}86%{color:red !important}88%{color:red !important}90%{color:red !important}92%{color:red !important}94%{color:red !important}96%{color:red !important}98%{color:red !important}}#bar.svelte-19glm00 .logo.hovered.hover-effect-0.logo-behind-a.svelte-19glm00{color:#ffc800 !important;animation:svelte-19glm00-distort1 300ms linear infinite, svelte-19glm00-glitch-anim3 5s infinite linear alternate-reverse, svelte-19glm00-cooool 5s infinite linear alternate-reverse}#bar.svelte-19glm00 .logo.hovered.hover-effect-0.logo-behind-b.svelte-19glm00{color:#aa10f2 !important;animation:svelte-19glm00-distort2 300ms linear infinite, svelte-19glm00-glitch-anim3 3s infinite linear alternate-reverse}#bar.svelte-19glm00 .logo.hover-effect-1.svelte-19glm00{animation:svelte-19glm00-glitch-skew 1s infinite linear alternate-reverse}@keyframes svelte-19glm00-glitch-anim{0%{clip:rect(2.7rem, 9999px, 3.5rem, 0);transform:skew(7.4deg);z-index:4}2%{clip:rect(0.5rem, 9999px, 2.5rem, 0);transform:skew(9deg);z-index:4}4%{clip:rect(2rem, 9999px, 2.5rem, 0);transform:skew(0.8deg);z-index:3}6%{clip:rect(3.2rem, 9999px, 5rem, 0);transform:skew(6deg);z-index:4}8%{clip:rect(0.3rem, 9999px, 4rem, 0);transform:skew(9.3deg);z-index:1}10%{clip:rect(3.5rem, 9999px, 0.5rem, 0);transform:skew(2.5deg);z-index:3}12%{clip:rect(0.4rem, 9999px, 3rem, 0);transform:skew(6.5deg);z-index:2}14%{clip:rect(0.8rem, 9999px, 1rem, 0);transform:skew(2.8deg);z-index:3}16%{clip:rect(0.4rem, 9999px, 0.5rem, 0);transform:skew(5deg);z-index:4}18%{clip:rect(3rem, 9999px, 4rem, 0);transform:skew(9.5deg);z-index:2}20%{clip:rect(3rem, 9999px, 2rem, 0);transform:skew(7.2deg);z-index:2}22%{clip:rect(1.5rem, 9999px, 3rem, 0);transform:skew(1.1deg);z-index:2}24%{clip:rect(3.2rem, 9999px, 4.5rem, 0);transform:skew(6.1deg);z-index:2}26%{clip:rect(0.1rem, 9999px, 4.5rem, 0);transform:skew(9.3deg);z-index:2}28%{clip:rect(0.5rem, 9999px, 1rem, 0);transform:skew(9.1deg);z-index:1}30%{clip:rect(1.1rem, 9999px, 1rem, 0);transform:skew(6.9deg);z-index:3}32%{clip:rect(1.6rem, 9999px, 3rem, 0);transform:skew(2.9deg);z-index:2}34%{clip:rect(1.5rem, 9999px, 3.5rem, 0);transform:skew(1.7deg);z-index:2}36%{clip:rect(0.1rem, 9999px, 0.5rem, 0);transform:skew(9deg);z-index:3}38%{clip:rect(2.1rem, 9999px, 0.5rem, 0);transform:skew(8.6deg);z-index:2}40%{clip:rect(2.1rem, 9999px, 2.5rem, 0);transform:skew(4deg);z-index:4}42%{clip:rect(2.4rem, 9999px, 0.5rem, 0);transform:skew(1.3deg);z-index:3}44%{clip:rect(1rem, 9999px, 1.5rem, 0);transform:skew(1.2deg);z-index:2}46%{clip:rect(2.6rem, 9999px, 3.5rem, 0);transform:skew(4.7deg);z-index:2}48%{clip:rect(0.3rem, 9999px, 4rem, 0);transform:skew(1.2deg);z-index:4}50%{clip:rect(3.3rem, 9999px, 1.5rem, 0);transform:skew(5.8deg);z-index:1}52%{clip:rect(3.2rem, 9999px, 2rem, 0);transform:skew(1.1deg);z-index:3}54%{clip:rect(1rem, 9999px, 4.5rem, 0);transform:skew(6.8deg);z-index:3}56%{clip:rect(2.5rem, 9999px, 3rem, 0);transform:skew(2.6deg);z-index:3}58%{clip:rect(3.9rem, 9999px, 5rem, 0);transform:skew(0.1deg);z-index:2}60%{clip:rect(3.2rem, 9999px, 4rem, 0);transform:skew(1.1deg);z-index:4}62%{clip:rect(0.2rem, 9999px, 4.5rem, 0);transform:skew(6.4deg);z-index:2}64%{clip:rect(3.1rem, 9999px, 0.5rem, 0);transform:skew(7.3deg);z-index:4}66%{clip:rect(0.5rem, 9999px, 0.5rem, 0);transform:skew(4.9deg);z-index:3}68%{clip:rect(3.7rem, 9999px, 1.5rem, 0);transform:skew(2.3deg);z-index:4}70%{clip:rect(2.1rem, 9999px, 4rem, 0);transform:skew(4deg);z-index:2}72%{clip:rect(1.9rem, 9999px, 4rem, 0);transform:skew(9.9deg);z-index:3}74%{clip:rect(3.9rem, 9999px, 4rem, 0);transform:skew(8.7deg);z-index:1}76%{clip:rect(1.7rem, 9999px, 4.5rem, 0);transform:skew(2.7deg);z-index:4}78%{clip:rect(1.2rem, 9999px, 1.5rem, 0);transform:skew(4.6deg);z-index:3}80%{clip:rect(1rem, 9999px, 0.5rem, 0);transform:skew(1.6deg);z-index:4}82%{clip:rect(2.1rem, 9999px, 2rem, 0);transform:skew(3.2deg);z-index:1}84%{clip:rect(3.4rem, 9999px, 2rem, 0);transform:skew(8deg);z-index:4}86%{clip:rect(2rem, 9999px, 1rem, 0);transform:skew(9.6deg);z-index:2}88%{clip:rect(3.9rem, 9999px, 1.5rem, 0);transform:skew(0.3deg);z-index:4}90%{clip:rect(1.5rem, 9999px, 4rem, 0);transform:skew(0.9deg);z-index:1}92%{clip:rect(2.8rem, 9999px, 2.5rem, 0);transform:skew(5.2deg);z-index:2}94%{clip:rect(2.4rem, 9999px, 4.5rem, 0);transform:skew(1.1deg);z-index:2}96%{clip:rect(1.8rem, 9999px, 5rem, 0);transform:skew(5.4deg);z-index:2}98%{clip:rect(1.5rem, 9999px, 2.5rem, 0);transform:skew(3.2deg);z-index:2}}@keyframes svelte-19glm00-glitch-anim2{0%{clip:rect(0.2rem, 99999px, 2.5rem, 0);transform:skew(9.5deg);transform:translateX(0.3518518519rem)}0.6666666667%{clip:rect(0.16rem, 99999px, 3rem, 0);transform:skew(12.6deg);transform:translateX(0.3518518519rem)}1.3333333333%{clip:rect(0.14rem, 99999px, 5.8rem, 0);transform:skew(14.5deg);transform:translateX(0.3518518519rem)}2%{clip:rect(0.12rem, 99999px, 9.8rem, 0);transform:skew(4.8deg);transform:translateX(0.0555555556rem)}2.6666666667%{clip:rect(0.16rem, 99999px, 4.7rem, 0);transform:skew(10.2deg);transform:translateX(0.462962963rem)}3.3333333333%{clip:rect(0.04rem, 99999px, 6.6rem, 0);transform:skew(9.3deg);transform:translateX(0.0555555556rem)}4%{clip:rect(0.1rem, 99999px, 4.2rem, 0);transform:skew(8deg);transform:translateX(0rem)}4.6666666667%{clip:rect(0.06rem, 99999px, 0.3rem, 0);transform:skew(2.3deg);transform:translateX(0.0555555556rem)}5.3333333333%{clip:rect(0.1rem, 99999px, 4.9rem, 0);transform:skew(3.8deg);transform:translateX(-0.5rem)}6%{clip:rect(0.06rem, 99999px, 10rem, 0);transform:skew(9deg);transform:translateX(0.3518518519rem)}6.6666666667%{clip:rect(0.04rem, 99999px, 0.7rem, 0);transform:skew(4deg);transform:translateX(0.4259259259rem)}7.3333333333%{clip:rect(0.2rem, 99999px, 1.5rem, 0);transform:skew(12deg);transform:translateX(0.4444444444rem)}8%{clip:rect(0.2rem, 99999px, 7.9rem, 0);transform:skew(7.5deg);transform:translateX(0.462962963rem)}8.6666666667%{clip:rect(0.14rem, 99999px, 1.2rem, 0);transform:skew(6.7deg);transform:translateX(0.3888888889rem)}9.3333333333%{clip:rect(0.16rem, 99999px, 0.2rem, 0);transform:skew(5.2deg);transform:translateX(0.3888888889rem)}10%{clip:rect(0.04rem, 99999px, 8.8rem, 0);transform:skew(4.8deg);transform:translateX(0.4444444444rem)}10.6666666667%{clip:rect(0.06rem, 99999px, 4.4rem, 0);transform:skew(8.3deg);transform:translateX(0.3888888889rem)}11.3333333333%{clip:rect(0.12rem, 99999px, 2.2rem, 0);transform:skew(7.1deg);transform:translateX(0.2777777778rem)}12%{clip:rect(0.02rem, 99999px, 3.5rem, 0);transform:skew(3.8deg);transform:translateX(0.2777777778rem)}12.6666666667%{clip:rect(0.16rem, 99999px, 5.4rem, 0);transform:skew(7.9deg);transform:translateX(0.3333333333rem)}13.3333333333%{clip:rect(0.02rem, 99999px, 8.3rem, 0);transform:skew(3.9deg);transform:translateX(0.462962963rem)}14%{clip:rect(0.02rem, 99999px, 5rem, 0);transform:skew(6.9deg);transform:translateX(0.0555555556rem)}14.6666666667%{clip:rect(0.2rem, 99999px, 7.6rem, 0);transform:skew(6.3deg);transform:translateX(0.1666666667rem)}15.3333333333%{clip:rect(0.04rem, 99999px, 0.9rem, 0);transform:skew(1deg);transform:translateX(0.3518518519rem)}16%{clip:rect(0.04rem, 99999px, 3.5rem, 0);transform:skew(12.3deg);transform:translateX(0.1666666667rem)}16.6666666667%{clip:rect(0.18rem, 99999px, 10rem, 0);transform:skew(0.1deg);transform:translateX(0.3518518519rem)}17.3333333333%{clip:rect(0.18rem, 99999px, 4.8rem, 0);transform:skew(12.4deg);transform:translateX(0.3888888889rem)}18%{clip:rect(0.2rem, 99999px, 7.4rem, 0);transform:skew(14.8deg);transform:translateX(-0.5rem)}18.6666666667%{clip:rect(0.18rem, 99999px, 4rem, 0);transform:skew(0.9deg);transform:translateX(0.3333333333rem)}19.3333333333%{clip:rect(0.1rem, 99999px, 4.4rem, 0);transform:skew(0.1deg);transform:translateX(0.2777777778rem)}20%{clip:rect(0.12rem, 99999px, 2.9rem, 0);transform:skew(3.6deg);transform:translateX(-0.5rem)}20.6666666667%{clip:rect(0.18rem, 99999px, 4.8rem, 0);transform:skew(13.9deg);transform:translateX(0.2777777778rem)}21.3333333333%{clip:rect(0.02rem, 99999px, 0.6rem, 0);transform:skew(1.3deg);transform:translateX(0.2777777778rem)}22%{clip:rect(0.2rem, 99999px, 1.1rem, 0);transform:skew(5.8deg);transform:translateX(0.3888888889rem)}22.6666666667%{clip:rect(0.14rem, 99999px, 7rem, 0);transform:skew(5.8deg);transform:translateX(0.4259259259rem)}23.3333333333%{clip:rect(0.12rem, 99999px, 8rem, 0);transform:skew(13.5deg);transform:translateX(0.3333333333rem)}24%{clip:rect(0.02rem, 99999px, 3.9rem, 0);transform:skew(0.3deg);transform:translateX(0.3518518519rem)}24.6666666667%{clip:rect(0.16rem, 99999px, 4.1rem, 0);transform:skew(5.3deg);transform:translateX(0.4259259259rem)}25.3333333333%{clip:rect(0.2rem, 99999px, 8rem, 0);transform:skew(8.4deg);transform:translateX(0.4259259259rem)}26%{clip:rect(0.18rem, 99999px, 6.1rem, 0);transform:skew(12.6deg);transform:translateX(0.1666666667rem)}26.6666666667%{clip:rect(0.2rem, 99999px, 8rem, 0);transform:skew(0.2deg);transform:translateX(0.3888888889rem)}27.3333333333%{clip:rect(0.04rem, 99999px, 5.6rem, 0);transform:skew(3.9deg);transform:translateX(0.4444444444rem)}28%{clip:rect(0.04rem, 99999px, 6.1rem, 0);transform:skew(5.7deg);transform:translateX(0.3888888889rem)}28.6666666667%{clip:rect(0.1rem, 99999px, 7.3rem, 0);transform:skew(13.4deg);transform:translateX(0.4444444444rem)}29.3333333333%{clip:rect(0.04rem, 99999px, 7.9rem, 0);transform:skew(8.4deg);transform:translateX(0.3333333333rem)}30%{clip:rect(0.04rem, 99999px, 5rem, 0);transform:skew(0.1deg);transform:translateX(0.4814814815rem)}30.6666666667%{clip:rect(0.12rem, 99999px, 6.2rem, 0);transform:skew(11.6deg);transform:translateX(0.3888888889rem)}31.3333333333%{clip:rect(0.06rem, 99999px, 6.3rem, 0);transform:skew(7.1deg);transform:translateX(0.2777777778rem)}32%{clip:rect(0.2rem, 99999px, 3.3rem, 0);transform:skew(11.3deg);transform:translateX(0.2777777778rem)}32.6666666667%{clip:rect(0.12rem, 99999px, 4rem, 0);transform:skew(1.4deg);transform:translateX(0.4259259259rem)}33.3333333333%{clip:rect(0.16rem, 99999px, 8.7rem, 0);transform:skew(12.8deg);transform:translateX(0.3888888889rem)}34%{clip:rect(0.18rem, 99999px, 3.1rem, 0);transform:skew(4.6deg);transform:translateX(0.3888888889rem)}34.6666666667%{clip:rect(0.02rem, 99999px, 9.9rem, 0);transform:skew(12.6deg);transform:translateX(0.2777777778rem)}35.3333333333%{clip:rect(0.2rem, 99999px, 8.5rem, 0);transform:skew(10.2deg);transform:translateX(0.2777777778rem)}36%{clip:rect(0.16rem, 99999px, 6.9rem, 0);transform:skew(14.1deg);transform:translateX(0.2777777778rem)}36.6666666667%{clip:rect(0.02rem, 99999px, 6.7rem, 0);transform:skew(1.7deg);transform:translateX(0.0555555556rem)}37.3333333333%{clip:rect(0.04rem, 99999px, 8.4rem, 0);transform:skew(10.1deg);transform:translateX(0.3333333333rem)}38%{clip:rect(0.02rem, 99999px, 8.3rem, 0);transform:skew(5.7deg);transform:translateX(0.2777777778rem)}38.6666666667%{clip:rect(0.16rem, 99999px, 6.1rem, 0);transform:skew(11deg);transform:translateX(0.3888888889rem)}39.3333333333%{clip:rect(0.18rem, 99999px, 9.3rem, 0);transform:skew(7.5deg);transform:translateX(0.2777777778rem)}40%{clip:rect(0.18rem, 99999px, 0.1rem, 0);transform:skew(11.5deg);transform:translateX(0.3333333333rem)}40.6666666667%{clip:rect(0.04rem, 99999px, 7.6rem, 0);transform:skew(13.1deg);transform:translateX(0.2777777778rem)}41.3333333333%{clip:rect(0.08rem, 99999px, 3.5rem, 0);transform:skew(6deg);transform:translateX(-0.1666666667rem)}42%{clip:rect(0.16rem, 99999px, 10rem, 0);transform:skew(9.3deg);transform:translateX(0.462962963rem)}42.6666666667%{clip:rect(0.14rem, 99999px, 6.2rem, 0);transform:skew(13.8deg);transform:translateX(0.1666666667rem)}43.3333333333%{clip:rect(0.08rem, 99999px, 2.8rem, 0);transform:skew(1.7deg);transform:translateX(0.2777777778rem)}44%{clip:rect(0.08rem, 99999px, 9.8rem, 0);transform:skew(9.7deg);transform:translateX(0.3518518519rem)}44.6666666667%{clip:rect(0.08rem, 99999px, 6.2rem, 0);transform:skew(14.8deg);transform:translateX(0.0555555556rem)}45.3333333333%{clip:rect(0.1rem, 99999px, 3.5rem, 0);transform:skew(6.6deg);transform:translateX(0.462962963rem)}46%{clip:rect(0.12rem, 99999px, 5.7rem, 0);transform:skew(3.7deg);transform:translateX(0.3888888889rem)}46.6666666667%{clip:rect(0.02rem, 99999px, 2.2rem, 0);transform:skew(10.2deg);transform:translateX(0.3518518519rem)}47.3333333333%{clip:rect(0.04rem, 99999px, 4.7rem, 0);transform:skew(11.3deg);transform:translateX(0.1666666667rem)}48%{clip:rect(0.2rem, 99999px, 4.3rem, 0);transform:skew(4.9deg);transform:translateX(0.2777777778rem)}48.6666666667%{clip:rect(0.1rem, 99999px, 10rem, 0);transform:skew(7.1deg);transform:translateX(0.3888888889rem)}49.3333333333%{clip:rect(0.06rem, 99999px, 9.7rem, 0);transform:skew(13.7deg);transform:translateX(0.2777777778rem)}50%{clip:rect(0.1rem, 99999px, 0.5rem, 0);transform:skew(3.5deg);transform:translateX(0.1666666667rem)}50.6666666667%{clip:rect(0.08rem, 99999px, 0.3rem, 0);transform:skew(3.9deg);transform:translateX(0.1666666667rem)}51.3333333333%{clip:rect(0.18rem, 99999px, 2.1rem, 0);transform:skew(11.9deg);transform:translateX(0.4259259259rem)}52%{clip:rect(0.12rem, 99999px, 5.3rem, 0);transform:skew(11.2deg);transform:translateX(0.462962963rem)}52.6666666667%{clip:rect(0.16rem, 99999px, 5.6rem, 0);transform:skew(1.8deg);transform:translateX(0.3518518519rem)}53.3333333333%{clip:rect(0.12rem, 99999px, 5.3rem, 0);transform:skew(10.5deg);transform:translateX(0.2777777778rem)}54%{clip:rect(0.08rem, 99999px, 0.6rem, 0);transform:skew(12.4deg);transform:translateX(0.4444444444rem)}54.6666666667%{clip:rect(0.08rem, 99999px, 3.8rem, 0);transform:skew(1.3deg);transform:translateX(0.0555555556rem)}55.3333333333%{clip:rect(0.06rem, 99999px, 4.6rem, 0);transform:skew(10.7deg);transform:translateX(0.4814814815rem)}56%{clip:rect(0.08rem, 99999px, 6.1rem, 0);transform:skew(5.9deg);transform:translateX(0.4259259259rem)}56.6666666667%{clip:rect(0.18rem, 99999px, 4.1rem, 0);transform:skew(6deg);transform:translateX(-0.1666666667rem)}57.3333333333%{clip:rect(0.2rem, 99999px, 4.6rem, 0);transform:skew(13.8deg);transform:translateX(0.462962963rem)}58%{clip:rect(0.04rem, 99999px, 3.2rem, 0);transform:skew(4.9deg);transform:translateX(0.3518518519rem)}58.6666666667%{clip:rect(0.02rem, 99999px, 5.2rem, 0);transform:skew(12.7deg);transform:translateX(0.4814814815rem)}59.3333333333%{clip:rect(0.04rem, 99999px, 4.6rem, 0);transform:skew(9.6deg);transform:translateX(0.462962963rem)}60%{clip:rect(0.16rem, 99999px, 9.4rem, 0);transform:skew(1deg);transform:translateX(0.2777777778rem)}60.6666666667%{clip:rect(0.2rem, 99999px, 4.1rem, 0);transform:skew(5.3deg);transform:translateX(0.3518518519rem)}61.3333333333%{clip:rect(0.12rem, 99999px, 0.4rem, 0);transform:skew(0.2deg);transform:translateX(0.0555555556rem)}62%{clip:rect(0.1rem, 99999px, 5rem, 0);transform:skew(0.5deg);transform:translateX(0.4444444444rem)}62.6666666667%{clip:rect(0.12rem, 99999px, 9.4rem, 0);transform:skew(10.7deg);transform:translateX(0rem)}63.3333333333%{clip:rect(0.06rem, 99999px, 8.5rem, 0);transform:skew(10.6deg);transform:translateX(0.0555555556rem)}64%{clip:rect(0.1rem, 99999px, 9.3rem, 0);transform:skew(8.3deg);transform:translateX(0.2777777778rem)}64.6666666667%{clip:rect(0.18rem, 99999px, 5.5rem, 0);transform:skew(0.8deg);transform:translateX(0.3888888889rem)}65.3333333333%{clip:rect(0.18rem, 99999px, 2rem, 0);transform:skew(5.9deg);transform:translateX(0.3518518519rem)}66%{clip:rect(0.08rem, 99999px, 0.1rem, 0);transform:skew(13.7deg);transform:translateX(0.4259259259rem)}66.6666666667%{clip:rect(0.08rem, 99999px, 2.9rem, 0);transform:skew(6.9deg);transform:translateX(0.462962963rem)}67.3333333333%{clip:rect(0.18rem, 99999px, 7.1rem, 0);transform:skew(6.8deg);transform:translateX(0.3888888889rem)}68%{clip:rect(0.04rem, 99999px, 0.6rem, 0);transform:skew(9deg);transform:translateX(0.4259259259rem)}68.6666666667%{clip:rect(0.1rem, 99999px, 7rem, 0);transform:skew(9deg);transform:translateX(0.4259259259rem)}69.3333333333%{clip:rect(0.16rem, 99999px, 7.8rem, 0);transform:skew(6.1deg);transform:translateX(0.3518518519rem)}70%{clip:rect(0.1rem, 99999px, 8.5rem, 0);transform:skew(0.2deg);transform:translateX(0.2777777778rem)}70.6666666667%{clip:rect(0.1rem, 99999px, 7.3rem, 0);transform:skew(0.4deg);transform:translateX(0.0555555556rem)}71.3333333333%{clip:rect(0.2rem, 99999px, 1.6rem, 0);transform:skew(14.5deg);transform:translateX(0.3888888889rem)}72%{clip:rect(0.06rem, 99999px, 9.1rem, 0);transform:skew(9.8deg);transform:translateX(-0.1666666667rem)}72.6666666667%{clip:rect(0.1rem, 99999px, 0.7rem, 0);transform:skew(10deg);transform:translateX(0.3518518519rem)}73.3333333333%{clip:rect(0.12rem, 99999px, 2rem, 0);transform:skew(12.9deg);transform:translateX(0.0555555556rem)}74%{clip:rect(0.16rem, 99999px, 4.9rem, 0);transform:skew(1.9deg);transform:translateX(0.2777777778rem)}74.6666666667%{clip:rect(0.14rem, 99999px, 2.6rem, 0);transform:skew(12.8deg);transform:translateX(0.4444444444rem)}75.3333333333%{clip:rect(0.06rem, 99999px, 0.1rem, 0);transform:skew(11.8deg);transform:translateX(0.1666666667rem)}76%{clip:rect(0.1rem, 99999px, 1rem, 0);transform:skew(4.7deg);transform:translateX(0.3888888889rem)}76.6666666667%{clip:rect(0.02rem, 99999px, 4rem, 0);transform:skew(11.9deg);transform:translateX(0.2777777778rem)}77.3333333333%{clip:rect(0.06rem, 99999px, 7.5rem, 0);transform:skew(10.7deg);transform:translateX(0.4259259259rem)}78%{clip:rect(0.02rem, 99999px, 8.9rem, 0);transform:skew(5.3deg);transform:translateX(0.3888888889rem)}78.6666666667%{clip:rect(0.12rem, 99999px, 8.4rem, 0);transform:skew(3.1deg);transform:translateX(0.0555555556rem)}79.3333333333%{clip:rect(0.14rem, 99999px, 9.2rem, 0);transform:skew(1.4deg);transform:translateX(0.4259259259rem)}80%{clip:rect(0.08rem, 99999px, 3.3rem, 0);transform:skew(1.5deg);transform:translateX(0.3888888889rem)}80.6666666667%{clip:rect(0.14rem, 99999px, 3.5rem, 0);transform:skew(3.9deg);transform:translateX(0.4444444444rem)}81.3333333333%{clip:rect(0.2rem, 99999px, 0.2rem, 0);transform:skew(10.8deg);transform:translateX(0.4259259259rem)}82%{clip:rect(0.02rem, 99999px, 4.4rem, 0);transform:skew(15deg);transform:translateX(0.4259259259rem)}82.6666666667%{clip:rect(0.16rem, 99999px, 2.4rem, 0);transform:skew(3.3deg);transform:translateX(0.4259259259rem)}83.3333333333%{clip:rect(0.2rem, 99999px, 2.3rem, 0);transform:skew(7.4deg);transform:translateX(0.1666666667rem)}84%{clip:rect(0.08rem, 99999px, 1rem, 0);transform:skew(5.8deg);transform:translateX(0.4259259259rem)}84.6666666667%{clip:rect(0.1rem, 99999px, 5.6rem, 0);transform:skew(13.2deg);transform:translateX(0.2037037037rem)}85.3333333333%{clip:rect(0.1rem, 99999px, 8.2rem, 0);transform:skew(7.7deg);transform:translateX(0.0555555556rem)}86%{clip:rect(0.04rem, 99999px, 3.5rem, 0);transform:skew(2.5deg);transform:translateX(0.0555555556rem)}86.6666666667%{clip:rect(0.04rem, 99999px, 3.3rem, 0);transform:skew(8.2deg);transform:translateX(0.4259259259rem)}87.3333333333%{clip:rect(0.08rem, 99999px, 0.6rem, 0);transform:skew(8.5deg);transform:translateX(0.3518518519rem)}88%{clip:rect(0.06rem, 99999px, 4.3rem, 0);transform:skew(6.6deg);transform:translateX(0.4259259259rem)}88.6666666667%{clip:rect(0.06rem, 99999px, 1rem, 0);transform:skew(6.3deg);transform:translateX(0.0555555556rem)}89.3333333333%{clip:rect(0.02rem, 99999px, 4.7rem, 0);transform:skew(7.8deg);transform:translateX(0.1666666667rem)}90%{clip:rect(0.1rem, 99999px, 7.7rem, 0);transform:skew(0.3deg);transform:translateX(0.3888888889rem)}90.6666666667%{clip:rect(0.08rem, 99999px, 6.6rem, 0);transform:skew(1.4deg);transform:translateX(0.3888888889rem)}91.3333333333%{clip:rect(0.02rem, 99999px, 6.5rem, 0);transform:skew(8.4deg);transform:translateX(0.1666666667rem)}92%{clip:rect(0.06rem, 99999px, 3.3rem, 0);transform:skew(3.8deg);transform:translateX(0.2777777778rem)}92.6666666667%{clip:rect(0.18rem, 99999px, 6.6rem, 0);transform:skew(11.6deg);transform:translateX(0.3888888889rem)}93.3333333333%{clip:rect(0.14rem, 99999px, 5.6rem, 0);transform:skew(0.1deg);transform:translateX(0.3333333333rem)}94%{clip:rect(0.12rem, 99999px, 2.1rem, 0);transform:skew(6.6deg);transform:translateX(0.4259259259rem)}94.6666666667%{clip:rect(0.16rem, 99999px, 3.2rem, 0);transform:skew(7.5deg);transform:translateX(0.2777777778rem)}95.3333333333%{clip:rect(0.14rem, 99999px, 8.4rem, 0);transform:skew(7.3deg);transform:translateX(0.1666666667rem)}96%{clip:rect(0.12rem, 99999px, 5rem, 0);transform:skew(12.8deg);transform:translateX(0.3888888889rem)}96.6666666667%{clip:rect(0.18rem, 99999px, 4.4rem, 0);transform:skew(7.6deg);transform:translateX(0.2037037037rem)}97.3333333333%{clip:rect(0.04rem, 99999px, 2.3rem, 0);transform:skew(13.7deg);transform:translateX(-0.1666666667rem)}98%{clip:rect(0.06rem, 99999px, 1.7rem, 0);transform:skew(0.5deg);transform:translateX(0.1666666667rem)}98.6666666667%{clip:rect(0.2rem, 99999px, 1rem, 0);transform:skew(11deg);transform:translateX(0.3888888889rem)}99.3333333333%{clip:rect(0.16rem, 99999px, 9rem, 0);transform:skew(6.7deg);transform:translateX(0rem)}}@keyframes svelte-19glm00-glitch-skew{0%{transform:skew(3deg)}10%{transform:skew(2deg)}20%{transform:skew(2deg)}30%{transform:skew(5deg)}40%{transform:skew(-4deg)}50%{transform:skew(-3deg)}60%{transform:skew(3deg)}70%{transform:skew(-4deg)}80%{transform:skew(-1deg)}90%{transform:skew(5deg)}}#bar.svelte-19glm00 .logo.hover-effect-1.logo-behind-a.svelte-19glm00{color:white;transform:translateX(-0.5rem);color:#ffc800 !important;text-shadow:-2px 0 #ffc800, 2px 2px #ffc800;clip:rect(44px, 450px, 56px, 0);animation:svelte-19glm00-glitch-anim2 5s infinite linear alternate-reverse}#bar.svelte-19glm00 .logo.hover-effect-1.logo-behind-b.svelte-19glm00{color:rgb(165, 49, 49) !important;z-index:1;transform:translateX(0.2rem);text-shadow:-2px 0 #aa10f2;clip:rect(44px, 450px, 56px, 0);animation:svelte-19glm00-glitch-anim 5s infinite linear alternate-reverse}#bar.svelte-19glm00 .logo.logo-behind.svelte-19glm00{width:0px;height:0px;overflow:visible;pointer-events:none}#bar.svelte-19glm00 .logo.logo-behind.svelte-19glm00:not(.hovered){display:none}#bar.svelte-19glm00 #menus.svelte-19glm00{margin-left:auto;display:flex}#bar.svelte-19glm00 #menus #menu.svelte-19glm00{height:10rem;display:flex;flex-direction:column;justify-content:space-between;margin-right:1rem}#bar.svelte-19glm00 #menus #menu.svelte-19glm00 .menu-item{font-weight:750;font-style:italic;width:fit-content}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE4RWtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJhci5zdmVsdGUiXX0=*/`, "",{"version":3,"sources":["webpack://./src/components/Bar.svelte"],"names":[],"mappings":"AA8EkB,mCAAA,UAAA,CAAA,eAAA,CAAA,kBAAA,CAAA,YAAA,CAAA,cAAA,CAAA,UAAA,CAAA,wCAAA,gBAAA,CAAA,yCAAA,cAAA,CAAA,gBAAA,CAAA,kBAAA,CAAA,oBAAA,CAAA,qDAAA,iBAAA,CAAA,iDAAA,sBAAA,CAAA,gEAAA,2EAAA,CAAA,mCAAA,GAAA,mCAAA,CAAA,MAAA,iCAAA,CAAA,IAAA,mCAAA,CAAA,MAAA,iCAAA,CAAA,IAAA,mCAAA,CAAA,MAAA,iCAAA,CAAA,IAAA,mCAAA,CAAA,MAAA,iCAAA,CAAA,KAAA,mCAAA,CAAA,CAAA,mCAAA,GAAA,mCAAA,CAAA,MAAA,iCAAA,CAAA,IAAA,mCAAA,CAAA,MAAA,iCAAA,CAAA,IAAA,mCAAA,CAAA,MAAA,iCAAA,CAAA,IAAA,mCAAA,CAAA,MAAA,iCAAA,CAAA,KAAA,mCAAA,CAAA,CAAA,uCAAA,GAAA,kCAAA,CAAA,uBAAA,CAAA,GAAA,kCAAA,CAAA,uBAAA,CAAA,GAAA,kCAAA,CAAA,uBAAA,CAAA,GAAA,kCAAA,CAAA,uBAAA,CAAA,GAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,gCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,IAAA,kCAAA,CAAA,uBAAA,CAAA,CAAA,iCAAA,GAAA,oBAAA,CAAA,GAAA,oBAAA,CAAA,GAAA,oBAAA,CAAA,GAAA,oBAAA,CAAA,GAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,CAAA,8EAAA,wBAAA,CAAA,qLAAA,CAAA,8EAAA,wBAAA,CAAA,yHAAA,CAAA,wDAAA,yEAAA,CAAA,sCAAA,GAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,GAAA,oCAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,GAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,GAAA,kCAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,GAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,gCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,gCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,gCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,kCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,SAAA,CAAA,CAAA,uCAAA,GAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,cAAA,oCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,cAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,GAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,cAAA,sCAAA,CAAA,uBAAA,CAAA,oCAAA,CAAA,cAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,GAAA,qCAAA,CAAA,oBAAA,CAAA,0BAAA,CAAA,cAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,cAAA,qCAAA,CAAA,sBAAA,CAAA,6BAAA,CAAA,GAAA,qCAAA,CAAA,oBAAA,CAAA,qCAAA,CAAA,cAAA,sCAAA,CAAA,oBAAA,CAAA,qCAAA,CAAA,cAAA,qCAAA,CAAA,qBAAA,CAAA,qCAAA,CAAA,GAAA,qCAAA,CAAA,sBAAA,CAAA,oCAAA,CAAA,cAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,cAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,oCAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,oBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,qCAAA,CAAA,uBAAA,CAAA,6BAAA,CAAA,eAAA,oCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,6BAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,oCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,oCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,mCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,mCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,qCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,oCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,qBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,oBAAA,CAAA,sCAAA,CAAA,IAAA,qCAAA,CAAA,sBAAA,CAAA,oCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,sBAAA,CAAA,oCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,oCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,uBAAA,CAAA,oCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,oBAAA,CAAA,sCAAA,CAAA,eAAA,qCAAA,CAAA,uBAAA,CAAA,oCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,oCAAA,CAAA,IAAA,sCAAA,CAAA,oBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,mCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,0BAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,oCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,oCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,oBAAA,CAAA,qCAAA,CAAA,eAAA,mCAAA,CAAA,oBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,sCAAA,CAAA,eAAA,qCAAA,CAAA,qBAAA,CAAA,qCAAA,CAAA,eAAA,oCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,mCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,oCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,qBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,oCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,oCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,qCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,IAAA,oCAAA,CAAA,uBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,sCAAA,CAAA,uBAAA,CAAA,sCAAA,CAAA,IAAA,sCAAA,CAAA,sBAAA,CAAA,qCAAA,CAAA,eAAA,mCAAA,CAAA,qBAAA,CAAA,qCAAA,CAAA,eAAA,oCAAA,CAAA,sBAAA,CAAA,0BAAA,CAAA,CAAA,sCAAA,GAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,qBAAA,CAAA,IAAA,qBAAA,CAAA,IAAA,oBAAA,CAAA,IAAA,qBAAA,CAAA,IAAA,qBAAA,CAAA,IAAA,oBAAA,CAAA,CAAA,sEAAA,WAAA,CAAA,6BAAA,CAAA,wBAAA,CAAA,2CAAA,CAAA,+BAAA,CAAA,0EAAA,CAAA,sEAAA,iCAAA,CAAA,SAAA,CAAA,4BAAA,CAAA,0BAAA,CAAA,+BAAA,CAAA,yEAAA,CAAA,qDAAA,SAAA,CAAA,UAAA,CAAA,gBAAA,CAAA,mBAAA,CAAA,mEAAA,YAAA,CAAA,0CAAA,gBAAA,CAAA,YAAA,CAAA,gDAAA,YAAA,CAAA,YAAA,CAAA,qBAAA,CAAA,6BAAA,CAAA,iBAAA,CAAA,2DAAA,eAAA,CAAA,iBAAA,CAAA,iBAAA;AA7ElB,yLAAyL","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 300:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.year.svelte-1njzqxq.svelte-1njzqxq{font-weight:bolder;font-size:2rem;margin-bottom:0.1rem;margin-top:0.9rem}.demo.svelte-1njzqxq.svelte-1njzqxq{width:fit-content;display:flex}.demo.svelte-1njzqxq .svelte-1njzqxq{font-size:1rem}.demo.svelte-1njzqxq .name.svelte-1njzqxq{font-weight:bold}main.svelte-1njzqxq.svelte-1njzqxq{width:100%;max-width:40rem;min-height:100%;height:fit-content;display:flex;flex-direction:column;max-width:var(--main-max-width)}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmF2RGVtb3Muc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXdMa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRmF2RGVtb3Muc3ZlbHRlIl19*/`, "",{"version":3,"sources":["webpack://./src/components/FavDemos.svelte"],"names":[],"mappings":"AAwLkB,oCAAA,kBAAA,CAAA,cAAA,CAAA,oBAAA,CAAA,iBAAA,CAAA,oCAAA,iBAAA,CAAA,YAAA,CAAA,qCAAA,cAAA,CAAA,0CAAA,gBAAA,CAAA,mCAAA,UAAA,CAAA,eAAA,CAAA,eAAA,CAAA,kBAAA,CAAA,YAAA,CAAA,qBAAA,CAAA,+BAAA;AAvLlB,qMAAqM","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 952:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `#bar.svelte-1pmkho9.svelte-1pmkho9{width:100%;margin-top:auto;display:flex;flex-wrap:wrap;justify-content:flex-end;padding-top:2rem;padding-bottom:2rem}#bar.svelte-1pmkho9 svg{cursor:pointer;aspect-ratio:1/1;width:2rem;margin-right:auto}#bar.svelte-1pmkho9 svg:active{filter:invert(1);background:white}#bar.svelte-1pmkho9 .svelte-1pmkho9{font-weight:600}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9vdGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnRGtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkZvb3Rlci5zdmVsdGUiXX0=*/`, "",{"version":3,"sources":["webpack://./src/components/Footer.svelte"],"names":[],"mappings":"AAgDkB,mCAAA,UAAA,CAAA,eAAA,CAAA,YAAA,CAAA,cAAA,CAAA,wBAAA,CAAA,gBAAA,CAAA,mBAAA,CAAA,wBAAA,cAAA,CAAA,gBAAA,CAAA,UAAA,CAAA,iBAAA,CAAA,+BAAA,gBAAA,CAAA,gBAAA,CAAA,oCAAA,eAAA;AA/ClB,iMAAiM","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 25:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.masonry.svelte-1rbj9nr{max-width:100%}.container.svelte-1rbj9nr{display:flex;flex-wrap:wrap}.image.svelte-1rbj9nr{position:relative;height:100%}.image.svelte-1rbj9nr>*{width:100%;height:100%}.hidden.svelte-1rbj9nr{visibility:hidden}.stashed.svelte-1rbj9nr{display:none}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FsbGVyeS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMENFLHVCQUFTLENBQ1AsU0FBUyxDQUFFLElBQ2IsQ0FFQSx5QkFBVyxDQUNULE9BQU8sQ0FBRSxJQUFJLENBQ2IsU0FBUyxDQUFFLElBQ2IsQ0FFQSxxQkFBTyxDQUNMLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE1BQU0sQ0FBRSxJQUNWLENBRUEscUJBQU0sQ0FBVyxDQUFHLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQ1YsQ0FFQSxzQkFBUSxDQUNOLFVBQVUsQ0FBRSxNQUNkLENBQ0EsdUJBQVMsQ0FDUCxPQUFPLENBQUUsSUFDWCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJHYWxsZXJ5LnN2ZWx0ZSJdfQ==*/`, "",{"version":3,"sources":["webpack://./src/components/Gallery.svelte"],"names":[],"mappings":"AA0CE,wBACE,cACF,CAEA,0BACE,YAAa,CACb,cACF,CAEA,sBACE,iBAAkB,CAClB,WACF,CAEA,wBACE,UAAW,CACX,WACF,CAEA,uBACE,iBACF,CACA,wBACE,YACF;AAjEF,qhBAAqhB","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 201:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.menu-item.svelte-1j874il{font-weight:600;font-style:italic;width:fit-content}.selected.svelte-1j874il{background:black;color:white}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGluay5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBOEJrQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJMaW5rLnN2ZWx0ZSJdfQ==*/`, "",{"version":3,"sources":["webpack://./src/components/Link.svelte"],"names":[],"mappings":"AA8BkB,0BAAA,eAAA,CAAA,iBAAA,CAAA,iBAAA,CAAA,yBAAA,gBAAA,CAAA,WAAA;AA7BlB,6LAA6L","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 926:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.name.svelte-1pobciu.svelte-1pobciu{font-weight:bolder;font-size:2rem;margin-bottom:1rem;margin-top:0.9rem}.gallery.svelte-1pobciu.svelte-1pobciu{display:flex;flex-wrap:wrap}wbr.svelte-1pobciu.svelte-1pobciu{display:block;height:0.02rem;margin:none}.description.svelte-1pobciu.svelte-1pobciu{display:flex;flex-direction:column;font-weight:var(--text-font-weight)}.description.svelte-1pobciu a.svelte-1pobciu{font-weight:var(--link-font-weight)}.description.svelte-1pobciu .svelte-1pobciu{font-weight:var(--text-font-weight);font-size:1rem}main.svelte-1pobciu.svelte-1pobciu{width:100%;max-width:40rem;min-height:100%;height:fit-content;display:flex;flex-direction:column;max-width:var(--main-max-width)}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvamVjdHMuc3Z4IiwibWFwcGluZ3MiOiJBQThDa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUHJvamVjdHMuc3Z4Il19*/`, "",{"version":3,"sources":["webpack://./src/components/Projects.svx"],"names":[],"mappings":"AA8CkB,oCAAA,kBAAA,CAAA,cAAA,CAAA,kBAAA,CAAA,iBAAA,CAAA,uCAAA,YAAA,CAAA,cAAA,CAAA,kCAAA,aAAA,CAAA,cAAA,CAAA,WAAA,CAAA,2CAAA,YAAA,CAAA,qBAAA,CAAA,mCAAA,CAAA,6CAAA,mCAAA,CAAA,4CAAA,mCAAA,CAAA,cAAA,CAAA,mCAAA,UAAA,CAAA,eAAA,CAAA,eAAA,CAAA,kBAAA,CAAA,YAAA,CAAA,qBAAA,CAAA,+BAAA;AA7ClB,6LAA6L","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 16:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `*{user-select:none}*{color:black}*::selection{background:black;color:white}.menu-item{color:white;background:black}.menu-item:hover{color:black !important;background:white}#logo{color:white;background:black}::-webkit-scrollbar{background:black}::-webkit-scrollbar-track{background:white}::-webkit-scrollbar-thumb{background:black}main.svelte-v3tjz9{width:100%;max-width:40rem;height:100%;display:flex;flex-direction:column;max-width:var(--main-max-width);margin-right:auto;margin-left:auto}canvas.svelte-v3tjz9{position:absolute;top:0;left:0;z-index:-5;width:100%;height:100%;margin:auto;padding:0}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3BsYXNoLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtWGtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlNwbGFzaC5zdmVsdGUiXX0=*/`, "",{"version":3,"sources":["webpack://./src/components/Splash.svelte"],"names":[],"mappings":"AAmXkB,EAAA,gBAAA,CAAA,EAAA,WAAA,CAAA,aAAA,gBAAA,CAAA,WAAA,CAAA,WAAA,WAAA,CAAA,gBAAA,CAAA,iBAAA,sBAAA,CAAA,gBAAA,CAAA,MAAA,WAAA,CAAA,gBAAA,CAAA,oBAAA,gBAAA,CAAA,0BAAA,gBAAA,CAAA,0BAAA,gBAAA,CAAA,mBAAA,UAAA,CAAA,eAAA,CAAA,WAAA,CAAA,YAAA,CAAA,qBAAA,CAAA,+BAAA,CAAA,iBAAA,CAAA,gBAAA,CAAA,qBAAA,iBAAA,CAAA,KAAA,CAAA,MAAA,CAAA,UAAA,CAAA,UAAA,CAAA,WAAA,CAAA,WAAA,CAAA,SAAA;AAlXlB,iMAAiM","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 378:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `*{color:black;font-family:"Petrona";font-weight:400}*::selection{background:black;color:white}.title-container.svelte-1xdostg.svelte-1xdostg{margin-left:1rem;width:fit-content;cursor:pointer;display:flex;align-items:center}.title-container.svelte-1xdostg svg.svelte-1xdostg{transition:transform 0.1s ease}.title-container.svelte-1xdostg.svelte-1xdostg:active{filter:invert(1);background:white}.title-container.svelte-1xdostg .title.svelte-1xdostg{font-weight:bolder;font-size:2rem;margin-bottom:2rem;margin-top:2rem}main.svelte-1xdostg.svelte-1xdostg{width:100%;max-width:40rem;min-height:100%;height:fit-content;display:flex;flex-direction:column;max-width:var(--main-max-width)}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJ0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE4SWtCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbImFydC5zdmVsdGUiXX0=*/`, "",{"version":3,"sources":["webpack://./src/components/art.svelte"],"names":[],"mappings":"AA8IkB,EAAA,WAAA,CAAA,qBAAA,CAAA,eAAA,CAAA,aAAA,gBAAA,CAAA,WAAA,CAAA,+CAAA,gBAAA,CAAA,iBAAA,CAAA,cAAA,CAAA,YAAA,CAAA,kBAAA,CAAA,mDAAA,8BAAA,CAAA,sDAAA,gBAAA,CAAA,gBAAA,CAAA,sDAAA,kBAAA,CAAA,cAAA,CAAA,kBAAA,CAAA,eAAA,CAAA,mCAAA,UAAA,CAAA,eAAA,CAAA,eAAA,CAAA,kBAAA,CAAA,YAAA,CAAA,qBAAA,CAAA,+BAAA;AA7IlB,yLAAyL","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 464:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.player.svelte-1d9fbv.svelte-1d9fbv::part(duration){display:none;font-family:"Petrona" !important}.player.svelte-1d9fbv.svelte-1d9fbv::part(currenttime){display:none;font-weight:400}.player.svelte-1d9fbv.svelte-1d9fbv::part(input){overflow:hidden}.player.svelte-1d9fbv.svelte-1d9fbv::part(path2){stroke:black}.title.svelte-1d9fbv.svelte-1d9fbv{font-weight:bolder;font-size:2rem;margin-left:1.5rem;margin-bottom:0.6rem;margin-top:0.9rem}.tracks.svelte-1d9fbv.svelte-1d9fbv{display:flex;flex-wrap:wrap}.tracks.svelte-1d9fbv .track.svelte-1d9fbv{display:flex;width:fit-content;flex-direction:column;align-items:end;margin-bottom:0.5rem}*{color:black;font-family:"Petrona";font-weight:400}*::selection{background:black;color:white}main.svelte-1d9fbv.svelte-1d9fbv{width:100%;max-width:40rem;min-height:100%;height:fit-content;display:flex;flex-direction:column;max-width:var(--main-max-width)}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVzaWMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWdGa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsibXVzaWMuc3ZlbHRlIl19*/`, "",{"version":3,"sources":["webpack://./src/components/music.svelte"],"names":[],"mappings":"AAgFkB,oDAAA,YAAA,CAAA,gCAAA,CAAA,uDAAA,YAAA,CAAA,eAAA,CAAA,iDAAA,eAAA,CAAA,iDAAA,YAAA,CAAA,mCAAA,kBAAA,CAAA,cAAA,CAAA,kBAAA,CAAA,oBAAA,CAAA,iBAAA,CAAA,oCAAA,YAAA,CAAA,cAAA,CAAA,2CAAA,YAAA,CAAA,iBAAA,CAAA,qBAAA,CAAA,eAAA,CAAA,oBAAA,CAAA,EAAA,WAAA,CAAA,qBAAA,CAAA,eAAA,CAAA,aAAA,gBAAA,CAAA,WAAA,CAAA,iCAAA,UAAA,CAAA,eAAA,CAAA,eAAA,CAAA,kBAAA,CAAA,YAAA,CAAA,qBAAA,CAAA,+BAAA;AA/ElB,6LAA6L","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 712:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.container.svelte-bmpzgc{width:100%;height:100%;position:fixed;display:flex;flex-direction:column;align-items:center;width:100vw;height:100vh;left:0;top:0;z-index:100;background:black}.c-svelteZoom.svelte-bmpzgc{width:100%;height:100%;position:absolute;transform-origin:0 0;backface-visibility:hidden;-webkit-backface-visibility:hidden;-moz-backface-visibility:hidden;-o-backface-visibility:hidden;-ms-backface-visibility:hidden;-webkit-user-drag:none;-moz-user-drag:none;-o-user-drag:none;user-drag:none;touch-action:none}.c-svelteZoom--contain.svelte-bmpzgc{object-fit:contain}.c-svelteZoom--no-contain.svelte-bmpzgc{object-fit:contain}.c-svelteZoom--transition.svelte-bmpzgc{transition:transform 0.2s}.c-svelteZoom--visible.svelte-bmpzgc{visibility:visible}.c-svelteZoom--hidden.svelte-bmpzgc{visibility:hidden}.c-svelteZoom--willChange.svelte-bmpzgc{will-change:transform}.close-button.svelte-bmpzgc{z-index:1;background:black;position:absolute;right:1rem;cursor:pointer}.close-button.svelte-bmpzgc:hover{filter:invert(1)}.close-button.svelte-bmpzgc svg{fill:white;stroke:white;aspect-ratio:1/1;width:6rem}.hidden.svelte-bmpzgc{display:none}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWtXa0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiaW5kZXguc3ZlbHRlIl19*/`, "",{"version":3,"sources":["webpack://./src/components/svelte-zoom/index.svelte"],"names":[],"mappings":"AAkWkB,yBAAA,UAAA,CAAA,WAAA,CAAA,cAAA,CAAA,YAAA,CAAA,qBAAA,CAAA,kBAAA,CAAA,WAAA,CAAA,YAAA,CAAA,MAAA,CAAA,KAAA,CAAA,WAAA,CAAA,gBAAA,CAAA,4BAAA,UAAA,CAAA,WAAA,CAAA,iBAAA,CAAA,oBAAA,CAAA,0BAAA,CAAA,kCAAA,CAAA,+BAAA,CAAA,6BAAA,CAAA,8BAAA,CAAA,sBAAA,CAAA,mBAAA,CAAA,iBAAA,CAAA,cAAA,CAAA,iBAAA,CAAA,qCAAA,kBAAA,CAAA,wCAAA,kBAAA,CAAA,wCAAA,yBAAA,CAAA,qCAAA,kBAAA,CAAA,oCAAA,iBAAA,CAAA,wCAAA,qBAAA,CAAA,4BAAA,SAAA,CAAA,gBAAA,CAAA,iBAAA,CAAA,UAAA,CAAA,cAAA,CAAA,kCAAA,gBAAA,CAAA,gCAAA,UAAA,CAAA,YAAA,CAAA,gBAAA,CAAA,UAAA,CAAA,sBAAA,YAAA;AAjWlB,6LAA6L","sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 563:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(864);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(352);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(393);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(446), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(591), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `@font-face {
  font-family: "Petrona";
  /* font-style: normal; */
  /* font-weight: 400; */
  src: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) format("truetype");

}
@font-face {
  font-family: "Petrona";
  src: url(${___CSS_LOADER_URL_REPLACEMENT_1___}) format("truetype");
  font-style: italic;
}


* {
  -webkit-tap-highlight-color: transparent;
  --main-max-width: 40rem;
  --text-font-weight: 500;
  --link-font-weight: 800;
}

body {
  margin: 0;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0px;
  width: 100%;
  height: 100%;
  background: white;
  /* filter: invert() hue-rotate(2.14rad) saturate(0.5); */

}
html {
  width: 100%;
  height: 100%;
}

canvas {
  max-width: 100%;
  max-height: 100%;
  width: 100%;
  height: 100%;
  touch-action: none;
}
`, "",{"version":3,"sources":["webpack://./public/style.css"],"names":[],"mappings":"AAAA;EACE,sBAAsB;EACtB,wBAAwB;EACxB,sBAAsB;EACtB,+DAA8D;;AAEhE;AACA;EACE,sBAAsB;EACtB,+DAAqE;EACrE,kBAAkB;AACpB;;;AAGA;EACE,wCAAwC;EACxC,uBAAuB;EACvB,uBAAuB;EACvB,uBAAuB;AACzB;;AAEA;EACE,SAAS;EACT,UAAU;EACV,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,WAAW;EACX,WAAW;EACX,YAAY;EACZ,iBAAiB;EACjB,wDAAwD;;AAE1D;AACA;EACE,WAAW;EACX,YAAY;AACd;;AAEA;EACE,eAAe;EACf,gBAAgB;EAChB,WAAW;EACX,YAAY;EACZ,kBAAkB;AACpB","sourcesContent":["@font-face {\r\n  font-family: \"Petrona\";\r\n  /* font-style: normal; */\r\n  /* font-weight: 400; */\r\n  src: url(\"./Petrona-VariableFont_wght.ttf\") format(\"truetype\");\r\n\r\n}\r\n@font-face {\r\n  font-family: \"Petrona\";\r\n  src: url(\"./Petrona-Italic-VariableFont_wght.ttf\") format(\"truetype\");\r\n  font-style: italic;\r\n}\r\n\r\n\r\n* {\r\n  -webkit-tap-highlight-color: transparent;\r\n  --main-max-width: 40rem;\r\n  --text-font-weight: 500;\r\n  --link-font-weight: 800;\r\n}\r\n\r\nbody {\r\n  margin: 0;\r\n  padding: 0;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  margin: 0px;\r\n  width: 100%;\r\n  height: 100%;\r\n  background: white;\r\n  /* filter: invert() hue-rotate(2.14rad) saturate(0.5); */\r\n\r\n}\r\nhtml {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\ncanvas {\r\n  max-width: 100%;\r\n  max-height: 100%;\r\n  width: 100%;\r\n  height: 100%;\r\n  touch-action: none;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 304:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("./images/c9e01a1673477e113f5c945ea3fd3553.webp");

/***/ }),

/***/ 352:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 393:
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ 864:
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ 703:
/***/ (function(module) {

/*! lozad.js - v1.16.0 - 2020-09-06
* https://github.com/ApoorvSaxena/lozad.js
* Copyright (c) 2020 Apoorv Saxena; Licensed MIT */
!function(t,e){ true?module.exports=e():0}(this,function(){"use strict";
/**
   * Detect IE browser
   * @const {boolean}
   * @private
   */var g="undefined"!=typeof document&&document.documentMode,f={rootMargin:"0px",threshold:0,load:function(t){if("picture"===t.nodeName.toLowerCase()){var e=t.querySelector("img"),r=!1;null===e&&(e=document.createElement("img"),r=!0),g&&t.getAttribute("data-iesrc")&&(e.src=t.getAttribute("data-iesrc")),t.getAttribute("data-alt")&&(e.alt=t.getAttribute("data-alt")),r&&t.append(e)}if("video"===t.nodeName.toLowerCase()&&!t.getAttribute("data-src")&&t.children){for(var a=t.children,o=void 0,i=0;i<=a.length-1;i++)(o=a[i].getAttribute("data-src"))&&(a[i].src=o);t.load()}t.getAttribute("data-poster")&&(t.poster=t.getAttribute("data-poster")),t.getAttribute("data-src")&&(t.src=t.getAttribute("data-src")),t.getAttribute("data-srcset")&&t.setAttribute("srcset",t.getAttribute("data-srcset"));var n=",";if(t.getAttribute("data-background-delimiter")&&(n=t.getAttribute("data-background-delimiter")),t.getAttribute("data-background-image"))t.style.backgroundImage="url('"+t.getAttribute("data-background-image").split(n).join("'),url('")+"')";else if(t.getAttribute("data-background-image-set")){var d=t.getAttribute("data-background-image-set").split(n),u=d[0].substr(0,d[0].indexOf(" "))||d[0];// Substring before ... 1x
u=-1===u.indexOf("url(")?"url("+u+")":u,1===d.length?t.style.backgroundImage=u:t.setAttribute("style",(t.getAttribute("style")||"")+"background-image: "+u+"; background-image: -webkit-image-set("+d+"); background-image: image-set("+d+")")}t.getAttribute("data-toggle-class")&&t.classList.toggle(t.getAttribute("data-toggle-class"))},loaded:function(){}};function A(t){t.setAttribute("data-loaded",!0)}var m=function(t){return"true"===t.getAttribute("data-loaded")},v=function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:document;return t instanceof Element?[t]:t instanceof NodeList?t:e.querySelectorAll(t)};return function(){var r,a,o=0<arguments.length&&void 0!==arguments[0]?arguments[0]:".lozad",t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},e=Object.assign({},f,t),i=e.root,n=e.rootMargin,d=e.threshold,u=e.load,g=e.loaded,s=void 0;"undefined"!=typeof window&&window.IntersectionObserver&&(s=new IntersectionObserver((r=u,a=g,function(t,e){t.forEach(function(t){(0<t.intersectionRatio||t.isIntersecting)&&(e.unobserve(t.target),m(t.target)||(r(t.target),A(t.target),a(t.target)))})}),{root:i,rootMargin:n,threshold:d}));for(var c,l=v(o,i),b=0;b<l.length;b++)(c=l[b]).getAttribute("data-placeholder-background")&&(c.style.background=c.getAttribute("data-placeholder-background"));return{observe:function(){for(var t=v(o,i),e=0;e<t.length;e++)m(t[e])||(s?s.observe(t[e]):(u(t[e]),A(t[e]),g(t[e])))},triggerLoad:function(t){m(t)||(u(t),A(t),g(t))},observer:s}}});


/***/ }),

/***/ 379:
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 569:
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 216:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 565:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 795:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 589:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 567:
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\"><path d=\"M481-29 346-160H160v-186L26-480l134-134v-186h186l135-134 133 134h186v186l134 134-134 134v186H614L481-29Zm0-191q108 0 183.5-76.125T740-481q0-107.917-75.542-183.458Q588.917-740 481-740v520Zm0 107 107.917-107H740v-151l109-109-109-109v-151H589L481-849 371-740H220v151L111-480l109 109v151h150l111 107Zm-1-368Z\"></path></svg>"

/***/ }),

/***/ 461:
/***/ ((module) => {

module.exports = "<svg fill=\"#000000\" viewBox=\"0 0 32 32\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>forbid</title><path d=\"M18.828 16l4.243 4.243-2.828 2.828-4.243-4.243-4.243 4.243-2.828-2.828 4.243-4.243-4.243-4.243 2.828-2.828 4.243 4.243 4.243-4.243 2.828 2.828-4.243 4.243z\"></path></svg>"

/***/ }),

/***/ 591:
/***/ ((module) => {

"use strict";
module.exports = "./dcfc4364a27f80004241.ttf";

/***/ }),

/***/ 446:
/***/ ((module) => {

"use strict";
module.exports = "./cf375f38268a2ad9eef9.ttf";

/***/ }),

/***/ 809:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 R;\\n  vec2 canvasR;\\n  float time;\\n  float ptr_pressure;\\n  float mouse_pos_x;\\n  float mouse_pos_y;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\n#ifndef SPECTRAL\\n#define SPECTRAL\\n\\nconst int SPECTRAL_SIZE = 38;\\nconst float SPECTRAL_GAMMA = 2.4;\\nconst float SPECTRAL_EPSILON = 0.0001;\\n\\nfloat spectral_uncompand(float x) {\\n  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);\\n}\\n\\nfloat spectral_compand(float x) {\\n  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;\\n}\\n\\nvec3 spectral_srgb_to_linear(vec3 srgb) {\\n    return vec3(spectral_uncompand(srgb[0]), spectral_uncompand(srgb[1]), spectral_uncompand(srgb[2]));\\n}\\n\\nvec3 spectral_linear_to_srgb(vec3 lrgb) {\\n    return clamp(vec3(spectral_compand(lrgb[0]), spectral_compand(lrgb[1]), spectral_compand(lrgb[2])), 0.0, 1.0);\\n}\\n\\nvoid spectral_upsampling(vec3 lrgb, out float w, out float c, out float m, out float y, out float r, out float g, out float b) {\\n    w = min(lrgb.r, min(lrgb.g, lrgb.b));\\n\\n    lrgb -= w;\\n\\n    c = min(lrgb.g, lrgb.b);\\n    m = min(lrgb.r, lrgb.b);\\n    y = min(lrgb.r, lrgb.g);\\n    r = min(max(0., lrgb.r - lrgb.b), max(0., lrgb.r - lrgb.g));\\n    g = min(max(0., lrgb.g - lrgb.b), max(0., lrgb.g - lrgb.r));\\n    b = min(max(0., lrgb.b - lrgb.g), max(0., lrgb.b - lrgb.r));\\n}\\n\\nvoid spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {\\n    float w, c, m, y, r, g, b;\\n    \\n    spectral_upsampling(lrgb, w, c, m, y, r, g, b);\\n    \\n     R[0] = max(SPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\\n     R[1] = max(SPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\\n     R[2] = max(SPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\\n     R[3] = max(SPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\\n     R[4] = max(SPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\\n     R[5] = max(SPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\\n     R[6] = max(SPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\\n     R[7] = max(SPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\\n     R[8] = max(SPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\\n     R[9] = max(SPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\\n    R[10] = max(SPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\\n    R[11] = max(SPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\\n    R[12] = max(SPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\\n    R[13] = max(SPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\\n    R[14] = max(SPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\\n    R[15] = max(SPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\\n    R[16] = max(SPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\\n    R[17] = max(SPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\\n    R[18] = max(SPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\\n    R[19] = max(SPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\\n    R[20] = max(SPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\\n    R[21] = max(SPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\\n    R[22] = max(SPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\\n    R[23] = max(SPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\\n    R[24] = max(SPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\\n    R[25] = max(SPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\\n    R[26] = max(SPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\\n    R[27] = max(SPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\\n    R[28] = max(SPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\\n    R[29] = max(SPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\\n    R[30] = max(SPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\\n    R[31] = max(SPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\\n    R[32] = max(SPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\\n    R[33] = max(SPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\\n    R[34] = max(SPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\\n    R[35] = max(SPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\\n    R[36] = max(SPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\\n    R[37] = max(SPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\\n}\\n\\nvec3 spectral_xyz_to_srgb(vec3 xyz) {\\n    mat3 XYZ_RGB;\\n\\n    XYZ_RGB[0] = vec3( 3.24306333, -1.53837619, -0.49893282);\\n    XYZ_RGB[1] = vec3(-0.96896309,  1.87542451,  0.04154303);\\n    XYZ_RGB[2] = vec3( 0.05568392, -0.20417438,  1.05799454);\\n    \\n    float r = dot(XYZ_RGB[0], xyz);\\n    float g = dot(XYZ_RGB[1], xyz);\\n    float b = dot(XYZ_RGB[2], xyz);\\n\\n    return spectral_linear_to_srgb(vec3(r, g, b));\\n}\\n\\nvec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {\\n    vec3 xyz = vec3(0.0);\\n    \\n    xyz +=  R[0] * vec3(0.00006469, 0.00000184, 0.00030502);\\n    xyz +=  R[1] * vec3(0.00021941, 0.00000621, 0.00103681);\\n    xyz +=  R[2] * vec3(0.00112057, 0.00003101, 0.00531314);\\n    xyz +=  R[3] * vec3(0.00376661, 0.00010475, 0.01795439);\\n    xyz +=  R[4] * vec3(0.01188055, 0.00035364, 0.05707758);\\n    xyz +=  R[5] * vec3(0.02328644, 0.00095147, 0.11365162);\\n    xyz +=  R[6] * vec3(0.03455942, 0.00228226, 0.17335873);\\n    xyz +=  R[7] * vec3(0.03722379, 0.00420733, 0.19620658);\\n    xyz +=  R[8] * vec3(0.03241838, 0.00668880, 0.18608237);\\n    xyz +=  R[9] * vec3(0.02123321, 0.00988840, 0.13995048);\\n    xyz += R[10] * vec3(0.01049099, 0.01524945, 0.08917453);\\n    xyz += R[11] * vec3(0.00329584, 0.02141831, 0.04789621);\\n    xyz += R[12] * vec3(0.00050704, 0.03342293, 0.02814563);\\n    xyz += R[13] * vec3(0.00094867, 0.05131001, 0.01613766);\\n    xyz += R[14] * vec3(0.00627372, 0.07040208, 0.00775910);\\n    xyz += R[15] * vec3(0.01686462, 0.08783871, 0.00429615);\\n    xyz += R[16] * vec3(0.02868965, 0.09424905, 0.00200551);\\n    xyz += R[17] * vec3(0.04267481, 0.09795667, 0.00086147);\\n    xyz += R[18] * vec3(0.05625475, 0.09415219, 0.00036904);\\n    xyz += R[19] * vec3(0.06947040, 0.08678102, 0.00019143);\\n    xyz += R[20] * vec3(0.08305315, 0.07885653, 0.00014956);\\n    xyz += R[21] * vec3(0.08612610, 0.06352670, 0.00009231);\\n    xyz += R[22] * vec3(0.09046614, 0.05374142, 0.00006813);\\n    xyz += R[23] * vec3(0.08500387, 0.04264606, 0.00002883);\\n    xyz += R[24] * vec3(0.07090667, 0.03161735, 0.00001577);\\n    xyz += R[25] * vec3(0.05062889, 0.02088521, 0.00000394);\\n    xyz += R[26] * vec3(0.03547396, 0.01386011, 0.00000158);\\n    xyz += R[27] * vec3(0.02146821, 0.00810264, 0.00000000);\\n    xyz += R[28] * vec3(0.01251646, 0.00463010, 0.00000000);\\n    xyz += R[29] * vec3(0.00680458, 0.00249138, 0.00000000);\\n    xyz += R[30] * vec3(0.00346457, 0.00125930, 0.00000000);\\n    xyz += R[31] * vec3(0.00149761, 0.00054165, 0.00000000);\\n    xyz += R[32] * vec3(0.00076970, 0.00027795, 0.00000000);\\n    xyz += R[33] * vec3(0.00040737, 0.00014711, 0.00000000);\\n    xyz += R[34] * vec3(0.00016901, 0.00006103, 0.00000000);\\n    xyz += R[35] * vec3(0.00009522, 0.00003439, 0.00000000);\\n    xyz += R[36] * vec3(0.00004903, 0.00001771, 0.00000000);\\n    xyz += R[37] * vec3(0.00002000, 0.00000722, 0.00000000);\\n\\n    return xyz;\\n}\\n\\nfloat spectral_linear_to_concentration(float l1, float l2, float t) {\\n    float t1 = l1 * pow(1.0 - t, 2.0);\\n    float t2 = l2 * pow(t, 2.0);\\n\\n    return t2 / (t1 + t2);\\n}\\n\\nvec3 spectral_mix(vec3 color1, vec3 color2, float t) {\\n    vec3 lrgb1 = spectral_srgb_to_linear(color1);\\n    vec3 lrgb2 = spectral_srgb_to_linear(color2);\\n\\n    float R1[SPECTRAL_SIZE];\\n    float R2[SPECTRAL_SIZE];\\n\\n    spectral_linear_to_reflectance(lrgb1, R1);\\n    spectral_linear_to_reflectance(lrgb2, R2);\\n\\n    float l1 = spectral_reflectance_to_xyz(R1)[1];\\n    float l2 = spectral_reflectance_to_xyz(R2)[1];\\n\\n    t = spectral_linear_to_concentration(l1, l2, t);\\n\\n    float R[SPECTRAL_SIZE];\\n\\n    for (int i = 0; i < SPECTRAL_SIZE; i++) {\\n      float KS = (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i])) + t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));\\n      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);\\n\\n      //Saunderson correction\\n      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);\\n\\n      R[i] = KM;\\n    }\\n\\n    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));\\n}\\n\\nvec4 spectral_mix(vec4 color1, vec4 color2, float t) {\\n    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\\n}\\n\\n#endif\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nvec4 blend_brushstroke(vec4 col, vec4 stroke, int blending_colour_space){\\n  // col.xyz = mix(col.xyz, stroke.xyz, stroke.w); \\n  \\n  int mode = blending_colour_space;\\n  \\n  if(stroke.w > 0.00000001){\\n    // float interpolant = stroke.w;\\n    stroke.xyz = stroke.xyz/max(stroke.w,0.001);\\n    \\n    if(mode == 0){\\n      col.xyz = spectral_mix(col.xyz, clamp(stroke.xyz,0.00001,0.99999), stroke.w);\\n      if(stroke.w > 0.99999)\\n        col.xyz = stroke.xyz;\\n    } else if(mode == 1){\\n      col.xyz = srgb_to_oklch( col.xyz );\\n      stroke.xyz = srgb_to_oklch( stroke.xyz );\\n      col.xy = mix(col.xy, stroke.xy,stroke.w);\\n      float tau = acos(-1.) * 2.;\\n      float h_a = stroke.z;\\n      float h_b = stroke.z + tau;\\n      float dist_a = abs(col.z - h_a);\\n      float dist_b = abs(col.z - h_b);\\n      if(dist_a < dist_b){\\n        col.z = mix(col.z, h_a, stroke.w);\\n      } else {\\n        col.z = mix(col.z, h_b, stroke.w);\\n      }\\n      col.z = mod(col.z, tau);\\n      // col.z = max(col.z)\\n      // if(isnan(col.z)){\\n      //   col.z = 1.;\\n      // }\\n\\n      col.xyz = oklch_to_srgb( col.xyz );\\n      col.xyz = clamp(col.xyz,0.,1.);\\n    } else {\\n      col.xyz = mix(col.xyz, stroke.xyz, stroke.w);\\n    }\\n    col.w = max(col.w, stroke.w);\\n  }\\n\\n  return col; \\n}\\n\\nuniform sampler2D fb_a;\\nuniform sampler2D fb_b;\\n\\nin vec2 uv;\\nout vec4 col;\\n\\nvec3[] pal = vec3[](\\n    vec3(0.8,0.5,0.),\\n    vec3(0.2,0.6,0.4),\\n    vec3(1.0,0.0,0.7),\\n    // vec3(1.0,1.0,0.5),\\n    vec3(0,0,0.2)\\n);\\n\\nvec3 mix_oklch(vec3 col_a, vec3 col_b, float a){\\n  // return mix(col_a,col_b,a);\\n  float tau = 3.14159265359 * 2.;\\n  float col_b_h_1 = col_b.z;\\n  float col_b_h_2 = col_b.z + tau;\\n  float dist_a = abs(col_a.z - col_b_h_1);\\n  float dist_b = abs(col_a.z - col_b_h_2);\\n  // if(dist_a < dist_b){\\n  //   col_a.z = mix(col_a.z, col_b_h_1, a);\\n  // } else {\\n  //   col_a.z = mix(col_a.z, col_b_h_2, a);\\n  // }\\n  col_a.z = mix(col_a.z,col_b.z,a);\\n\\n  col_a.x = mix(col_a.x, col_b.x, a);\\n  col_a.y = mix(col_a.y, col_b.y, a);\\n  // col_a.z = mod(col_a.z, tau);\\n  return col_a;\\n}\\n\\nvoid main() {\\n  \\n  // vec2 u = (uv + 1.)*0.5;\\n  // u = u - 0.5\\n  vec2 u = (gl_FragCoord.xy - 0.5*R)/min(R.x,R.y);\\n  \\n  vec4 tex_this_prev_frame = texture(fb_a, gl_FragCoord.xy/R);\\n  vec4 tex_lines_prev_frame = texture(fb_b, gl_FragCoord.xy/R);\\n\\n  // col = vec4(u.xyxy);\\n  col = vec4(1,0.,0.,0.);\\n  \\n  vec2 mouse_pos = vec2(mouse_pos_x, mouse_pos_y);\\n  \\n  \\n\\n  float T = time;\\n  // T = 0.;\\n  \\n\\n  for(float i = 0.; i < 6.; i++){\\n    float m = T*0.5+ sin(i + T*0.5);\\n\\n    vec2 q = vec2(\\n      sin(i + m*sin(i)),\\n      cos(i + m*cos(i))\\n    )*sin(i);\\n    q *= 0.5;\\n    vec2 v_from_mouse = (q - mouse_pos);\\n    q += normalize(v_from_mouse) * smoothstep(0.5,0.,length(v_from_mouse))*ptr_pressure;\\n\\n    float d = length(q - u);\\n    \\n    float interp = sin(i*0.5)*10.5 + 0.5 + T*0.1;\\n    interp = fract(interp);\\n    int idx = int(interp * float(pal.length())*0.9999);\\n    int idx_next = idx + 1;\\n    if(idx_next >= pal.length()){\\n      idx_next = 0;\\n    }\\n    interp = fract(interp*float(pal.length())*0.9999);\\n\\n    vec3 c_a = pal[idx];\\n    vec3 c_b = pal[idx_next];\\n    \\n    vec3 c = mix_oklch(\\n      srgb_to_oklch(c_a),\\n      srgb_to_oklch(c_b),\\n      interp\\n    );\\n    // col += smoothstep(0.4,0.,d);\\n    // col.xyz = mix(col.xyz,c,d);\\n    col.xyz = mix_oklch(\\n      col.xyz, \\n      c, \\n      smoothstep(0.6 + sin(i*0.6 + 1.5 + m)*0.2,0.,d)\\n    );\\n  }\\n\\n  if ( dot(tex_lines_prev_frame.xyz,tex_lines_prev_frame.xyz) < 0.5 ) { \\n    col.rgb -= tex_lines_prev_frame.rgb; \\n    col.xy = clamp(col.xy,vec2(0.), vec2(1));\\n    // col.z = clamp(col.z,vec2(0.), vec2(1));\\n    col.z = mod(col.z, 3.14 * 2.0);\\n  }\\n  col.xyz = oklch_to_srgb( col.xyz );\\n  col.xyz = clamp(col.xyz,0.,1.);\\n    \\n  col.w = 1.;\\n}    \\n\\n  \\n  \\n\\t\\t \";";

/***/ }),

/***/ 804:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 R;\\n  vec2 canvasR;\\n  float time;\\n  float ptr_pressure;\\n  float mouse_pos_x;\\n  float mouse_pos_y;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\n#ifndef SPECTRAL\\n#define SPECTRAL\\n\\nconst int SPECTRAL_SIZE = 38;\\nconst float SPECTRAL_GAMMA = 2.4;\\nconst float SPECTRAL_EPSILON = 0.0001;\\n\\nfloat spectral_uncompand(float x) {\\n  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);\\n}\\n\\nfloat spectral_compand(float x) {\\n  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;\\n}\\n\\nvec3 spectral_srgb_to_linear(vec3 srgb) {\\n    return vec3(spectral_uncompand(srgb[0]), spectral_uncompand(srgb[1]), spectral_uncompand(srgb[2]));\\n}\\n\\nvec3 spectral_linear_to_srgb(vec3 lrgb) {\\n    return clamp(vec3(spectral_compand(lrgb[0]), spectral_compand(lrgb[1]), spectral_compand(lrgb[2])), 0.0, 1.0);\\n}\\n\\nvoid spectral_upsampling(vec3 lrgb, out float w, out float c, out float m, out float y, out float r, out float g, out float b) {\\n    w = min(lrgb.r, min(lrgb.g, lrgb.b));\\n\\n    lrgb -= w;\\n\\n    c = min(lrgb.g, lrgb.b);\\n    m = min(lrgb.r, lrgb.b);\\n    y = min(lrgb.r, lrgb.g);\\n    r = min(max(0., lrgb.r - lrgb.b), max(0., lrgb.r - lrgb.g));\\n    g = min(max(0., lrgb.g - lrgb.b), max(0., lrgb.g - lrgb.r));\\n    b = min(max(0., lrgb.b - lrgb.g), max(0., lrgb.b - lrgb.r));\\n}\\n\\nvoid spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {\\n    float w, c, m, y, r, g, b;\\n    \\n    spectral_upsampling(lrgb, w, c, m, y, r, g, b);\\n    \\n     R[0] = max(SPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\\n     R[1] = max(SPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\\n     R[2] = max(SPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\\n     R[3] = max(SPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\\n     R[4] = max(SPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\\n     R[5] = max(SPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\\n     R[6] = max(SPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\\n     R[7] = max(SPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\\n     R[8] = max(SPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\\n     R[9] = max(SPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\\n    R[10] = max(SPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\\n    R[11] = max(SPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\\n    R[12] = max(SPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\\n    R[13] = max(SPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\\n    R[14] = max(SPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\\n    R[15] = max(SPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\\n    R[16] = max(SPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\\n    R[17] = max(SPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\\n    R[18] = max(SPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\\n    R[19] = max(SPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\\n    R[20] = max(SPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\\n    R[21] = max(SPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\\n    R[22] = max(SPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\\n    R[23] = max(SPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\\n    R[24] = max(SPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\\n    R[25] = max(SPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\\n    R[26] = max(SPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\\n    R[27] = max(SPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\\n    R[28] = max(SPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\\n    R[29] = max(SPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\\n    R[30] = max(SPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\\n    R[31] = max(SPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\\n    R[32] = max(SPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\\n    R[33] = max(SPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\\n    R[34] = max(SPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\\n    R[35] = max(SPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\\n    R[36] = max(SPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\\n    R[37] = max(SPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\\n}\\n\\nvec3 spectral_xyz_to_srgb(vec3 xyz) {\\n    mat3 XYZ_RGB;\\n\\n    XYZ_RGB[0] = vec3( 3.24306333, -1.53837619, -0.49893282);\\n    XYZ_RGB[1] = vec3(-0.96896309,  1.87542451,  0.04154303);\\n    XYZ_RGB[2] = vec3( 0.05568392, -0.20417438,  1.05799454);\\n    \\n    float r = dot(XYZ_RGB[0], xyz);\\n    float g = dot(XYZ_RGB[1], xyz);\\n    float b = dot(XYZ_RGB[2], xyz);\\n\\n    return spectral_linear_to_srgb(vec3(r, g, b));\\n}\\n\\nvec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {\\n    vec3 xyz = vec3(0.0);\\n    \\n    xyz +=  R[0] * vec3(0.00006469, 0.00000184, 0.00030502);\\n    xyz +=  R[1] * vec3(0.00021941, 0.00000621, 0.00103681);\\n    xyz +=  R[2] * vec3(0.00112057, 0.00003101, 0.00531314);\\n    xyz +=  R[3] * vec3(0.00376661, 0.00010475, 0.01795439);\\n    xyz +=  R[4] * vec3(0.01188055, 0.00035364, 0.05707758);\\n    xyz +=  R[5] * vec3(0.02328644, 0.00095147, 0.11365162);\\n    xyz +=  R[6] * vec3(0.03455942, 0.00228226, 0.17335873);\\n    xyz +=  R[7] * vec3(0.03722379, 0.00420733, 0.19620658);\\n    xyz +=  R[8] * vec3(0.03241838, 0.00668880, 0.18608237);\\n    xyz +=  R[9] * vec3(0.02123321, 0.00988840, 0.13995048);\\n    xyz += R[10] * vec3(0.01049099, 0.01524945, 0.08917453);\\n    xyz += R[11] * vec3(0.00329584, 0.02141831, 0.04789621);\\n    xyz += R[12] * vec3(0.00050704, 0.03342293, 0.02814563);\\n    xyz += R[13] * vec3(0.00094867, 0.05131001, 0.01613766);\\n    xyz += R[14] * vec3(0.00627372, 0.07040208, 0.00775910);\\n    xyz += R[15] * vec3(0.01686462, 0.08783871, 0.00429615);\\n    xyz += R[16] * vec3(0.02868965, 0.09424905, 0.00200551);\\n    xyz += R[17] * vec3(0.04267481, 0.09795667, 0.00086147);\\n    xyz += R[18] * vec3(0.05625475, 0.09415219, 0.00036904);\\n    xyz += R[19] * vec3(0.06947040, 0.08678102, 0.00019143);\\n    xyz += R[20] * vec3(0.08305315, 0.07885653, 0.00014956);\\n    xyz += R[21] * vec3(0.08612610, 0.06352670, 0.00009231);\\n    xyz += R[22] * vec3(0.09046614, 0.05374142, 0.00006813);\\n    xyz += R[23] * vec3(0.08500387, 0.04264606, 0.00002883);\\n    xyz += R[24] * vec3(0.07090667, 0.03161735, 0.00001577);\\n    xyz += R[25] * vec3(0.05062889, 0.02088521, 0.00000394);\\n    xyz += R[26] * vec3(0.03547396, 0.01386011, 0.00000158);\\n    xyz += R[27] * vec3(0.02146821, 0.00810264, 0.00000000);\\n    xyz += R[28] * vec3(0.01251646, 0.00463010, 0.00000000);\\n    xyz += R[29] * vec3(0.00680458, 0.00249138, 0.00000000);\\n    xyz += R[30] * vec3(0.00346457, 0.00125930, 0.00000000);\\n    xyz += R[31] * vec3(0.00149761, 0.00054165, 0.00000000);\\n    xyz += R[32] * vec3(0.00076970, 0.00027795, 0.00000000);\\n    xyz += R[33] * vec3(0.00040737, 0.00014711, 0.00000000);\\n    xyz += R[34] * vec3(0.00016901, 0.00006103, 0.00000000);\\n    xyz += R[35] * vec3(0.00009522, 0.00003439, 0.00000000);\\n    xyz += R[36] * vec3(0.00004903, 0.00001771, 0.00000000);\\n    xyz += R[37] * vec3(0.00002000, 0.00000722, 0.00000000);\\n\\n    return xyz;\\n}\\n\\nfloat spectral_linear_to_concentration(float l1, float l2, float t) {\\n    float t1 = l1 * pow(1.0 - t, 2.0);\\n    float t2 = l2 * pow(t, 2.0);\\n\\n    return t2 / (t1 + t2);\\n}\\n\\nvec3 spectral_mix(vec3 color1, vec3 color2, float t) {\\n    vec3 lrgb1 = spectral_srgb_to_linear(color1);\\n    vec3 lrgb2 = spectral_srgb_to_linear(color2);\\n\\n    float R1[SPECTRAL_SIZE];\\n    float R2[SPECTRAL_SIZE];\\n\\n    spectral_linear_to_reflectance(lrgb1, R1);\\n    spectral_linear_to_reflectance(lrgb2, R2);\\n\\n    float l1 = spectral_reflectance_to_xyz(R1)[1];\\n    float l2 = spectral_reflectance_to_xyz(R2)[1];\\n\\n    t = spectral_linear_to_concentration(l1, l2, t);\\n\\n    float R[SPECTRAL_SIZE];\\n\\n    for (int i = 0; i < SPECTRAL_SIZE; i++) {\\n      float KS = (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i])) + t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));\\n      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);\\n\\n      //Saunderson correction\\n      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);\\n\\n      R[i] = KM;\\n    }\\n\\n    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));\\n}\\n\\nvec4 spectral_mix(vec4 color1, vec4 color2, float t) {\\n    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\\n}\\n\\n#endif\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nvec4 blend_brushstroke(vec4 col, vec4 stroke, int blending_colour_space){\\n  // col.xyz = mix(col.xyz, stroke.xyz, stroke.w); \\n  \\n  int mode = blending_colour_space;\\n  \\n  if(stroke.w > 0.00000001){\\n    // float interpolant = stroke.w;\\n    stroke.xyz = stroke.xyz/max(stroke.w,0.001);\\n    \\n    if(mode == 0){\\n      col.xyz = spectral_mix(col.xyz, clamp(stroke.xyz,0.00001,0.99999), stroke.w);\\n      if(stroke.w > 0.99999)\\n        col.xyz = stroke.xyz;\\n    } else if(mode == 1){\\n      col.xyz = srgb_to_oklch( col.xyz );\\n      stroke.xyz = srgb_to_oklch( stroke.xyz );\\n      col.xy = mix(col.xy, stroke.xy,stroke.w);\\n      float tau = acos(-1.) * 2.;\\n      float h_a = stroke.z;\\n      float h_b = stroke.z + tau;\\n      float dist_a = abs(col.z - h_a);\\n      float dist_b = abs(col.z - h_b);\\n      if(dist_a < dist_b){\\n        col.z = mix(col.z, h_a, stroke.w);\\n      } else {\\n        col.z = mix(col.z, h_b, stroke.w);\\n      }\\n      col.z = mod(col.z, tau);\\n      // col.z = max(col.z)\\n      // if(isnan(col.z)){\\n      //   col.z = 1.;\\n      // }\\n\\n      col.xyz = oklch_to_srgb( col.xyz );\\n      col.xyz = clamp(col.xyz,0.,1.);\\n    } else {\\n      col.xyz = mix(col.xyz, stroke.xyz, stroke.w);\\n    }\\n    col.w = max(col.w, stroke.w);\\n  }\\n\\n  return col; \\n}\\n\\nuniform sampler2D fb_a;\\nuniform sampler2D fb_b;\\n\\nin vec2 uv;\\nout vec4 col;\\n\\nvoid main() {\\n  \\n  vec2 u = (gl_FragCoord.xy - 0.5*R)/min(R.x,R.y);\\n  \\n  vec4 tex_this_prev_frame = texture(fb_a, gl_FragCoord.xy/R);\\n  vec4 tex_lines_curr = texture(fb_b, gl_FragCoord.xy/R);\\n  vec4 fac = vec4(0.3,.1 - ptr_pressure * 0.3,0.9,1);\\n  col = mix(\\n    tex_this_prev_frame,\\n    tex_lines_curr.a * fac,\\n    0.01\\n  );\\n    \\n  col.w = 1.;\\n}    \\n\\n  \\n  \\n\\t\\t \";";

/***/ }),

/***/ 165:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 R;\\n  vec2 canvasR;\\n  float time;\\n  float ptr_pressure;\\n  float mouse_pos_x;\\n  float mouse_pos_y;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\nout vec2 uv;\\n\\nvec2 css_contain(vec2 u, vec2 input_res, vec2 tex_res){\\n\\tfloat input_ratio = (input_res.x/input_res.y);\\n\\tfloat tex_ratio = (tex_res.x/tex_res.y);\\n\\tfloat ratio = input_ratio / tex_ratio;\\n\\t\\n\\tif(ratio < 1.){\\n\\t\\t// gl_Position.x -= ( 1. - 1./ratio)*0.5;\\n\\t\\tu.x *= ratio;\\n\\t} else {\\n\\t\\t// gl_Position.y -= ( 1. - ratio)*0.5;\\n\\t\\tu.y /= ratio;\\n\\t}\\n  return u;\\n}\\n\\nvec2 ndc_aspect_correct(vec2 u, vec2 r){\\n\\tif(r.x < r.y){\\n\\t\\tu.y /= r.y/r.x;\\n\\t} else {\\n\\t\\tu.x /= r.x/r.y;\\n\\t}\\n  return u;\\n}\\n\\nuniform float zoom;\\nuniform vec2 panning;\\nvoid main(){\\n  uv = positions[gl_VertexID];\\n  gl_Position = vec4(positions[gl_VertexID],0,1);\\n}  \\n\\t\\t\\t\\n\";";

/***/ }),

/***/ 911:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 R;\\n  vec2 canvasR;\\n  float time;\\n  float ptr_pressure;\\n  float mouse_pos_x;\\n  float mouse_pos_y;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nuint seed = 11425u;\\n\\nuint hash_u(uint _a) {\\n   uint a = _a;\\n   a ^= a >> 16;\\n   a *= 0x7feb352du;\\n   a ^= a >> 15;\\n   a *= 0x846ca68bu;\\n   a ^= a >> 16;\\n   return a; \\n }\\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\\n\\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\\nfloat hash_21_s(ivec2 _s_){ \\n  uvec2 s = uvec2(_s_);\\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \\n  return hash_f_s(_s); \\n}\\n// vec3 hash_23_s(){ return vec3(hash_f_s(), hash_f_s(), hash_f_s()); }\\n// vec4 hash_24_s(){ return vec4(hash_f_s(), hash_f_s(), hash_f_s(), hash_f_s()); }\\n\\nfloat valueNoise( in vec2 p ){\\n    p += 100.;\\n    ivec2 i = ivec2(floor( p ));\\n    vec2 f = fract( p );\\n\\n    // cubic interpolant\\n    vec2 u = f*f*(3.0-2.0*f);\\n\\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \\n                     hash_21_s( i + ivec2(1,0) ), u.x),\\n                mix( hash_21_s( i + ivec2(0,1) ), \\n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\\n}\\n\\nin vec2 uv;\\n\\nout vec4 col;\\n\\nfloat sdBox(vec2 p, vec2 sz){\\n    p = abs(p) - sz;\\n    return max(p.x,p.y);\\n}\\nvoid main() {\\n  vec2 boxSz = vec2(0.49);\\n  \\n  float pi = 3.14159265359;\\n  float tau = 2.*pi;\\n\\n  col = vec4(0,0,0,1);\\n  \\n  vec2 u = uv - 0.5;\\n  \\n  \\n  \\n  // return;\\n\\n  \\n  {\\n    vec2 dx = dFdx(uv.xy);\\n    vec2 dy = dFdy(uv.xy);\\n    \\n    float sd = sdBox(u,boxSz);\\n    // sd = sdBox(u,boxSz - fwidth(sd)); // ?\\n\\n    float fw = fwidth((sd));\\n    \\n    #define render(pos)  (1.-step(0.,sdBox(pos,boxSz)))\\n        \\n\\n    float w = 0.;\\n    float _Bias = 1.;\\n    vec2 uvOffsets = vec2(0.125, 0.375);\\n    vec2 offsetUV = vec2(0.0, 0.0);\\n\\n    offsetUV.xy = u.xy + uvOffsets.x * dx + uvOffsets.y * dy;\\n    w += render(offsetUV.xy);\\n    offsetUV.xy = u.xy - uvOffsets.x * dx - uvOffsets.y * dy;\\n    w += render(offsetUV.xy);\\n    offsetUV.xy = u.xy + uvOffsets.y * dx - uvOffsets.x * dy;\\n    w += render(offsetUV.xy);\\n    offsetUV.xy = u.xy - uvOffsets.y * dx + uvOffsets.x * dy;\\n    w += render(offsetUV.xy);\\n    w *= 1./4.;\\n    col.w *= w;\\n      \\n      // uvOffsets = uvOffsets * rot(0.25*acos(-1.));\\n      // offsetUV.xy = u.xy + uvOffsets.x * dx + uvOffsets.y * dy;\\n      // w += render(offsetUV.xy);\\n      // offsetUV.xy = u.xy - uvOffsets.x * dx - uvOffsets.y * dy;\\n      // w += render(offsetUV.xy);\\n      // offsetUV.xy = u.xy + uvOffsets.y * dx - uvOffsets.x * dy;\\n      // w += render(offsetUV.xy);\\n      // offsetUV.xy = u.xy - uvOffsets.y * dx + uvOffsets.x * dy;\\n      // w += render(offsetUV.xy);\\n\\n      // w /= 8.;\\n      // col.w *= w;\\n      //col.x = 1.;\\n  } \\n}\";";

/***/ }),

/***/ 643:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 R;\\n  vec2 canvasR;\\n  float time;\\n  float ptr_pressure;\\n  float mouse_pos_x;\\n  float mouse_pos_y;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\nout vec2 uv;\\n\\nlayout(location = 0) in vec4 pos;\\n// layout(location = 1) in vec4 col;\\nvoid main(){\\n  // gl_Position.xy *= brush_sz;\\n  vec2 p = pos.xy;\\n  // p = (p - 0.5*R)/min(R.x,R.y);\\n  float ratio = R.x/R.y;\\n  if(ratio > 0.){\\n    p.x /= ratio;\\n  } else {\\n    p.x *= ratio;\\n  }\\n  \\n  gl_Position = vec4(p.xy,0,1);\\n\\n  uv = pos.zw;\\n  // uv = ;\\n}  \";";

/***/ }),

/***/ 975:
/***/ ((module) => {

"use strict";
module.exports = "export default \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#define GLSLIFY 1\\nuniform sampler2D canvas_back;\\nuniform sampler2D temp_tex;\\nuniform sampler2D canvas_a;\\nuniform sampler2D canvas_b;\\n\\nuniform sampler2D brush_texture[7];\\n\\nuniform Settings {\\n  vec2 R;\\n  vec2 canvasR;\\n  float time;\\n  float ptr_pressure;\\n  float mouse_pos_x;\\n  float mouse_pos_y;\\n};\\n\\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\\nvec2[] positions = vec2[4](\\n  vec2(-1, -1), vec2(1, -1), vec2(-1, 1),vec2(1, 1)\\n);\\n\\n#ifndef SPECTRAL\\n#define SPECTRAL\\n\\nconst int SPECTRAL_SIZE = 38;\\nconst float SPECTRAL_GAMMA = 2.4;\\nconst float SPECTRAL_EPSILON = 0.0001;\\n\\nfloat spectral_uncompand(float x) {\\n  return (x < 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, SPECTRAL_GAMMA);\\n}\\n\\nfloat spectral_compand(float x) {\\n  return (x < 0.0031308) ? x * 12.92 : 1.055 * pow(x, 1.0 / SPECTRAL_GAMMA) - 0.055;\\n}\\n\\nvec3 spectral_srgb_to_linear(vec3 srgb) {\\n    return vec3(spectral_uncompand(srgb[0]), spectral_uncompand(srgb[1]), spectral_uncompand(srgb[2]));\\n}\\n\\nvec3 spectral_linear_to_srgb(vec3 lrgb) {\\n    return clamp(vec3(spectral_compand(lrgb[0]), spectral_compand(lrgb[1]), spectral_compand(lrgb[2])), 0.0, 1.0);\\n}\\n\\nvoid spectral_upsampling(vec3 lrgb, out float w, out float c, out float m, out float y, out float r, out float g, out float b) {\\n    w = min(lrgb.r, min(lrgb.g, lrgb.b));\\n\\n    lrgb -= w;\\n\\n    c = min(lrgb.g, lrgb.b);\\n    m = min(lrgb.r, lrgb.b);\\n    y = min(lrgb.r, lrgb.g);\\n    r = min(max(0., lrgb.r - lrgb.b), max(0., lrgb.r - lrgb.g));\\n    g = min(max(0., lrgb.g - lrgb.b), max(0., lrgb.g - lrgb.r));\\n    b = min(max(0., lrgb.b - lrgb.g), max(0., lrgb.b - lrgb.r));\\n}\\n\\nvoid spectral_linear_to_reflectance(vec3 lrgb, inout float R[SPECTRAL_SIZE]) {\\n    float w, c, m, y, r, g, b;\\n    \\n    spectral_upsampling(lrgb, w, c, m, y, r, g, b);\\n    \\n     R[0] = max(SPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\\n     R[1] = max(SPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\\n     R[2] = max(SPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\\n     R[3] = max(SPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\\n     R[4] = max(SPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\\n     R[5] = max(SPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\\n     R[6] = max(SPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\\n     R[7] = max(SPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\\n     R[8] = max(SPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\\n     R[9] = max(SPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\\n    R[10] = max(SPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\\n    R[11] = max(SPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\\n    R[12] = max(SPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\\n    R[13] = max(SPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\\n    R[14] = max(SPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\\n    R[15] = max(SPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\\n    R[16] = max(SPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\\n    R[17] = max(SPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\\n    R[18] = max(SPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\\n    R[19] = max(SPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\\n    R[20] = max(SPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\\n    R[21] = max(SPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\\n    R[22] = max(SPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\\n    R[23] = max(SPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\\n    R[24] = max(SPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\\n    R[25] = max(SPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\\n    R[26] = max(SPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\\n    R[27] = max(SPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\\n    R[28] = max(SPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\\n    R[29] = max(SPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\\n    R[30] = max(SPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\\n    R[31] = max(SPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\\n    R[32] = max(SPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\\n    R[33] = max(SPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\\n    R[34] = max(SPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\\n    R[35] = max(SPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\\n    R[36] = max(SPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\\n    R[37] = max(SPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\\n}\\n\\nvec3 spectral_xyz_to_srgb(vec3 xyz) {\\n    mat3 XYZ_RGB;\\n\\n    XYZ_RGB[0] = vec3( 3.24306333, -1.53837619, -0.49893282);\\n    XYZ_RGB[1] = vec3(-0.96896309,  1.87542451,  0.04154303);\\n    XYZ_RGB[2] = vec3( 0.05568392, -0.20417438,  1.05799454);\\n    \\n    float r = dot(XYZ_RGB[0], xyz);\\n    float g = dot(XYZ_RGB[1], xyz);\\n    float b = dot(XYZ_RGB[2], xyz);\\n\\n    return spectral_linear_to_srgb(vec3(r, g, b));\\n}\\n\\nvec3 spectral_reflectance_to_xyz(float R[SPECTRAL_SIZE]) {\\n    vec3 xyz = vec3(0.0);\\n    \\n    xyz +=  R[0] * vec3(0.00006469, 0.00000184, 0.00030502);\\n    xyz +=  R[1] * vec3(0.00021941, 0.00000621, 0.00103681);\\n    xyz +=  R[2] * vec3(0.00112057, 0.00003101, 0.00531314);\\n    xyz +=  R[3] * vec3(0.00376661, 0.00010475, 0.01795439);\\n    xyz +=  R[4] * vec3(0.01188055, 0.00035364, 0.05707758);\\n    xyz +=  R[5] * vec3(0.02328644, 0.00095147, 0.11365162);\\n    xyz +=  R[6] * vec3(0.03455942, 0.00228226, 0.17335873);\\n    xyz +=  R[7] * vec3(0.03722379, 0.00420733, 0.19620658);\\n    xyz +=  R[8] * vec3(0.03241838, 0.00668880, 0.18608237);\\n    xyz +=  R[9] * vec3(0.02123321, 0.00988840, 0.13995048);\\n    xyz += R[10] * vec3(0.01049099, 0.01524945, 0.08917453);\\n    xyz += R[11] * vec3(0.00329584, 0.02141831, 0.04789621);\\n    xyz += R[12] * vec3(0.00050704, 0.03342293, 0.02814563);\\n    xyz += R[13] * vec3(0.00094867, 0.05131001, 0.01613766);\\n    xyz += R[14] * vec3(0.00627372, 0.07040208, 0.00775910);\\n    xyz += R[15] * vec3(0.01686462, 0.08783871, 0.00429615);\\n    xyz += R[16] * vec3(0.02868965, 0.09424905, 0.00200551);\\n    xyz += R[17] * vec3(0.04267481, 0.09795667, 0.00086147);\\n    xyz += R[18] * vec3(0.05625475, 0.09415219, 0.00036904);\\n    xyz += R[19] * vec3(0.06947040, 0.08678102, 0.00019143);\\n    xyz += R[20] * vec3(0.08305315, 0.07885653, 0.00014956);\\n    xyz += R[21] * vec3(0.08612610, 0.06352670, 0.00009231);\\n    xyz += R[22] * vec3(0.09046614, 0.05374142, 0.00006813);\\n    xyz += R[23] * vec3(0.08500387, 0.04264606, 0.00002883);\\n    xyz += R[24] * vec3(0.07090667, 0.03161735, 0.00001577);\\n    xyz += R[25] * vec3(0.05062889, 0.02088521, 0.00000394);\\n    xyz += R[26] * vec3(0.03547396, 0.01386011, 0.00000158);\\n    xyz += R[27] * vec3(0.02146821, 0.00810264, 0.00000000);\\n    xyz += R[28] * vec3(0.01251646, 0.00463010, 0.00000000);\\n    xyz += R[29] * vec3(0.00680458, 0.00249138, 0.00000000);\\n    xyz += R[30] * vec3(0.00346457, 0.00125930, 0.00000000);\\n    xyz += R[31] * vec3(0.00149761, 0.00054165, 0.00000000);\\n    xyz += R[32] * vec3(0.00076970, 0.00027795, 0.00000000);\\n    xyz += R[33] * vec3(0.00040737, 0.00014711, 0.00000000);\\n    xyz += R[34] * vec3(0.00016901, 0.00006103, 0.00000000);\\n    xyz += R[35] * vec3(0.00009522, 0.00003439, 0.00000000);\\n    xyz += R[36] * vec3(0.00004903, 0.00001771, 0.00000000);\\n    xyz += R[37] * vec3(0.00002000, 0.00000722, 0.00000000);\\n\\n    return xyz;\\n}\\n\\nfloat spectral_linear_to_concentration(float l1, float l2, float t) {\\n    float t1 = l1 * pow(1.0 - t, 2.0);\\n    float t2 = l2 * pow(t, 2.0);\\n\\n    return t2 / (t1 + t2);\\n}\\n\\nvec3 spectral_mix(vec3 color1, vec3 color2, float t) {\\n    vec3 lrgb1 = spectral_srgb_to_linear(color1);\\n    vec3 lrgb2 = spectral_srgb_to_linear(color2);\\n\\n    float R1[SPECTRAL_SIZE];\\n    float R2[SPECTRAL_SIZE];\\n\\n    spectral_linear_to_reflectance(lrgb1, R1);\\n    spectral_linear_to_reflectance(lrgb2, R2);\\n\\n    float l1 = spectral_reflectance_to_xyz(R1)[1];\\n    float l2 = spectral_reflectance_to_xyz(R2)[1];\\n\\n    t = spectral_linear_to_concentration(l1, l2, t);\\n\\n    float R[SPECTRAL_SIZE];\\n\\n    for (int i = 0; i < SPECTRAL_SIZE; i++) {\\n      float KS = (1.0 - t) * (pow(1.0 - R1[i], 2.0) / (2.0 * R1[i])) + t * (pow(1.0 - R2[i], 2.0) / (2.0 * R2[i]));\\n      float KM = 1.0 + KS - sqrt(pow(KS, 2.0) + 2.0 * KS);\\n\\n      //Saunderson correction\\n      // let S = ((1.0 - K1) * (1.0 - K2) * KM) / (1.0 - K2 * KM);\\n\\n      R[i] = KM;\\n    }\\n\\n    return spectral_xyz_to_srgb(spectral_reflectance_to_xyz(R));\\n}\\n\\nvec4 spectral_mix(vec4 color1, vec4 color2, float t) {\\n    return vec4(spectral_mix(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\\n}\\n\\n#endif\\n\\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\\n\\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\\n\\nvec3 srgb2oklab(vec3 c) {\\n    \\n    mat3 m1 = mat3(\\n        0.4122214708,0.5363325363,0.0514459929,\\n        0.2119034982,0.6806995451,0.1073969566,\\n        0.0883024619,0.2817188376,0.6299787005\\n    );\\n    \\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = pow(lms,vec3(1./3.));\\n\\n    mat3 m2 = mat3(\\n        +0.2104542553,+0.7936177850,-0.0040720468,\\n        +1.9779984951,-2.4285922050,+0.4505937099,\\n        +0.0259040371,+0.7827717662,-0.8086757660\\n    );\\n    \\n    return mul3(m2,lms);\\n}\\n\\nvec3 oklab2srgb(vec3 c)\\n{\\n    mat3 m1 = mat3(\\n        1.0000000000,+0.3963377774,+0.2158037573,\\n        1.0000000000,-0.1055613458,-0.0638541728,\\n        1.0000000000,-0.0894841775,-1.2914855480\\n    );\\n\\n    vec3 lms = mul3(m1,c);\\n    \\n    lms = lms * lms * lms;\\n  \\n    mat3 m2 = mat3(\\n        +4.0767416621,-3.3077115913,+0.2309699292,\\n        -1.2684380046,+2.6097574011,-0.3413193965,\\n        -0.0041960863,-0.7034186147,+1.7076147010\\n    );\\n    return mul3(m2,lms);\\n}\\n\\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\\n\\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\\n\\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\\n\\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\n\\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\\n\\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\\n\\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\\n\\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\\n{\\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\\n}\\n\\nvec3 hsv2rgb(vec3 c)\\n{\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 hsv2rgbSmooth( in vec3 hsv )\\n{\\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n\\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\\n\\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\\n}\\n\\nvec3 hueShift(vec3 col, vec3 hsv){\\n    vec3 h = rgb2hsv(col);\\n    h.x += hsv.x;\\n\\n    h.y *= hsv.y;\\n    h.z *= hsv.z;\\n\\n    return hsv2rgbSmooth(h);\\n}\\n\\nvec4 blend_brushstroke(vec4 col, vec4 stroke, int blending_colour_space){\\n  // col.xyz = mix(col.xyz, stroke.xyz, stroke.w); \\n  \\n  int mode = blending_colour_space;\\n  \\n  if(stroke.w > 0.00000001){\\n    // float interpolant = stroke.w;\\n    stroke.xyz = stroke.xyz/max(stroke.w,0.001);\\n    \\n    if(mode == 0){\\n      col.xyz = spectral_mix(col.xyz, clamp(stroke.xyz,0.00001,0.99999), stroke.w);\\n      if(stroke.w > 0.99999)\\n        col.xyz = stroke.xyz;\\n    } else if(mode == 1){\\n      col.xyz = srgb_to_oklch( col.xyz );\\n      stroke.xyz = srgb_to_oklch( stroke.xyz );\\n      col.xy = mix(col.xy, stroke.xy,stroke.w);\\n      float tau = acos(-1.) * 2.;\\n      float h_a = stroke.z;\\n      float h_b = stroke.z + tau;\\n      float dist_a = abs(col.z - h_a);\\n      float dist_b = abs(col.z - h_b);\\n      if(dist_a < dist_b){\\n        col.z = mix(col.z, h_a, stroke.w);\\n      } else {\\n        col.z = mix(col.z, h_b, stroke.w);\\n      }\\n      col.z = mod(col.z, tau);\\n      // col.z = max(col.z)\\n      // if(isnan(col.z)){\\n      //   col.z = 1.;\\n      // }\\n\\n      col.xyz = oklch_to_srgb( col.xyz );\\n      col.xyz = clamp(col.xyz,0.,1.);\\n    } else {\\n      col.xyz = mix(col.xyz, stroke.xyz, stroke.w);\\n    }\\n    col.w = max(col.w, stroke.w);\\n  }\\n\\n  return col; \\n}\\n\\nuniform sampler2D fb_a;\\nuniform sampler2D fb_b;\\nuniform sampler2D noise_tex;\\nin vec2 uv;\\nout vec4 col;\\n\\nvec3[] pal = vec3[](\\n    vec3(0.8,0.5,0.),\\n    vec3(0.2,0.6,0.4),\\n    vec3(1.0,0.0,0.7),\\n    vec3(1.0,1.0,0.99)\\n);\\n\\nvec3 mix_oklch(vec3 col_a, vec3 col_b, float a){\\n  // return mix(col_a,col_b,a);\\n  float tau = 3.14159265359 * 2.;\\n  float col_b_h_1 = col_b.z;\\n  float col_b_h_2 = col_b.z + tau;\\n  float dist_a = abs(col_a.z - col_b_h_1);\\n  float dist_b = abs(col_a.z - col_b_h_2);\\n  // if(dist_a < dist_b){\\n  //   col_a.z = mix(col_a.z, col_b_h_1, a);\\n  // } else {\\n  //   col_a.z = mix(col_a.z, col_b_h_2, a);\\n  // }\\n  col_a.z = mix(col_a.z,col_b.z,a);\\n\\n  col_a.x = mix(col_a.x, col_b.x, a);\\n  col_a.y = mix(col_a.y, col_b.y, a);\\n  // col_a.z = mod(col_a.z, tau);\\n  return col_a;\\n}\\n\\nvoid main() {\\n  vec2 u = (gl_FragCoord.xy - 0.5*R)/min(R.x,R.y);\\n  vec2 un = (gl_FragCoord.xy/R);\\n\\n  col = vec4(0,0,0,1);\\n  \\n  vec4 t_a = texture(fb_a, un);\\n  vec4 t_b = texelFetch(fb_b, ivec2(gl_FragCoord), 0);\\n  vec4 noise = texture(noise_tex, fract(u*3.));\\n\\n  const float bayer[] = float[64](\\n     0., 32., 8., 40., 2., 34., 10., 42., /* 8x8 Bayer ordered dithering */\\n    48., 16., 56., 24., 50., 18., 58., 26., /* pattern. Each input pixel */\\n    12., 44., 4., 36., 14., 46., 6., 38., /* is scaled to the 0..63 range */\\n    60., 28., 52., 20., 62., 30., 54., 22., /* before looking in this table */\\n     3., 35., 11., 43., 1., 33., 9., 41., /* to determine the action. */\\n    51., 19., 59., 27., 49., 17., 57., 25.,\\n    15., 47., 7., 39., 13., 45., 5., 37.,\\n    63., 31., 55., 23., 61., 29., 53., 21.\\n  );\\n\\n  col += t_a;\\n  col = mix(col, vec4(0), t_b.a);\\n  \\n  // col += bayer[]\\n  \\n\\t// vec2 sc = px_sz / aspect_ratio;\\n  // u += time;\\n  // uv += 1.0;\\n\\tvec2 sc = 4./R;\\n\\t// vec2 fruv = fract(u / sc);\\n\\tvec2 fuv = floor((uv + 5.)/ sc) * sc;\\n\\t\\n\\tvec2 buv = mod(fuv/sc, 8.);\\n\\tfloat bay = float(bayer[int(buv.x) + int(buv.y)*8])/63.;\\n\\n  \\n  float T = time;\\n  \\n  // col = clamp(col,0.,1.);\\n  vec2 mouse_pos = vec2(mouse_pos_x, mouse_pos_y);\\n\\n  col.xyz = srgb_to_oklch(col.xyz);\\n\\n  col.z += (bay*2. - 1.)*0.9*(1. + mouse_pos.y);\\n  // if(col.y < 0.001 && col.x < 0.001){\\n  //   col.x += (bay*2. - 1.)*0.7;\\n  // }\\n  // col.x = max(col.x, 0.1);\\n\\n  col.xyz = oklch_to_srgb(col.xyz);\\n  \\n  \\n\\n  col = pow(col,vec4(0.454545454545)); \\n  col += (noise*noise*noise)*0.15;\\n  col.w = 1.;\\n}    \\n\\n  \\n  \\n\\t\\t \";";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			179: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ./public/Petrona-VariableFont_wght.ttf
var Petrona_VariableFont_wght = __webpack_require__(446);
// EXTERNAL MODULE: ./public/Petrona-Italic-VariableFont_wght.ttf
var Petrona_Italic_VariableFont_wght = __webpack_require__(591);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(379);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(795);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(569);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(565);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(216);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(589);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./public/style.css
var style = __webpack_require__(563);
;// CONCATENATED MODULE: ./public/style.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(style/* default */.Z, options);




       /* harmony default export */ const public_style = (style/* default */.Z && style/* default */.Z.locals ? style/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/environment.js


const is_client = typeof window !== 'undefined';

/** @type {() => number} */
let environment_now = (/* unused pure expression or super */ null && (is_client ? () => window.performance.now() : () => Date.now()));

let environment_raf = (/* unused pure expression or super */ null && (is_client ? (cb) => requestAnimationFrame(cb) : noop));

// used internally for testing
/** @returns {void} */
function set_now(fn) {
	environment_now = fn;
}

/** @returns {void} */
function set_raf(fn) {
	environment_raf = fn;
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/loop.js


const tasks = new Set();

/**
 * @param {number} now
 * @returns {void}
 */
function run_tasks(now) {
	tasks.forEach((task) => {
		if (!task.c(now)) {
			tasks.delete(task);
			task.f();
		}
	});
	if (tasks.size !== 0) raf(run_tasks);
}

/**
 * For testing purposes only!
 * @returns {void}
 */
function clear_loops() {
	tasks.clear();
}

/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 * @param {import('./private.js').TaskCallback} callback
 * @returns {import('./private.js').Task}
 */
function loop_loop(callback) {
	/** @type {import('./private.js').TaskEntry} */
	let task;
	if (tasks.size === 0) raf(run_tasks);
	return {
		promise: new Promise((fulfill) => {
			tasks.add((task = { c: callback, f: fulfill }));
		}),
		abort() {
			tasks.delete(task);
		}
	};
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/globals.js
/** @type {typeof globalThis} */
const globals =
	typeof window !== 'undefined'
		? window
		: typeof globalThis !== 'undefined'
		? globalThis
		: // @ts-ignore Node typings have this
		  global;

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js


/**
 * Resize observer singleton.
 * One listener per element only!
 * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ
 */
class ResizeObserverSingleton {
	/**
	 * @private
	 * @readonly
	 * @type {WeakMap<Element, import('./private.js').Listener>}
	 */
	_listeners = "WeakMap" in globals ? new WeakMap() : undefined;

	/**
	 * @private
	 * @type {ResizeObserver}
	 */
	_observer = undefined;

	/** @type {ResizeObserverOptions} */
	options;

	/** @param {ResizeObserverOptions} options */
	constructor(options) {
		this.options = options;
	}

	/**
	 * @param {Element} element
	 * @param {import('./private.js').Listener} listener
	 * @returns {() => void}
	 */
	observe(element, listener) {
		this._listeners.set(element, listener);
		this._getObserver().observe(element, this.options);
		return () => {
			this._listeners.delete(element);
			this._observer.unobserve(element); // this line can probably be removed
		};
	}

	/**
	 * @private
	 */
	_getObserver() {
		return (
			this._observer ??
			(this._observer = new ResizeObserver((entries) => {
				for (const entry of entries) {
					ResizeObserverSingleton.entries.set(entry.target, entry);
					this._listeners.get(entry.target)?.(entry);
				}
			}))
		);
	}
}

// Needs to be written like this to pass the tree-shake-test
ResizeObserverSingleton.entries = "WeakMap" in globals ? new WeakMap() : undefined;

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/utils.js
/** @returns {void} */
function utils_noop() {}

const identity = (x) => x;

/**
 * @template T
 * @template S
 * @param {T} tar
 * @param {S} src
 * @returns {T & S}
 */
function utils_assign(tar, src) {
	// @ts-ignore
	for (const k in src) tar[k] = src[k];
	return /** @type {T & S} */ (tar);
}

// Adapted from https://github.com/then/is-promise/blob/master/index.js
// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE
/**
 * @param {any} value
 * @returns {value is PromiseLike<any>}
 */
function is_promise(value) {
	return (
		!!value &&
		(typeof value === 'object' || typeof value === 'function') &&
		typeof (/** @type {any} */ (value).then) === 'function'
	);
}

/** @returns {void} */
function add_location(element, file, line, column, char) {
	element.__svelte_meta = {
		loc: { file, line, column, char }
	};
}

function run(fn) {
	return fn();
}

function utils_blank_object() {
	return Object.create(null);
}

/**
 * @param {Function[]} fns
 * @returns {void}
 */
function utils_run_all(fns) {
	fns.forEach(run);
}

/**
 * @param {any} thing
 * @returns {thing is Function}
 */
function utils_is_function(thing) {
	return typeof thing === 'function';
}

/** @returns {boolean} */
function safe_not_equal(a, b) {
	return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
}

let src_url_equal_anchor;

/** @returns {boolean} */
function src_url_equal(element_src, url) {
	if (!src_url_equal_anchor) {
		src_url_equal_anchor = document.createElement('a');
	}
	src_url_equal_anchor.href = url;
	return element_src === src_url_equal_anchor.href;
}

/** @returns {boolean} */
function not_equal(a, b) {
	return a != a ? b == b : a !== b;
}

/** @returns {boolean} */
function is_empty(obj) {
	return Object.keys(obj).length === 0;
}

/** @returns {void} */
function validate_store(store, name) {
	if (store != null && typeof store.subscribe !== 'function') {
		throw new Error(`'${name}' is not a store with a 'subscribe' method`);
	}
}

function subscribe(store, ...callbacks) {
	if (store == null) {
		for (const callback of callbacks) {
			callback(undefined);
		}
		return utils_noop;
	}
	const unsub = store.subscribe(...callbacks);
	return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

/**
 * Get the current value from a store by subscribing and immediately unsubscribing.
 *
 * https://svelte.dev/docs/svelte-store#get
 * @template T
 * @param {import('../store/public.js').Readable<T>} store
 * @returns {T}
 */
function get_store_value(store) {
	let value;
	subscribe(store, (_) => (value = _))();
	return value;
}

/** @returns {void} */
function component_subscribe(component, store, callback) {
	component.$$.on_destroy.push(subscribe(store, callback));
}

function create_slot(definition, ctx, $$scope, fn) {
	if (definition) {
		const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
		return definition[0](slot_ctx);
	}
}

function get_slot_context(definition, ctx, $$scope, fn) {
	return definition[1] && fn ? utils_assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}

function get_slot_changes(definition, $$scope, dirty, fn) {
	if (definition[2] && fn) {
		const lets = definition[2](fn(dirty));
		if ($$scope.dirty === undefined) {
			return lets;
		}
		if (typeof lets === 'object') {
			const merged = [];
			const len = Math.max($$scope.dirty.length, lets.length);
			for (let i = 0; i < len; i += 1) {
				merged[i] = $$scope.dirty[i] | lets[i];
			}
			return merged;
		}
		return $$scope.dirty | lets;
	}
	return $$scope.dirty;
}

/** @returns {void} */
function update_slot_base(
	slot,
	slot_definition,
	ctx,
	$$scope,
	slot_changes,
	get_slot_context_fn
) {
	if (slot_changes) {
		const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
		slot.p(slot_context, slot_changes);
	}
}

/** @returns {void} */
function update_slot(
	slot,
	slot_definition,
	ctx,
	$$scope,
	dirty,
	get_slot_changes_fn,
	get_slot_context_fn
) {
	const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
	update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
}

/** @returns {any[] | -1} */
function get_all_dirty_from_scope($$scope) {
	if ($$scope.ctx.length > 32) {
		const dirty = [];
		const length = $$scope.ctx.length / 32;
		for (let i = 0; i < length; i++) {
			dirty[i] = -1;
		}
		return dirty;
	}
	return -1;
}

/** @returns {{}} */
function exclude_internal_props(props) {
	const result = {};
	for (const k in props) if (k[0] !== '$') result[k] = props[k];
	return result;
}

/** @returns {{}} */
function compute_rest_props(props, keys) {
	const rest = {};
	keys = new Set(keys);
	for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];
	return rest;
}

/** @returns {{}} */
function compute_slots(slots) {
	const result = {};
	for (const key in slots) {
		result[key] = true;
	}
	return result;
}

/** @returns {(this: any, ...args: any[]) => void} */
function once(fn) {
	let ran = false;
	return function (...args) {
		if (ran) return;
		ran = true;
		fn.call(this, ...args);
	};
}

function null_to_empty(value) {
	return value == null ? '' : value;
}

function set_store_value(store, ret, value) {
	store.set(value);
	return ret;
}

const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

function action_destroyer(action_result) {
	return action_result && utils_is_function(action_result.destroy) ? action_result.destroy : utils_noop;
}

/** @param {number | string} value
 * @returns {[number, string]}
 */
function split_css_unit(value) {
	const split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
	return split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];
}

const utils_contenteditable_truthy_values = (/* unused pure expression or super */ null && (['', true, 1, 'true', 'contenteditable']));

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dom.js


// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
// at the end of hydration without touching the remaining nodes.
let is_hydrating = false;

/**
 * @returns {void}
 */
function start_hydrating() {
	is_hydrating = true;
}

/**
 * @returns {void}
 */
function end_hydrating() {
	is_hydrating = false;
}

/**
 * @param {number} low
 * @param {number} high
 * @param {(index: number) => number} key
 * @param {number} value
 * @returns {number}
 */
function upper_bound(low, high, key, value) {
	// Return first index of value larger than input value in the range [low, high)
	while (low < high) {
		const mid = low + ((high - low) >> 1);
		if (key(mid) <= value) {
			low = mid + 1;
		} else {
			high = mid;
		}
	}
	return low;
}

/**
 * @param {NodeEx} target
 * @returns {void}
 */
function init_hydrate(target) {
	if (target.hydrate_init) return;
	target.hydrate_init = true;
	// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>

	let children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);
	// If target is <head>, there may be children without claim_order
	if (target.nodeName === 'HEAD') {
		const myChildren = [];
		for (let i = 0; i < children.length; i++) {
			const node = children[i];
			if (node.claim_order !== undefined) {
				myChildren.push(node);
			}
		}
		children = myChildren;
	}
	/*
	 * Reorder claimed children optimally.
	 * We can reorder claimed children optimally by finding the longest subsequence of
	 * nodes that are already claimed in order and only moving the rest. The longest
	 * subsequence of nodes that are claimed in order can be found by
	 * computing the longest increasing subsequence of .claim_order values.
	 *
	 * This algorithm is optimal in generating the least amount of reorder operations
	 * possible.
	 *
	 * Proof:
	 * We know that, given a set of reordering operations, the nodes that do not move
	 * always form an increasing subsequence, since they do not move among each other
	 * meaning that they must be already ordered among each other. Thus, the maximal
	 * set of nodes that do not move form a longest increasing subsequence.
	 */
	// Compute longest increasing subsequence
	// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
	const m = new Int32Array(children.length + 1);
	// Predecessor indices + 1
	const p = new Int32Array(children.length);
	m[0] = -1;
	let longest = 0;
	for (let i = 0; i < children.length; i++) {
		const current = children[i].claim_order;
		// Find the largest subsequence length such that it ends in a value less than our current value
		// upper_bound returns first greater value, so we subtract one
		// with fast path for when we are on the current longest subsequence
		const seqLen =
			(longest > 0 && children[m[longest]].claim_order <= current
				? longest + 1
				: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;
		p[i] = m[seqLen] + 1;
		const newLen = seqLen + 1;
		// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
		m[newLen] = i;
		longest = Math.max(newLen, longest);
	}
	// The longest increasing subsequence of nodes (initially reversed)

	/**
	 * @type {NodeEx2[]}
	 */
	const lis = [];
	// The rest of the nodes, nodes that will be moved

	/**
	 * @type {NodeEx2[]}
	 */
	const toMove = [];
	let last = children.length - 1;
	for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
		lis.push(children[cur - 1]);
		for (; last >= cur; last--) {
			toMove.push(children[last]);
		}
		last--;
	}
	for (; last >= 0; last--) {
		toMove.push(children[last]);
	}
	lis.reverse();
	// We sort the nodes being moved to guarantee that their insertion order matches the claim order
	toMove.sort((a, b) => a.claim_order - b.claim_order);
	// Finally, we move the nodes
	for (let i = 0, j = 0; i < toMove.length; i++) {
		while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
			j++;
		}
		const anchor = j < lis.length ? lis[j] : null;
		target.insertBefore(toMove[i], anchor);
	}
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append(target, node) {
	target.appendChild(node);
}

/**
 * @param {Node} target
 * @param {string} style_sheet_id
 * @param {string} styles
 * @returns {void}
 */
function append_styles(target, style_sheet_id, styles) {
	const append_styles_to = dom_get_root_for_style(target);
	if (!append_styles_to.getElementById(style_sheet_id)) {
		const style = dom_element('style');
		style.id = style_sheet_id;
		style.textContent = styles;
		append_stylesheet(append_styles_to, style);
	}
}

/**
 * @param {Node} node
 * @returns {ShadowRoot | Document}
 */
function dom_get_root_for_style(node) {
	if (!node) return document;
	const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
	if (root && /** @type {ShadowRoot} */ (root).host) {
		return /** @type {ShadowRoot} */ (root);
	}
	return node.ownerDocument;
}

/**
 * @param {Node} node
 * @returns {CSSStyleSheet}
 */
function dom_append_empty_stylesheet(node) {
	const style_element = dom_element('style');
	// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,
	// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.
	// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.
	// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.
	// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.
	style_element.textContent = '/* empty */';
	append_stylesheet(dom_get_root_for_style(node), style_element);
	return style_element.sheet;
}

/**
 * @param {ShadowRoot | Document} node
 * @param {HTMLStyleElement} style
 * @returns {CSSStyleSheet}
 */
function append_stylesheet(node, style) {
	append(/** @type {Document} */ (node).head || node, style);
	return style.sheet;
}

/**
 * @param {NodeEx} target
 * @param {NodeEx} node
 * @returns {void}
 */
function dom_append_hydration(target, node) {
	if (is_hydrating) {
		init_hydrate(target);
		if (
			target.actual_end_child === undefined ||
			(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)
		) {
			target.actual_end_child = target.firstChild;
		}
		// Skip nodes of undefined ordering
		while (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {
			target.actual_end_child = target.actual_end_child.nextSibling;
		}
		if (node !== target.actual_end_child) {
			// We only insert if the ordering of this node should be modified or the parent node is not target
			if (node.claim_order !== undefined || node.parentNode !== target) {
				target.insertBefore(node, target.actual_end_child);
			}
		} else {
			target.actual_end_child = node.nextSibling;
		}
	} else if (node.parentNode !== target || node.nextSibling !== null) {
		target.appendChild(node);
	}
}

/**
 * @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert(target, node, anchor) {
	target.insertBefore(node, anchor || null);
}

/**
 * @param {NodeEx} target
 * @param {NodeEx} node
 * @param {NodeEx} [anchor]
 * @returns {void}
 */
function dom_insert_hydration(target, node, anchor) {
	if (is_hydrating && !anchor) {
		dom_append_hydration(target, node);
	} else if (node.parentNode !== target || node.nextSibling != anchor) {
		target.insertBefore(node, anchor || null);
	}
}

/**
 * @param {Node} node
 * @returns {void}
 */
function dom_detach(node) {
	if (node.parentNode) {
		node.parentNode.removeChild(node);
	}
}

/**
 * @returns {void} */
function destroy_each(iterations, detaching) {
	for (let i = 0; i < iterations.length; i += 1) {
		if (iterations[i]) iterations[i].d(detaching);
	}
}

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} name
 * @returns {HTMLElementTagNameMap[K]}
 */
function dom_element(name) {
	return document.createElement(name);
}

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} name
 * @param {string} is
 * @returns {HTMLElementTagNameMap[K]}
 */
function element_is(name, is) {
	return document.createElement(name, { is });
}

/**
 * @template T
 * @template {keyof T} K
 * @param {T} obj
 * @param {K[]} exclude
 * @returns {Pick<T, Exclude<keyof T, K>>}
 */
function object_without_properties(obj, exclude) {
	const target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});
	for (const k in obj) {
		if (
			has_prop(obj, k) &&
			// @ts-ignore
			exclude.indexOf(k) === -1
		) {
			// @ts-ignore
			target[k] = obj[k];
		}
	}
	return target;
}

/**
 * @template {keyof SVGElementTagNameMap} K
 * @param {K} name
 * @returns {SVGElement}
 */
function svg_element(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

/**
 * @param {string} data
 * @returns {Text}
 */
function dom_text(data) {
	return document.createTextNode(data);
}

/**
 * @returns {Text} */
function space() {
	return dom_text(' ');
}

/**
 * @returns {Text} */
function empty() {
	return dom_text('');
}

/**
 * @param {string} content
 * @returns {Comment}
 */
function comment(content) {
	return document.createComment(content);
}

/**
 * @param {EventTarget} node
 * @param {string} event
 * @param {EventListenerOrEventListenerObject} handler
 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
 * @returns {() => void}
 */
function listen(node, event, handler, options) {
	node.addEventListener(event, handler, options);
	return () => node.removeEventListener(event, handler, options);
}

/**
 * @returns {(event: any) => any} */
function prevent_default(fn) {
	return function (event) {
		event.preventDefault();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => any} */
function stop_propagation(fn) {
	return function (event) {
		event.stopPropagation();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => any} */
function stop_immediate_propagation(fn) {
	return function (event) {
		event.stopImmediatePropagation();
		// @ts-ignore
		return fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => void} */
function dom_self(fn) {
	return function (event) {
		// @ts-ignore
		if (event.target === this) fn.call(this, event);
	};
}

/**
 * @returns {(event: any) => void} */
function trusted(fn) {
	return function (event) {
		// @ts-ignore
		if (event.isTrusted) fn.call(this, event);
	};
}

/**
 * @param {Element} node
 * @param {string} attribute
 * @param {string} [value]
 * @returns {void}
 */
function attr(node, attribute, value) {
	if (value == null) node.removeAttribute(attribute);
	else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
/**
 * List of attributes that should always be set through the attr method,
 * because updating them through the property setter doesn't work reliably.
 * In the example of `width`/`height`, the problem is that the setter only
 * accepts numeric values, but the attribute can also be set to a string like `50%`.
 * If this list becomes too big, rethink this approach.
 */
const always_set_through_set_attribute = ['width', 'height'];

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {{ [x: string]: string }} attributes
 * @returns {void}
 */
function set_attributes(node, attributes) {
	// @ts-ignore
	const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
	for (const key in attributes) {
		if (attributes[key] == null) {
			node.removeAttribute(key);
		} else if (key === 'style') {
			node.style.cssText = attributes[key];
		} else if (key === '__value') {
			/** @type {any} */ (node).value = node[key] = attributes[key];
		} else if (
			descriptors[key] &&
			descriptors[key].set &&
			always_set_through_set_attribute.indexOf(key) === -1
		) {
			node[key] = attributes[key];
		} else {
			attr(node, key, attributes[key]);
		}
	}
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {{ [x: string]: string }} attributes
 * @returns {void}
 */
function set_svg_attributes(node, attributes) {
	for (const key in attributes) {
		attr(node, key, attributes[key]);
	}
}

/**
 * @param {Record<string, unknown>} data_map
 * @returns {void}
 */
function set_custom_element_data_map(node, data_map) {
	Object.keys(data_map).forEach((key) => {
		set_custom_element_data(node, key, data_map[key]);
	});
}

/**
 * @returns {void} */
function set_custom_element_data(node, prop, value) {
	if (prop in node) {
		node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
	} else {
		attr(node, prop, value);
	}
}

/**
 * @param {string} tag
 */
function set_dynamic_element_data(tag) {
	return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}

/**
 * @returns {void}
 */
function xlink_attr(node, attribute, value) {
	node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}

/**
 * @param {HTMLElement} node
 * @returns {string}
 */
function get_svelte_dataset(node) {
	return node.dataset.svelteH;
}

/**
 * @returns {unknown[]} */
function get_binding_group_value(group, __value, checked) {
	const value = new Set();
	for (let i = 0; i < group.length; i += 1) {
		if (group[i].checked) value.add(group[i].__value);
	}
	if (!checked) {
		value.delete(__value);
	}
	return Array.from(value);
}

/**
 * @param {HTMLInputElement[]} group
 * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}
 */
function init_binding_group(group) {
	/**
	 * @type {HTMLInputElement[]} */
	let _inputs;
	return {
		/* push */ p(...inputs) {
			_inputs = inputs;
			_inputs.forEach((input) => group.push(input));
		},
		/* remove */ r() {
			_inputs.forEach((input) => group.splice(group.indexOf(input), 1));
		}
	};
}

/**
 * @param {number[]} indexes
 * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}
 */
function init_binding_group_dynamic(group, indexes) {
	/**
	 * @type {HTMLInputElement[]} */
	let _group = get_binding_group(group);

	/**
	 * @type {HTMLInputElement[]} */
	let _inputs;

	function get_binding_group(group) {
		for (let i = 0; i < indexes.length; i++) {
			group = group[indexes[i]] = group[indexes[i]] || [];
		}
		return group;
	}

	/**
	 * @returns {void} */
	function push() {
		_inputs.forEach((input) => _group.push(input));
	}

	/**
	 * @returns {void} */
	function remove() {
		_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));
	}
	return {
		/* update */ u(new_indexes) {
			indexes = new_indexes;
			const new_group = get_binding_group(group);
			if (new_group !== _group) {
				remove();
				_group = new_group;
				push();
			}
		},
		/* push */ p(...inputs) {
			_inputs = inputs;
			push();
		},
		/* remove */ r: remove
	};
}

/**
 * @returns {number} */
function to_number(value) {
	return value === '' ? null : +value;
}

/**
 * @returns {any[]} */
function time_ranges_to_array(ranges) {
	const array = [];
	for (let i = 0; i < ranges.length; i += 1) {
		array.push({ start: ranges.start(i), end: ranges.end(i) });
	}
	return array;
}

/**
 * @param {Element} element
 * @returns {ChildNode[]}
 */
function children(element) {
	return Array.from(element.childNodes);
}

/**
 * @param {ChildNodeArray} nodes
 * @returns {void}
 */
function init_claim_info(nodes) {
	if (nodes.claim_info === undefined) {
		nodes.claim_info = { last_index: 0, total_claimed: 0 };
	}
}

/**
 * @template {ChildNodeEx} R
 * @param {ChildNodeArray} nodes
 * @param {(node: ChildNodeEx) => node is R} predicate
 * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} processNode
 * @param {() => R} createNode
 * @param {boolean} dontUpdateLastIndex
 * @returns {R}
 */
function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
	// Try to find nodes in an order such that we lengthen the longest increasing subsequence
	init_claim_info(nodes);
	const resultNode = (() => {
		// We first try to find an element after the previous one
		for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
			const node = nodes[i];
			if (predicate(node)) {
				const replacement = processNode(node);
				if (replacement === undefined) {
					nodes.splice(i, 1);
				} else {
					nodes[i] = replacement;
				}
				if (!dontUpdateLastIndex) {
					nodes.claim_info.last_index = i;
				}
				return node;
			}
		}
		// Otherwise, we try to find one before
		// We iterate in reverse so that we don't go too far back
		for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
			const node = nodes[i];
			if (predicate(node)) {
				const replacement = processNode(node);
				if (replacement === undefined) {
					nodes.splice(i, 1);
				} else {
					nodes[i] = replacement;
				}
				if (!dontUpdateLastIndex) {
					nodes.claim_info.last_index = i;
				} else if (replacement === undefined) {
					// Since we spliced before the last_index, we decrease it
					nodes.claim_info.last_index--;
				}
				return node;
			}
		}
		// If we can't find any matching node, we create a new one
		return createNode();
	})();
	resultNode.claim_order = nodes.claim_info.total_claimed;
	nodes.claim_info.total_claimed += 1;
	return resultNode;
}

/**
 * @param {ChildNodeArray} nodes
 * @param {string} name
 * @param {{ [key: string]: boolean }} attributes
 * @param {(name: string) => Element | SVGElement} create_element
 * @returns {Element | SVGElement}
 */
function claim_element_base(nodes, name, attributes, create_element) {
	return claim_node(
		nodes,
		/** @returns {node is Element | SVGElement} */
		(node) => node.nodeName === name,
		/** @param {Element} node */
		(node) => {
			const remove = [];
			for (let j = 0; j < node.attributes.length; j++) {
				const attribute = node.attributes[j];
				if (!attributes[attribute.name]) {
					remove.push(attribute.name);
				}
			}
			remove.forEach((v) => node.removeAttribute(v));
			return undefined;
		},
		() => create_element(name)
	);
}

/**
 * @param {ChildNodeArray} nodes
 * @param {string} name
 * @param {{ [key: string]: boolean }} attributes
 * @returns {Element | SVGElement}
 */
function claim_element(nodes, name, attributes) {
	return claim_element_base(nodes, name, attributes, dom_element);
}

/**
 * @param {ChildNodeArray} nodes
 * @param {string} name
 * @param {{ [key: string]: boolean }} attributes
 * @returns {Element | SVGElement}
 */
function claim_svg_element(nodes, name, attributes) {
	return claim_element_base(nodes, name, attributes, svg_element);
}

/**
 * @param {ChildNodeArray} nodes
 * @returns {Text}
 */
function claim_text(nodes, data) {
	return claim_node(
		nodes,
		/** @returns {node is Text} */
		(node) => node.nodeType === 3,
		/** @param {Text} node */
		(node) => {
			const dataStr = '' + data;
			if (node.data.startsWith(dataStr)) {
				if (node.data.length !== dataStr.length) {
					return node.splitText(dataStr.length);
				}
			} else {
				node.data = dataStr;
			}
		},
		() => dom_text(data),
		true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
	);
}

/**
 * @returns {Text} */
function claim_space(nodes) {
	return claim_text(nodes, ' ');
}

/**
 * @param {ChildNodeArray} nodes
 * @returns {Comment}
 */
function claim_comment(nodes, data) {
	return claim_node(
		nodes,
		/** @returns {node is Comment} */
		(node) => node.nodeType === 8,
		/** @param {Comment} node */
		(node) => {
			node.data = '' + data;
			return undefined;
		},
		() => comment(data),
		true
	);
}

function find_comment(nodes, text, start) {
	for (let i = start; i < nodes.length; i += 1) {
		const node = nodes[i];
		if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {
			return i;
		}
	}
	return nodes.length;
}

/**
 * @param {boolean} is_svg
 * @returns {HtmlTagHydration}
 */
function claim_html_tag(nodes, is_svg) {
	// find html opening tag
	const start_index = find_comment(nodes, 'HTML_TAG_START', 0);
	const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);
	if (start_index === end_index) {
		return new HtmlTagHydration(undefined, is_svg);
	}
	init_claim_info(nodes);
	const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
	dom_detach(html_tag_nodes[0]);
	dom_detach(html_tag_nodes[html_tag_nodes.length - 1]);
	const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
	for (const n of claimed_nodes) {
		n.claim_order = nodes.claim_info.total_claimed;
		nodes.claim_info.total_claimed += 1;
	}
	return new HtmlTagHydration(claimed_nodes, is_svg);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data(text, data) {
	data = '' + data;
	if (text.data === data) return;
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data_contenteditable(text, data) {
	data = '' + data;
	if (text.wholeText === data) return;
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @param {string} attr_value
 * @returns {void}
 */
function set_data_maybe_contenteditable(text, data, attr_value) {
	if (~contenteditable_truthy_values.indexOf(attr_value)) {
		set_data_contenteditable(text, data);
	} else {
		set_data(text, data);
	}
}

/**
 * @returns {void} */
function set_input_value(input, value) {
	input.value = value == null ? '' : value;
}

/**
 * @returns {void} */
function set_input_type(input, type) {
	try {
		input.type = type;
	} catch (e) {
		// do nothing
	}
}

/**
 * @returns {void} */
function set_style(node, key, value, important) {
	if (value == null) {
		node.style.removeProperty(key);
	} else {
		node.style.setProperty(key, value, important ? 'important' : '');
	}
}

/**
 * @returns {void} */
function select_option(select, value, mounting) {
	for (let i = 0; i < select.options.length; i += 1) {
		const option = select.options[i];
		if (option.__value === value) {
			option.selected = true;
			return;
		}
	}
	if (!mounting || value !== undefined) {
		select.selectedIndex = -1; // no option should be selected
	}
}

/**
 * @returns {void} */
function select_options(select, value) {
	for (let i = 0; i < select.options.length; i += 1) {
		const option = select.options[i];
		option.selected = ~value.indexOf(option.__value);
	}
}

function select_value(select) {
	const selected_option = select.querySelector(':checked');
	return selected_option && selected_option.__value;
}

function select_multiple_value(select) {
	return [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead

/**
 * @type {boolean} */
let crossorigin;

/**
 * @returns {boolean} */
function is_crossorigin() {
	if (crossorigin === undefined) {
		crossorigin = false;
		try {
			if (typeof window !== 'undefined' && window.parent) {
				void window.parent.document;
			}
		} catch (error) {
			crossorigin = true;
		}
	}
	return crossorigin;
}

/**
 * @param {HTMLElement} node
 * @param {() => void} fn
 * @returns {() => void}
 */
function add_iframe_resize_listener(node, fn) {
	const computed_style = getComputedStyle(node);
	if (computed_style.position === 'static') {
		node.style.position = 'relative';
	}
	const iframe = dom_element('iframe');
	iframe.setAttribute(
		'style',
		'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
			'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'
	);
	iframe.setAttribute('aria-hidden', 'true');
	iframe.tabIndex = -1;
	const crossorigin = is_crossorigin();

	/**
	 * @type {() => void}
	 */
	let unsubscribe;
	if (crossorigin) {
		iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
		unsubscribe = listen(
			window,
			'message',
			/** @param {MessageEvent} event */ (event) => {
				if (event.source === iframe.contentWindow) fn();
			}
		);
	} else {
		iframe.src = 'about:blank';
		iframe.onload = () => {
			unsubscribe = listen(iframe.contentWindow, 'resize', fn);
			// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)
			// see https://github.com/sveltejs/svelte/issues/4233
			fn();
		};
	}
	append(node, iframe);
	return () => {
		if (crossorigin) {
			unsubscribe();
		} else if (unsubscribe && iframe.contentWindow) {
			unsubscribe();
		}
		dom_detach(iframe);
	};
}
const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
	box: 'content-box'
});
const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
	box: 'border-box'
});
const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(
	{ box: 'device-pixel-content-box' }
);


/**
 * @returns {void} */
function toggle_class(element, name, toggle) {
	// The `!!` is required because an `undefined` flag means flipping the current state.
	element.classList.toggle(name, !!toggle);
}

/**
 * @template T
 * @param {string} type
 * @param {T} [detail]
 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
 * @returns {CustomEvent<T>}
 */
function dom_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
	return new CustomEvent(type, { detail, bubbles, cancelable });
}

/**
 * @param {string} selector
 * @param {HTMLElement} parent
 * @returns {ChildNodeArray}
 */
function query_selector_all(selector, parent = document.body) {
	return Array.from(parent.querySelectorAll(selector));
}

/**
 * @param {string} nodeId
 * @param {HTMLElement} head
 * @returns {any[]}
 */
function head_selector(nodeId, head) {
	const result = [];
	let started = 0;
	for (const node of head.childNodes) {
		if (node.nodeType === 8 /* comment node */) {
			const comment = node.textContent.trim();
			if (comment === `HEAD_${nodeId}_END`) {
				started -= 1;
				result.push(node);
			} else if (comment === `HEAD_${nodeId}_START`) {
				started += 1;
				result.push(node);
			}
		} else if (started > 0) {
			result.push(node);
		}
	}
	return result;
}
/** */
class HtmlTag {
	/**
	 * @private
	 * @default false
	 */
	is_svg = false;
	// parent for creating node
	/** */
	e = undefined;
	// html tag nodes
	/** */
	n = undefined;
	// target
	/** */
	t = undefined;
	// anchor
	/** */
	a = undefined;
	constructor(is_svg = false) {
		this.is_svg = is_svg;
		this.e = this.n = null;
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	c(html) {
		this.h(html);
	}

	/**
	 * @param {string} html
	 * @param {HTMLElement | SVGElement} target
	 * @param {HTMLElement | SVGElement} anchor
	 * @returns {void}
	 */
	m(html, target, anchor = null) {
		if (!this.e) {
			if (this.is_svg)
				this.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));
			/** #7364  target for <template> may be provided as #document-fragment(11) */ else
				this.e = dom_element(
					/** @type {keyof HTMLElementTagNameMap} */ (
						target.nodeType === 11 ? 'TEMPLATE' : target.nodeName
					)
				);
			this.t =
				target.tagName !== 'TEMPLATE'
					? target
					: /** @type {HTMLTemplateElement} */ (target).content;
			this.c(html);
		}
		this.i(anchor);
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	h(html) {
		this.e.innerHTML = html;
		this.n = Array.from(
			this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes
		);
	}

	/**
	 * @returns {void} */
	i(anchor) {
		for (let i = 0; i < this.n.length; i += 1) {
			insert(this.t, this.n[i], anchor);
		}
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	p(html) {
		this.d();
		this.h(html);
		this.i(this.a);
	}

	/**
	 * @returns {void} */
	d() {
		this.n.forEach(dom_detach);
	}
}

/**
 * @extends HtmlTag */
class HtmlTagHydration extends (/* unused pure expression or super */ null && (HtmlTag)) {
	// hydration claimed nodes
	/** */
	l = undefined;
	constructor(claimed_nodes, is_svg = false) {
		super(is_svg);
		this.e = this.n = null;
		this.l = claimed_nodes;
	}

	/**
	 * @param {string} html
	 * @returns {void}
	 */
	c(html) {
		if (this.l) {
			this.n = this.l;
		} else {
			super.c(html);
		}
	}

	/**
	 * @returns {void} */
	i(anchor) {
		for (let i = 0; i < this.n.length; i += 1) {
			dom_insert_hydration(this.t, this.n[i], anchor);
		}
	}
}

/**
 * @param {NamedNodeMap} attributes
 * @returns {{}}
 */
function attribute_to_object(attributes) {
	const result = {};
	for (const attribute of attributes) {
		result[attribute.name] = attribute.value;
	}
	return result;
}

/**
 * @param {HTMLElement} element
 * @returns {{}}
 */
function get_custom_elements_slots(element) {
	const result = {};
	element.childNodes.forEach(
		/** @param {Element} node */ (node) => {
			result[node.slot || 'default'] = true;
		}
	);
	return result;
}

function construct_svelte_component(component, props) {
	return new component(props);
}

/**
 * @typedef {Node & {
 * 	claim_order?: number;
 * 	hydrate_init?: true;
 * 	actual_end_child?: NodeEx;
 * 	childNodes: NodeListOf<NodeEx>;
 * }} NodeEx
 */

/** @typedef {ChildNode & NodeEx} ChildNodeEx */

/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

/**
 * @typedef {ChildNodeEx[] & {
 * 	claim_info?: {
 * 		last_index: number;
 * 		total_claimed: number;
 * 	};
 * }} ChildNodeArray
 */

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/style_manager.js



// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */
const managed_styles = new Map();

let active = 0;

// https://github.com/darkskyapp/string-hash/blob/master/index.js
/**
 * @param {string} str
 * @returns {number}
 */
function hash(str) {
	let hash = 5381;
	let i = str.length;
	while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
	return hash >>> 0;
}

/**
 * @param {Document | ShadowRoot} doc
 * @param {Element & ElementCSSInlineStyle} node
 * @returns {{ stylesheet: any; rules: {}; }}
 */
function create_style_information(doc, node) {
	const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
	managed_styles.set(doc, info);
	return info;
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {number} a
 * @param {number} b
 * @param {number} duration
 * @param {number} delay
 * @param {(t: number) => number} ease
 * @param {(t: number, u: number) => string} fn
 * @param {number} uid
 * @returns {string}
 */
function style_manager_create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
	const step = 16.666 / duration;
	let keyframes = '{\n';
	for (let p = 0; p <= 1; p += step) {
		const t = a + (b - a) * ease(p);
		keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
	}
	const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
	const name = `__svelte_${hash(rule)}_${uid}`;
	const doc = get_root_for_style(node);
	const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
	if (!rules[name]) {
		rules[name] = true;
		stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
	}
	const animation = node.style.animation || '';
	node.style.animation = `${
		animation ? `${animation}, ` : ''
	}${name} ${duration}ms linear ${delay}ms 1 both`;
	active += 1;
	return name;
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {string} [name]
 * @returns {void}
 */
function style_manager_delete_rule(node, name) {
	const previous = (node.style.animation || '').split(', ');
	const next = previous.filter(
		name
			? (anim) => anim.indexOf(name) < 0 // remove specific animation
			: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations
	);
	const deleted = previous.length - next.length;
	if (deleted) {
		node.style.animation = next.join(', ');
		active -= deleted;
		if (!active) clear_rules();
	}
}

/** @returns {void} */
function clear_rules() {
	raf(() => {
		if (active) return;
		managed_styles.forEach((info) => {
			const { ownerNode } = info.stylesheet;
			// there is no ownerNode if it runs on jsdom.
			if (ownerNode) detach(ownerNode);
		});
		managed_styles.clear();
	});
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/animations.js





/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {import('./private.js').PositionRect} from
 * @param {import('./private.js').AnimationFn} fn
 */
function create_animation(node, from, fn, params) {
	if (!from) return noop;
	const to = node.getBoundingClientRect();
	if (
		from.left === to.left &&
		from.right === to.right &&
		from.top === to.top &&
		from.bottom === to.bottom
	)
		return noop;
	const {
		delay = 0,
		duration = 300,
		easing = linear,
		// @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
		start: start_time = now() + delay,
		// @ts-ignore todo:
		end = start_time + duration,
		tick = noop,
		css
	} = fn(node, { from, to }, params);
	let running = true;
	let started = false;
	let name;
	/** @returns {void} */
	function start() {
		if (css) {
			name = create_rule(node, 0, 1, duration, delay, easing, css);
		}
		if (!delay) {
			started = true;
		}
	}
	/** @returns {void} */
	function stop() {
		if (css) delete_rule(node, name);
		running = false;
	}
	loop((now) => {
		if (!started && now >= start_time) {
			started = true;
		}
		if (started && now >= end) {
			tick(1, 0);
			stop();
		}
		if (!running) {
			return false;
		}
		if (started) {
			const p = now - start_time;
			const t = 0 + 1 * easing(p / duration);
			tick(t, 1 - t);
		}
		return true;
	});
	start();
	tick(0, 1);
	return stop;
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @returns {void}
 */
function fix_position(node) {
	const style = getComputedStyle(node);
	if (style.position !== 'absolute' && style.position !== 'fixed') {
		const { width, height } = style;
		const a = node.getBoundingClientRect();
		node.style.position = 'absolute';
		node.style.width = width;
		node.style.height = height;
		add_transform(node, a);
	}
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {import('./private.js').PositionRect} a
 * @returns {void}
 */
function add_transform(node, a) {
	const b = node.getBoundingClientRect();
	if (a.left !== b.left || a.top !== b.top) {
		const style = getComputedStyle(node);
		const transform = style.transform === 'none' ? '' : style.transform;
		node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
	}
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/lifecycle.js


let lifecycle_current_component;

/** @returns {void} */
function lifecycle_set_current_component(component) {
	lifecycle_current_component = component;
}

function get_current_component() {
	if (!lifecycle_current_component) throw new Error('Function called outside component initialization');
	return lifecycle_current_component;
}

/**
 * Schedules a callback to run immediately before the component is updated after any state change.
 *
 * The first time the callback runs will be before the initial `onMount`
 *
 * https://svelte.dev/docs/svelte#beforeupdate
 * @param {() => any} fn
 * @returns {void}
 */
function beforeUpdate(fn) {
	get_current_component().$$.before_update.push(fn);
}

/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs/svelte#onmount
 * @template T
 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
 * @returns {void}
 */
function onMount(fn) {
	get_current_component().$$.on_mount.push(fn);
}

/**
 * Schedules a callback to run immediately after the component has been updated.
 *
 * The first time the callback runs will be after the initial `onMount`
 *
 * https://svelte.dev/docs/svelte#afterupdate
 * @param {() => any} fn
 * @returns {void}
 */
function afterUpdate(fn) {
	get_current_component().$$.after_update.push(fn);
}

/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs/svelte#ondestroy
 * @param {() => any} fn
 * @returns {void}
 */
function onDestroy(fn) {
	get_current_component().$$.on_destroy.push(fn);
}

/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
 * ```ts
 * const dispatch = createEventDispatcher<{
 *  loaded: never; // does not take a detail argument
 *  change: string; // takes a detail argument of type string, which is required
 *  optional: number | null; // takes an optional detail argument of type number
 * }>();
 * ```
 *
 * https://svelte.dev/docs/svelte#createeventdispatcher
 * @template {Record<string, any>} [EventMap=any]
 * @returns {import('./public.js').EventDispatcher<EventMap>}
 */
function createEventDispatcher() {
	const component = get_current_component();
	return (type, detail, { cancelable = false } = {}) => {
		const callbacks = component.$$.callbacks[type];
		if (callbacks) {
			// TODO are there situations where events could be dispatched
			// in a server (non-DOM) environment?
			const event = dom_custom_event(/** @type {string} */ (type), detail, { cancelable });
			callbacks.slice().forEach((fn) => {
				fn.call(component, event);
			});
			return !event.defaultPrevented;
		}
		return true;
	};
}

/**
 * Associates an arbitrary `context` object with the current component and the specified `key`
 * and returns that object. The context is then available to children of the component
 * (including slotted content) with `getContext`.
 *
 * Like lifecycle functions, this must be called during component initialisation.
 *
 * https://svelte.dev/docs/svelte#setcontext
 * @template T
 * @param {any} key
 * @param {T} context
 * @returns {T}
 */
function setContext(key, context) {
	get_current_component().$$.context.set(key, context);
	return context;
}

/**
 * Retrieves the context that belongs to the closest parent component with the specified `key`.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs/svelte#getcontext
 * @template T
 * @param {any} key
 * @returns {T}
 */
function lifecycle_getContext(key) {
	return get_current_component().$$.context.get(key);
}

/**
 * Retrieves the whole context map that belongs to the closest parent component.
 * Must be called during component initialisation. Useful, for example, if you
 * programmatically create a component and want to pass the existing context to it.
 *
 * https://svelte.dev/docs/svelte#getallcontexts
 * @template {Map<any, any>} [T=Map<any, any>]
 * @returns {T}
 */
function getAllContexts() {
	return get_current_component().$$.context;
}

/**
 * Checks whether a given `key` has been set in the context of a parent component.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs/svelte#hascontext
 * @param {any} key
 * @returns {boolean}
 */
function hasContext(key) {
	return get_current_component().$$.context.has(key);
}

// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
/**
 * @param component
 * @param event
 * @returns {void}
 */
function bubble(component, event) {
	const callbacks = component.$$.callbacks[event.type];
	if (callbacks) {
		// @ts-ignore
		callbacks.slice().forEach((fn) => fn.call(this, event));
	}
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/scheduler.js



const dirty_components = [];
const intros = { enabled: false };
const binding_callbacks = [];

let render_callbacks = [];

const flush_callbacks = [];

const resolved_promise = /* @__PURE__ */ Promise.resolve();

let update_scheduled = false;

/** @returns {void} */
function schedule_update() {
	if (!update_scheduled) {
		update_scheduled = true;
		resolved_promise.then(flush);
	}
}

/** @returns {Promise<void>} */
function tick() {
	schedule_update();
	return resolved_promise;
}

/** @returns {void} */
function scheduler_add_render_callback(fn) {
	render_callbacks.push(fn);
}

/** @returns {void} */
function add_flush_callback(fn) {
	flush_callbacks.push(fn);
}

// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();

let flushidx = 0; // Do *not* move this inside the flush() function

/** @returns {void} */
function flush() {
	// Do not reenter flush while dirty components are updated, as this can
	// result in an infinite loop. Instead, let the inner flush handle it.
	// Reentrancy is ok afterwards for bindings etc.
	if (flushidx !== 0) {
		return;
	}
	const saved_component = lifecycle_current_component;
	do {
		// first, call beforeUpdate functions
		// and update components
		try {
			while (flushidx < dirty_components.length) {
				const component = dirty_components[flushidx];
				flushidx++;
				lifecycle_set_current_component(component);
				scheduler_update(component.$$);
			}
		} catch (e) {
			// reset dirty state to not end up in a deadlocked state and then rethrow
			dirty_components.length = 0;
			flushidx = 0;
			throw e;
		}
		lifecycle_set_current_component(null);
		dirty_components.length = 0;
		flushidx = 0;
		while (binding_callbacks.length) binding_callbacks.pop()();
		// then, once components are updated, call
		// afterUpdate functions. This may cause
		// subsequent updates...
		for (let i = 0; i < render_callbacks.length; i += 1) {
			const callback = render_callbacks[i];
			if (!seen_callbacks.has(callback)) {
				// ...so guard against infinite loops
				seen_callbacks.add(callback);
				callback();
			}
		}
		render_callbacks.length = 0;
	} while (dirty_components.length);
	while (flush_callbacks.length) {
		flush_callbacks.pop()();
	}
	update_scheduled = false;
	seen_callbacks.clear();
	lifecycle_set_current_component(saved_component);
}

/** @returns {void} */
function scheduler_update($$) {
	if ($$.fragment !== null) {
		$$.update();
		utils_run_all($$.before_update);
		const dirty = $$.dirty;
		$$.dirty = [-1];
		$$.fragment && $$.fragment.p($$.ctx, dirty);
		$$.after_update.forEach(scheduler_add_render_callback);
	}
}

/**
 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
 * @param {Function[]} fns
 * @returns {void}
 */
function flush_render_callbacks(fns) {
	const filtered = [];
	const targets = [];
	render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
	targets.forEach((c) => c());
	render_callbacks = filtered;
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/transitions.js







/**
 * @type {Promise<void> | null}
 */
let promise;

/**
 * @returns {Promise<void>}
 */
function wait() {
	if (!promise) {
		promise = Promise.resolve();
		promise.then(() => {
			promise = null;
		});
	}
	return promise;
}

/**
 * @param {Element} node
 * @param {INTRO | OUTRO | boolean} direction
 * @param {'start' | 'end'} kind
 * @returns {void}
 */
function dispatch(node, direction, kind) {
	node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}

const outroing = new Set();

/**
 * @type {Outro}
 */
let outros;

/**
 * @returns {void} */
function group_outros() {
	outros = {
		r: 0,
		c: [],
		p: outros // parent group
	};
}

/**
 * @returns {void} */
function check_outros() {
	if (!outros.r) {
		utils_run_all(outros.c);
	}
	outros = outros.p;
}

/**
 * @param {import('./private.js').Fragment} block
 * @param {0 | 1} [local]
 * @returns {void}
 */
function transitions_transition_in(block, local) {
	if (block && block.i) {
		outroing.delete(block);
		block.i(local);
	}
}

/**
 * @param {import('./private.js').Fragment} block
 * @param {0 | 1} local
 * @param {0 | 1} [detach]
 * @param {() => void} [callback]
 * @returns {void}
 */
function transitions_transition_out(block, local, detach, callback) {
	if (block && block.o) {
		if (outroing.has(block)) return;
		outroing.add(block);
		outros.c.push(() => {
			outroing.delete(block);
			if (callback) {
				if (detach) block.d(1);
				callback();
			}
		});
		block.o(local);
	} else if (callback) {
		callback();
	}
}

/**
 * @type {import('../transition/public.js').TransitionConfig}
 */
const null_transition = { duration: 0 };

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {TransitionFn} fn
 * @param {any} params
 * @returns {{ start(): void; invalidate(): void; end(): void; }}
 */
function create_in_transition(node, fn, params) {
	/**
	 * @type {TransitionOptions} */
	const options = { direction: 'in' };
	let config = fn(node, params, options);
	let running = false;
	let animation_name;
	let task;
	let uid = 0;

	/**
	 * @returns {void} */
	function cleanup() {
		if (animation_name) delete_rule(node, animation_name);
	}

	/**
	 * @returns {void} */
	function go() {
		const {
			delay = 0,
			duration = 300,
			easing = linear,
			tick = noop,
			css
		} = config || null_transition;
		if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
		tick(0, 1);
		const start_time = now() + delay;
		const end_time = start_time + duration;
		if (task) task.abort();
		running = true;
		add_render_callback(() => dispatch(node, true, 'start'));
		task = loop((now) => {
			if (running) {
				if (now >= end_time) {
					tick(1, 0);
					dispatch(node, true, 'end');
					cleanup();
					return (running = false);
				}
				if (now >= start_time) {
					const t = easing((now - start_time) / duration);
					tick(t, 1 - t);
				}
			}
			return running;
		});
	}
	let started = false;
	return {
		start() {
			if (started) return;
			started = true;
			delete_rule(node);
			if (is_function(config)) {
				config = config(options);
				wait().then(go);
			} else {
				go();
			}
		},
		invalidate() {
			started = false;
		},
		end() {
			if (running) {
				cleanup();
				running = false;
			}
		}
	};
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {TransitionFn} fn
 * @param {any} params
 * @returns {{ end(reset: any): void; }}
 */
function create_out_transition(node, fn, params) {
	/** @type {TransitionOptions} */
	const options = { direction: 'out' };
	let config = fn(node, params, options);
	let running = true;
	let animation_name;
	const group = outros;
	group.r += 1;
	/** @type {boolean} */
	let original_inert_value;

	/**
	 * @returns {void} */
	function go() {
		const {
			delay = 0,
			duration = 300,
			easing = linear,
			tick = noop,
			css
		} = config || null_transition;

		if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

		const start_time = now() + delay;
		const end_time = start_time + duration;
		add_render_callback(() => dispatch(node, false, 'start'));

		if ('inert' in node) {
			original_inert_value = /** @type {HTMLElement} */ (node).inert;
			node.inert = true;
		}

		loop((now) => {
			if (running) {
				if (now >= end_time) {
					tick(0, 1);
					dispatch(node, false, 'end');
					if (!--group.r) {
						// this will result in `end()` being called,
						// so we don't need to clean up here
						run_all(group.c);
					}
					return false;
				}
				if (now >= start_time) {
					const t = easing((now - start_time) / duration);
					tick(1 - t, t);
				}
			}
			return running;
		});
	}

	if (is_function(config)) {
		wait().then(() => {
			// @ts-ignore
			config = config(options);
			go();
		});
	} else {
		go();
	}

	return {
		end(reset) {
			if (reset && 'inert' in node) {
				node.inert = original_inert_value;
			}
			if (reset && config.tick) {
				config.tick(1, 0);
			}
			if (running) {
				if (animation_name) delete_rule(node, animation_name);
				running = false;
			}
		}
	};
}

/**
 * @param {Element & ElementCSSInlineStyle} node
 * @param {TransitionFn} fn
 * @param {any} params
 * @param {boolean} intro
 * @returns {{ run(b: 0 | 1): void; end(): void; }}
 */
function create_bidirectional_transition(node, fn, params, intro) {
	/**
	 * @type {TransitionOptions} */
	const options = { direction: 'both' };
	let config = fn(node, params, options);
	let t = intro ? 0 : 1;

	/**
	 * @type {Program | null} */
	let running_program = null;

	/**
	 * @type {PendingProgram | null} */
	let pending_program = null;
	let animation_name = null;

	/** @type {boolean} */
	let original_inert_value;

	/**
	 * @returns {void} */
	function clear_animation() {
		if (animation_name) delete_rule(node, animation_name);
	}

	/**
	 * @param {PendingProgram} program
	 * @param {number} duration
	 * @returns {Program}
	 */
	function init(program, duration) {
		const d = /** @type {Program['d']} */ (program.b - t);
		duration *= Math.abs(d);
		return {
			a: t,
			b: program.b,
			d,
			duration,
			start: program.start,
			end: program.start + duration,
			group: program.group
		};
	}

	/**
	 * @param {INTRO | OUTRO} b
	 * @returns {void}
	 */
	function go(b) {
		const {
			delay = 0,
			duration = 300,
			easing = linear,
			tick = noop,
			css
		} = config || null_transition;

		/**
		 * @type {PendingProgram} */
		const program = {
			start: now() + delay,
			b
		};

		if (!b) {
			// @ts-ignore todo: improve typings
			program.group = outros;
			outros.r += 1;
		}

		if ('inert' in node) {
			if (b) {
				if (original_inert_value !== undefined) {
					// aborted/reversed outro — restore previous inert value
					node.inert = original_inert_value;
				}
			} else {
				original_inert_value = /** @type {HTMLElement} */ (node).inert;
				node.inert = true;
			}
		}

		if (running_program || pending_program) {
			pending_program = program;
		} else {
			// if this is an intro, and there's a delay, we need to do
			// an initial tick and/or apply CSS animation immediately
			if (css) {
				clear_animation();
				animation_name = create_rule(node, t, b, duration, delay, easing, css);
			}
			if (b) tick(0, 1);
			running_program = init(program, duration);
			add_render_callback(() => dispatch(node, b, 'start'));
			loop((now) => {
				if (pending_program && now > pending_program.start) {
					running_program = init(pending_program, duration);
					pending_program = null;
					dispatch(node, running_program.b, 'start');
					if (css) {
						clear_animation();
						animation_name = create_rule(
							node,
							t,
							running_program.b,
							running_program.duration,
							0,
							easing,
							config.css
						);
					}
				}
				if (running_program) {
					if (now >= running_program.end) {
						tick((t = running_program.b), 1 - t);
						dispatch(node, running_program.b, 'end');
						if (!pending_program) {
							// we're done
							if (running_program.b) {
								// intro — we can tidy up immediately
								clear_animation();
							} else {
								// outro — needs to be coordinated
								if (!--running_program.group.r) run_all(running_program.group.c);
							}
						}
						running_program = null;
					} else if (now >= running_program.start) {
						const p = now - running_program.start;
						t = running_program.a + running_program.d * easing(p / running_program.duration);
						tick(t, 1 - t);
					}
				}
				return !!(running_program || pending_program);
			});
		}
	}
	return {
		run(b) {
			if (is_function(config)) {
				wait().then(() => {
					const opts = { direction: b ? 'in' : 'out' };
					// @ts-ignore
					config = config(opts);
					go(b);
				});
			} else {
				go(b);
			}
		},
		end() {
			clear_animation();
			running_program = pending_program = null;
		}
	};
}

/** @typedef {1} INTRO */
/** @typedef {0} OUTRO */
/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

/**
 * @typedef {Object} Outro
 * @property {number} r
 * @property {Function[]} c
 * @property {Object} p
 */

/**
 * @typedef {Object} PendingProgram
 * @property {number} start
 * @property {INTRO|OUTRO} b
 * @property {Outro} [group]
 */

/**
 * @typedef {Object} Program
 * @property {number} a
 * @property {INTRO|OUTRO} b
 * @property {1|-1} d
 * @property {number} duration
 * @property {number} start
 * @property {number} end
 * @property {Outro} [group]
 */

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/await_block.js





/**
 * @template T
 * @param {Promise<T>} promise
 * @param {import('./private.js').PromiseInfo<T>} info
 * @returns {boolean}
 */
function handle_promise(promise, info) {
	const token = (info.token = {});
	/**
	 * @param {import('./private.js').FragmentFactory} type
	 * @param {0 | 1 | 2} index
	 * @param {number} [key]
	 * @param {any} [value]
	 * @returns {void}
	 */
	function update(type, index, key, value) {
		if (info.token !== token) return;
		info.resolved = value;
		let child_ctx = info.ctx;
		if (key !== undefined) {
			child_ctx = child_ctx.slice();
			child_ctx[key] = value;
		}
		const block = type && (info.current = type)(child_ctx);
		let needs_flush = false;
		if (info.block) {
			if (info.blocks) {
				info.blocks.forEach((block, i) => {
					if (i !== index && block) {
						group_outros();
						transitions_transition_out(block, 1, 1, () => {
							if (info.blocks[i] === block) {
								info.blocks[i] = null;
							}
						});
						check_outros();
					}
				});
			} else {
				info.block.d(1);
			}
			block.c();
			transitions_transition_in(block, 1);
			block.m(info.mount(), info.anchor);
			needs_flush = true;
		}
		info.block = block;
		if (info.blocks) info.blocks[index] = block;
		if (needs_flush) {
			flush();
		}
	}
	if (is_promise(promise)) {
		const current_component = get_current_component();
		promise.then(
			(value) => {
				lifecycle_set_current_component(current_component);
				update(info.then, 1, info.value, value);
				lifecycle_set_current_component(null);
			},
			(error) => {
				lifecycle_set_current_component(current_component);
				update(info.catch, 2, info.error, error);
				lifecycle_set_current_component(null);
				if (!info.hasCatch) {
					throw error;
				}
			}
		);
		// if we previously had a then/catch block, destroy it
		if (info.current !== info.pending) {
			update(info.pending, 0);
			return true;
		}
	} else {
		if (info.current !== info.then) {
			update(info.then, 1, info.value, promise);
			return true;
		}
		info.resolved = /** @type {T} */ (promise);
	}
}

/** @returns {void} */
function update_await_block_branch(info, ctx, dirty) {
	const child_ctx = ctx.slice();
	const { resolved } = info;
	if (info.current === info.then) {
		child_ctx[info.value] = resolved;
	}
	if (info.current === info.catch) {
		child_ctx[info.error] = resolved;
	}
	info.block.p(child_ctx, dirty);
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/each.js



// general each functions:

function each_ensure_array_like(array_like_or_iterator) {
	return array_like_or_iterator?.length !== undefined
		? array_like_or_iterator
		: Array.from(array_like_or_iterator);
}

// keyed each functions:

/** @returns {void} */
function destroy_block(block, lookup) {
	block.d(1);
	lookup.delete(block.key);
}

/** @returns {void} */
function outro_and_destroy_block(block, lookup) {
	transition_out(block, 1, 1, () => {
		lookup.delete(block.key);
	});
}

/** @returns {void} */
function fix_and_destroy_block(block, lookup) {
	block.f();
	destroy_block(block, lookup);
}

/** @returns {void} */
function fix_and_outro_and_destroy_block(block, lookup) {
	block.f();
	outro_and_destroy_block(block, lookup);
}

/** @returns {any[]} */
function update_keyed_each(
	old_blocks,
	dirty,
	get_key,
	dynamic,
	ctx,
	list,
	lookup,
	node,
	destroy,
	create_each_block,
	next,
	get_context
) {
	let o = old_blocks.length;
	let n = list.length;
	let i = o;
	const old_indexes = {};
	while (i--) old_indexes[old_blocks[i].key] = i;
	const new_blocks = [];
	const new_lookup = new Map();
	const deltas = new Map();
	const updates = [];
	i = n;
	while (i--) {
		const child_ctx = get_context(ctx, list, i);
		const key = get_key(child_ctx);
		let block = lookup.get(key);
		if (!block) {
			block = create_each_block(key, child_ctx);
			block.c();
		} else if (dynamic) {
			// defer updates until all the DOM shuffling is done
			updates.push(() => block.p(child_ctx, dirty));
		}
		new_lookup.set(key, (new_blocks[i] = block));
		if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
	}
	const will_move = new Set();
	const did_move = new Set();
	/** @returns {void} */
	function insert(block) {
		transition_in(block, 1);
		block.m(node, next);
		lookup.set(block.key, block);
		next = block.first;
		n--;
	}
	while (o && n) {
		const new_block = new_blocks[n - 1];
		const old_block = old_blocks[o - 1];
		const new_key = new_block.key;
		const old_key = old_block.key;
		if (new_block === old_block) {
			// do nothing
			next = new_block.first;
			o--;
			n--;
		} else if (!new_lookup.has(old_key)) {
			// remove old block
			destroy(old_block, lookup);
			o--;
		} else if (!lookup.has(new_key) || will_move.has(new_key)) {
			insert(new_block);
		} else if (did_move.has(old_key)) {
			o--;
		} else if (deltas.get(new_key) > deltas.get(old_key)) {
			did_move.add(new_key);
			insert(new_block);
		} else {
			will_move.add(old_key);
			o--;
		}
	}
	while (o--) {
		const old_block = old_blocks[o];
		if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
	}
	while (n) insert(new_blocks[n - 1]);
	run_all(updates);
	return new_blocks;
}

/** @returns {void} */
function validate_each_keys(ctx, list, get_context, get_key) {
	const keys = new Map();
	for (let i = 0; i < list.length; i++) {
		const key = get_key(get_context(ctx, list, i));
		if (keys.has(key)) {
			let value = '';
			try {
				value = `with value '${String(key)}' `;
			} catch (e) {
				// can't stringify
			}
			throw new Error(
				`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(
					key
				)} and ${i} ${value}are duplicates`
			);
		}
		keys.set(key, i);
	}
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/spread.js
/** @returns {{}} */
function get_spread_update(levels, updates) {
	const update = {};
	const to_null_out = {};
	const accounted_for = { $$scope: 1 };
	let i = levels.length;
	while (i--) {
		const o = levels[i];
		const n = updates[i];
		if (n) {
			for (const key in o) {
				if (!(key in n)) to_null_out[key] = 1;
			}
			for (const key in n) {
				if (!accounted_for[key]) {
					update[key] = n[key];
					accounted_for[key] = 1;
				}
			}
			levels[i] = n;
		} else {
			for (const key in o) {
				accounted_for[key] = 1;
			}
		}
	}
	for (const key in to_null_out) {
		if (!(key in update)) update[key] = undefined;
	}
	return update;
}

function get_spread_object(spread_props) {
	return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/boolean_attributes.js
const _boolean_attributes = /** @type {const} */ ([
	'allowfullscreen',
	'allowpaymentrequest',
	'async',
	'autofocus',
	'autoplay',
	'checked',
	'controls',
	'default',
	'defer',
	'disabled',
	'formnovalidate',
	'hidden',
	'inert',
	'ismap',
	'loop',
	'multiple',
	'muted',
	'nomodule',
	'novalidate',
	'open',
	'playsinline',
	'readonly',
	'required',
	'reversed',
	'selected'
]);

/**
 * List of HTML boolean attributes (e.g. `<input disabled>`).
 * Source: https://html.spec.whatwg.org/multipage/indices.html
 *
 * @type {Set<string>}
 */
const boolean_attributes_boolean_attributes = new Set([..._boolean_attributes]);

/** @typedef {typeof _boolean_attributes[number]} BooleanAttributes */

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ssr.js






const invalid_attribute_name_character =
	/[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter

/** @returns {string} */
function spread(args, attrs_to_add) {
	const attributes = Object.assign({}, ...args);
	if (attrs_to_add) {
		const classes_to_add = attrs_to_add.classes;
		const styles_to_add = attrs_to_add.styles;
		if (classes_to_add) {
			if (attributes.class == null) {
				attributes.class = classes_to_add;
			} else {
				attributes.class += ' ' + classes_to_add;
			}
		}
		if (styles_to_add) {
			if (attributes.style == null) {
				attributes.style = style_object_to_string(styles_to_add);
			} else {
				attributes.style = style_object_to_string(
					merge_ssr_styles(attributes.style, styles_to_add)
				);
			}
		}
	}
	let str = '';
	Object.keys(attributes).forEach((name) => {
		if (invalid_attribute_name_character.test(name)) return;
		const value = attributes[name];
		if (value === true) str += ' ' + name;
		else if (boolean_attributes.has(name.toLowerCase())) {
			if (value) str += ' ' + name;
		} else if (value != null) {
			str += ` ${name}="${value}"`;
		}
	});
	return str;
}

/** @returns {{}} */
function merge_ssr_styles(style_attribute, style_directive) {
	const style_object = {};
	for (const individual_style of style_attribute.split(';')) {
		const colon_index = individual_style.indexOf(':');
		const name = individual_style.slice(0, colon_index).trim();
		const value = individual_style.slice(colon_index + 1).trim();
		if (!name) continue;
		style_object[name] = value;
	}
	for (const name in style_directive) {
		const value = style_directive[name];
		if (value) {
			style_object[name] = value;
		} else {
			delete style_object[name];
		}
	}
	return style_object;
}

const ATTR_REGEX = /[&"]/g;
const CONTENT_REGEX = /[&<]/g;

/**
 * Note: this method is performance sensitive and has been optimized
 * https://github.com/sveltejs/svelte/pull/5701
 * @param {unknown} value
 * @returns {string}
 */
function ssr_escape(value, is_attr = false) {
	const str = String(value);
	const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
	pattern.lastIndex = 0;
	let escaped = '';
	let last = 0;
	while (pattern.test(str)) {
		const i = pattern.lastIndex - 1;
		const ch = str[i];
		escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '"' ? '&quot;' : '&lt;');
		last = i + 1;
	}
	return escaped + str.substring(last);
}

function escape_attribute_value(value) {
	// keep booleans, null, and undefined for the sake of `spread`
	const should_escape = typeof value === 'string' || (value && typeof value === 'object');
	return should_escape ? ssr_escape(value, true) : value;
}

/** @returns {{}} */
function escape_object(obj) {
	const result = {};
	for (const key in obj) {
		result[key] = escape_attribute_value(obj[key]);
	}
	return result;
}

/** @returns {string} */
function each(items, fn) {
	items = ensure_array_like(items);
	let str = '';
	for (let i = 0; i < items.length; i += 1) {
		str += fn(items[i], i);
	}
	return str;
}

const missing_component = {
	$$render: () => ''
};

function validate_component(component, name) {
	if (!component || !component.$$render) {
		if (name === 'svelte:component') name += ' this={...}';
		throw new Error(
			`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`
		);
	}
	return component;
}

/** @returns {string} */
function debug(file, line, column, values) {
	console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
	console.log(values); // eslint-disable-line no-console
	return '';
}

let on_destroy;

/** @returns {{ render: (props?: {}, { $$slots, context }?: { $$slots?: {}; context?: Map<any, any>; }) => { html: any; css: { code: string; map: any; }; head: string; }; $$render: (result: any, props: any, bindings: any, slots: any, context: any) => any; }} */
function create_ssr_component(fn) {
	function $$render(result, props, bindings, slots, context) {
		const parent_component = current_component;
		const $$ = {
			on_destroy,
			context: new Map(context || (parent_component ? parent_component.$$.context : [])),
			// these will be immediately discarded
			on_mount: [],
			before_update: [],
			after_update: [],
			callbacks: blank_object()
		};
		set_current_component({ $$ });
		const html = fn(result, props, bindings, slots);
		set_current_component(parent_component);
		return html;
	}
	return {
		render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
			on_destroy = [];
			const result = { title: '', head: '', css: new Set() };
			const html = $$render(result, props, {}, $$slots, context);
			run_all(on_destroy);
			return {
				html,
				css: {
					code: Array.from(result.css)
						.map((css) => css.code)
						.join('\n'),
					map: null // TODO
				},
				head: result.title + result.head
			};
		},
		$$render
	};
}

/** @returns {string} */
function add_attribute(name, value, boolean) {
	if (value == null || (boolean && !value)) return '';
	const assignment = boolean && value === true ? '' : `="${ssr_escape(value, true)}"`;
	return ` ${name}${assignment}`;
}

/** @returns {string} */
function add_classes(classes) {
	return classes ? ` class="${classes}"` : '';
}

/** @returns {string} */
function style_object_to_string(style_object) {
	return Object.keys(style_object)
		.filter((key) => style_object[key])
		.map((key) => `${key}: ${escape_attribute_value(style_object[key])};`)
		.join(' ');
}

/** @returns {string} */
function add_styles(style_object) {
	const styles = style_object_to_string(style_object);
	return styles ? ` style="${styles}"` : '';
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/Component.js






/** @returns {void} */
function bind(component, name, callback) {
	const index = component.$$.props[name];
	if (index !== undefined) {
		component.$$.bound[index] = callback;
		callback(component.$$.ctx[index]);
	}
}

/** @returns {void} */
function create_component(block) {
	block && block.c();
}

/** @returns {void} */
function claim_component(block, parent_nodes) {
	block && block.l(parent_nodes);
}

/** @returns {void} */
function mount_component(component, target, anchor) {
	const { fragment, after_update } = component.$$;
	fragment && fragment.m(target, anchor);
	// onMount happens before the initial afterUpdate
	scheduler_add_render_callback(() => {
		const new_on_destroy = component.$$.on_mount.map(run).filter(utils_is_function);
		// if the component was destroyed immediately
		// it will update the `$$.on_destroy` reference to `null`.
		// the destructured on_destroy may still reference to the old array
		if (component.$$.on_destroy) {
			component.$$.on_destroy.push(...new_on_destroy);
		} else {
			// Edge case - component was destroyed immediately,
			// most likely as a result of a binding initialising
			utils_run_all(new_on_destroy);
		}
		component.$$.on_mount = [];
	});
	after_update.forEach(scheduler_add_render_callback);
}

/** @returns {void} */
function destroy_component(component, detaching) {
	const $$ = component.$$;
	if ($$.fragment !== null) {
		flush_render_callbacks($$.after_update);
		utils_run_all($$.on_destroy);
		$$.fragment && $$.fragment.d(detaching);
		// TODO null out other refs, including component.$$ (but need to
		// preserve final state?)
		$$.on_destroy = $$.fragment = null;
		$$.ctx = [];
	}
}

/** @returns {void} */
function make_dirty(component, i) {
	if (component.$$.dirty[0] === -1) {
		dirty_components.push(component);
		schedule_update();
		component.$$.dirty.fill(0);
	}
	component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}

/** @returns {void} */
function init(
	component,
	options,
	instance,
	create_fragment,
	not_equal,
	props,
	append_styles,
	dirty = [-1]
) {
	const parent_component = lifecycle_current_component;
	lifecycle_set_current_component(component);
	/** @type {import('./private.js').T$$} */
	const $$ = (component.$$ = {
		fragment: null,
		ctx: [],
		// state
		props,
		update: utils_noop,
		not_equal,
		bound: utils_blank_object(),
		// lifecycle
		on_mount: [],
		on_destroy: [],
		on_disconnect: [],
		before_update: [],
		after_update: [],
		context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
		// everything else
		callbacks: utils_blank_object(),
		dirty,
		skip_bound: false,
		root: options.target || parent_component.$$.root
	});
	append_styles && append_styles($$.root);
	let ready = false;
	$$.ctx = instance
		? instance(component, options.props || {}, (i, ret, ...rest) => {
				const value = rest.length ? rest[0] : ret;
				if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
					if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
					if (ready) make_dirty(component, i);
				}
				return ret;
		  })
		: [];
	$$.update();
	ready = true;
	utils_run_all($$.before_update);
	// `false` as a special case of no DOM component
	$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	if (options.target) {
		if (options.hydrate) {
			start_hydrating();
			const nodes = children(options.target);
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			$$.fragment && $$.fragment.l(nodes);
			nodes.forEach(dom_detach);
		} else {
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			$$.fragment && $$.fragment.c();
		}
		if (options.intro) transitions_transition_in(component.$$.fragment);
		mount_component(component, options.target, options.anchor);
		end_hydrating();
		flush();
	}
	lifecycle_set_current_component(parent_component);
}

let SvelteElement;

if (typeof HTMLElement === 'function') {
	SvelteElement = class extends HTMLElement {
		$$componentCtor;
		$$slots;
		$$component;
		$$connected = false;
		$$data = {};
		$$reflecting = false;
		/** @type {Record<string, CustomElementPropDefinition>} */
		$$props_definition = {};
		/** @type {Record<string, Function[]>} */
		$$listeners = {};
		/** @type {Map<Function, Function>} */
		$$listener_unsubscribe_fns = new Map();

		constructor($$componentCtor, $$slots, use_shadow_dom) {
			super();
			this.$$componentCtor = $$componentCtor;
			this.$$slots = $$slots;
			if (use_shadow_dom) {
				this.attachShadow({ mode: 'open' });
			}
		}

		addEventListener(type, listener, options) {
			// We can't determine upfront if the event is a custom event or not, so we have to
			// listen to both. If someone uses a custom event with the same name as a regular
			// browser event, this fires twice - we can't avoid that.
			this.$$listeners[type] = this.$$listeners[type] || [];
			this.$$listeners[type].push(listener);
			if (this.$$component) {
				const unsub = this.$$component.$on(type, listener);
				this.$$listener_unsubscribe_fns.set(listener, unsub);
			}
			super.addEventListener(type, listener, options);
		}

		removeEventListener(type, listener, options) {
			super.removeEventListener(type, listener, options);
			if (this.$$component) {
				const unsub = this.$$listener_unsubscribe_fns.get(listener);
				if (unsub) {
					unsub();
					this.$$listener_unsubscribe_fns.delete(listener);
				}
			}
		}

		async connectedCallback() {
			this.$$connected = true;
			if (!this.$$component) {
				// We wait one tick to let possible child slot elements be created/mounted
				await Promise.resolve();
				if (!this.$$connected) {
					return;
				}
				function create_slot(name) {
					return () => {
						let node;
						const obj = {
							c: function create() {
								node = document.createElement('slot');
								if (name !== 'default') {
									node.setAttribute('name', name);
								}
							},
							/**
							 * @param {HTMLElement} target
							 * @param {HTMLElement} [anchor]
							 */
							m: function mount(target, anchor) {
								insert(target, node, anchor);
							},
							d: function destroy(detaching) {
								if (detaching) {
									dom_detach(node);
								}
							}
						};
						return obj;
					};
				}
				const $$slots = {};
				const existing_slots = get_custom_elements_slots(this);
				for (const name of this.$$slots) {
					if (name in existing_slots) {
						$$slots[name] = [create_slot(name)];
					}
				}
				for (const attribute of this.attributes) {
					// this.$$data takes precedence over this.attributes
					const name = this.$$get_prop_name(attribute.name);
					if (!(name in this.$$data)) {
						this.$$data[name] = get_custom_element_value(
							name,
							attribute.value,
							this.$$props_definition,
							'toProp'
						);
					}
				}
				this.$$component = new this.$$componentCtor({
					target: this.shadowRoot || this,
					props: {
						...this.$$data,
						$$slots,
						$$scope: {
							ctx: []
						}
					}
				});
				for (const type in this.$$listeners) {
					for (const listener of this.$$listeners[type]) {
						const unsub = this.$$component.$on(type, listener);
						this.$$listener_unsubscribe_fns.set(listener, unsub);
					}
				}
				this.$$listeners = {};
			}
		}

		// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
		// and setting attributes through setAttribute etc, this is helpful
		attributeChangedCallback(attr, _oldValue, newValue) {
			if (this.$$reflecting) return;
			attr = this.$$get_prop_name(attr);
			this.$$data[attr] = get_custom_element_value(
				attr,
				newValue,
				this.$$props_definition,
				'toProp'
			);
			this.$$component?.$set({ [attr]: this.$$data[attr] });
		}

		disconnectedCallback() {
			this.$$connected = false;
			// In a microtask, because this could be a move within the DOM
			Promise.resolve().then(() => {
				if (!this.$$connected) {
					this.$$component.$destroy();
					this.$$component = undefined;
				}
			});
		}

		$$get_prop_name(attribute_name) {
			return (
				Object.keys(this.$$props_definition).find(
					(key) =>
						this.$$props_definition[key].attribute === attribute_name ||
						(!this.$$props_definition[key].attribute && key.toLowerCase() === attribute_name)
				) || attribute_name
			);
		}
	};
}

/**
 * @param {string} prop
 * @param {any} value
 * @param {Record<string, CustomElementPropDefinition>} props_definition
 * @param {'toAttribute' | 'toProp'} [transform]
 */
function get_custom_element_value(prop, value, props_definition, transform) {
	const type = props_definition[prop]?.type;
	value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;
	if (!transform || !props_definition[prop]) {
		return value;
	} else if (transform === 'toAttribute') {
		switch (type) {
			case 'Object':
			case 'Array':
				return value == null ? null : JSON.stringify(value);
			case 'Boolean':
				return value ? '' : null;
			case 'Number':
				return value == null ? null : value;
			default:
				return value;
		}
	} else {
		switch (type) {
			case 'Object':
			case 'Array':
				return value && JSON.parse(value);
			case 'Boolean':
				return value; // conversion already handled above
			case 'Number':
				return value != null ? +value : value;
			default:
				return value;
		}
	}
}

/**
 * @internal
 *
 * Turn a Svelte component into a custom element.
 * @param {import('./public.js').ComponentType} Component  A Svelte component constructor
 * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe
 * @param {string[]} slots  The slots to create
 * @param {string[]} accessors  Other accessors besides the ones for props the component has
 * @param {boolean} use_shadow_dom  Whether to use shadow DOM
 */
function create_custom_element(
	Component,
	props_definition,
	slots,
	accessors,
	use_shadow_dom
) {
	const Class = class extends SvelteElement {
		constructor() {
			super(Component, slots, use_shadow_dom);
			this.$$props_definition = props_definition;
		}
		static get observedAttributes() {
			return Object.keys(props_definition).map((key) =>
				(props_definition[key].attribute || key).toLowerCase()
			);
		}
	};
	Object.keys(props_definition).forEach((prop) => {
		Object.defineProperty(Class.prototype, prop, {
			get() {
				return this.$$component && prop in this.$$component
					? this.$$component[prop]
					: this.$$data[prop];
			},
			set(value) {
				value = get_custom_element_value(prop, value, props_definition);
				this.$$data[prop] = value;
				this.$$component?.$set({ [prop]: value });
				if (props_definition[prop].reflect) {
					this.$$reflecting = true;
					const attribute_value = get_custom_element_value(
						prop,
						value,
						props_definition,
						'toAttribute'
					);
					if (attribute_value == null) {
						this.removeAttribute(prop);
					} else {
						this.setAttribute(props_definition[prop].attribute || prop, attribute_value);
					}
					this.$$reflecting = false;
				}
			}
		});
	});
	accessors.forEach((accessor) => {
		Object.defineProperty(Class.prototype, accessor, {
			get() {
				return this.$$component?.[accessor];
			}
		});
	});
	Component.element = /** @type {any} */ (Class);
	return Class;
}

/**
 * Base class for Svelte components. Used when dev=false.
 *
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 */
class SvelteComponent {
	/**
	 * ### PRIVATE API
	 *
	 * Do not use, may change at any time
	 *
	 * @type {any}
	 */
	$$ = undefined;
	/**
	 * ### PRIVATE API
	 *
	 * Do not use, may change at any time
	 *
	 * @type {any}
	 */
	$$set = undefined;

	/** @returns {void} */
	$destroy() {
		destroy_component(this, 1);
		this.$destroy = utils_noop;
	}

	/**
	 * @template {Extract<keyof Events, string>} K
	 * @param {K} type
	 * @param {((e: Events[K]) => void) | null | undefined} callback
	 * @returns {() => void}
	 */
	$on(type, callback) {
		if (!utils_is_function(callback)) {
			return utils_noop;
		}
		const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
		callbacks.push(callback);
		return () => {
			const index = callbacks.indexOf(callback);
			if (index !== -1) callbacks.splice(index, 1);
		};
	}

	/**
	 * @param {Partial<Props>} props
	 * @returns {void}
	 */
	$set(props) {
		if (this.$$set && !is_empty(props)) {
			this.$$.skip_bound = true;
			this.$$set(props);
			this.$$.skip_bound = false;
		}
	}
}

/**
 * @typedef {Object} CustomElementPropDefinition
 * @property {string} [attribute]
 * @property {boolean} [reflect]
 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
 */

;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/version.js
// generated during release, do not modify

/**
 * The current version, as set in package.json.
 *
 * https://svelte.dev/docs/svelte-compiler#svelte-version
 * @type {string}
 */
const VERSION = '4.0.1';
const PUBLIC_VERSION = '4';

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dev.js







/**
 * @template T
 * @param {string} type
 * @param {T} [detail]
 * @returns {void}
 */
function dispatch_dev(type, detail) {
	document.dispatchEvent(dom_custom_event(type, { version: VERSION, ...detail }, { bubbles: true }));
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append_dev(target, node) {
	dispatch_dev('SvelteDOMInsert', { target, node });
	append(target, node);
}

/**
 * @param {Node} target
 * @param {Node} node
 * @returns {void}
 */
function append_hydration_dev(target, node) {
	dispatch_dev('SvelteDOMInsert', { target, node });
	append_hydration(target, node);
}

/**
 * @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert_dev(target, node, anchor) {
	dispatch_dev('SvelteDOMInsert', { target, node, anchor });
	insert(target, node, anchor);
}

/** @param {Node} target
 * @param {Node} node
 * @param {Node} [anchor]
 * @returns {void}
 */
function insert_hydration_dev(target, node, anchor) {
	dispatch_dev('SvelteDOMInsert', { target, node, anchor });
	insert_hydration(target, node, anchor);
}

/**
 * @param {Node} node
 * @returns {void}
 */
function detach_dev(node) {
	dispatch_dev('SvelteDOMRemove', { node });
	dom_detach(node);
}

/**
 * @param {Node} before
 * @param {Node} after
 * @returns {void}
 */
function detach_between_dev(before, after) {
	while (before.nextSibling && before.nextSibling !== after) {
		detach_dev(before.nextSibling);
	}
}

/**
 * @param {Node} after
 * @returns {void}
 */
function detach_before_dev(after) {
	while (after.previousSibling) {
		detach_dev(after.previousSibling);
	}
}

/**
 * @param {Node} before
 * @returns {void}
 */
function detach_after_dev(before) {
	while (before.nextSibling) {
		detach_dev(before.nextSibling);
	}
}

/**
 * @param {Node} node
 * @param {string} event
 * @param {EventListenerOrEventListenerObject} handler
 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
 * @param {boolean} [has_prevent_default]
 * @param {boolean} [has_stop_propagation]
 * @param {boolean} [has_stop_immediate_propagation]
 * @returns {() => void}
 */
function listen_dev(
	node,
	event,
	handler,
	options,
	has_prevent_default,
	has_stop_propagation,
	has_stop_immediate_propagation
) {
	const modifiers =
		options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
	if (has_prevent_default) modifiers.push('preventDefault');
	if (has_stop_propagation) modifiers.push('stopPropagation');
	if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
	dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
	const dispose = listen(node, event, handler, options);
	return () => {
		dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
		dispose();
	};
}

/**
 * @param {Element} node
 * @param {string} attribute
 * @param {string} [value]
 * @returns {void}
 */
function attr_dev(node, attribute, value) {
	attr(node, attribute, value);
	if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
	else dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
}

/**
 * @param {Element} node
 * @param {string} property
 * @param {any} [value]
 * @returns {void}
 */
function prop_dev(node, property, value) {
	node[property] = value;
	dispatch_dev('SvelteDOMSetProperty', { node, property, value });
}

/**
 * @param {HTMLElement} node
 * @param {string} property
 * @param {any} [value]
 * @returns {void}
 */
function dataset_dev(node, property, value) {
	node.dataset[property] = value;
	dispatch_dev('SvelteDOMSetDataset', { node, property, value });
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data_dev(text, data) {
	data = '' + data;
	if (text.data === data) return;
	dispatch_dev('SvelteDOMSetData', { node: text, data });
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @returns {void}
 */
function set_data_contenteditable_dev(text, data) {
	data = '' + data;
	if (text.wholeText === data) return;
	dispatch_dev('SvelteDOMSetData', { node: text, data });
	text.data = /** @type {string} */ (data);
}

/**
 * @param {Text} text
 * @param {unknown} data
 * @param {string} attr_value
 * @returns {void}
 */
function set_data_maybe_contenteditable_dev(text, data, attr_value) {
	if (~contenteditable_truthy_values.indexOf(attr_value)) {
		set_data_contenteditable_dev(text, data);
	} else {
		set_data_dev(text, data);
	}
}

function ensure_array_like_dev(arg) {
	if (
		typeof arg !== 'string' &&
		!(arg && typeof arg === 'object' && 'length' in arg) &&
		!(typeof Symbol === 'function' && arg && Symbol.iterator in arg)
	) {
		throw new Error('{#each} only works with iterable values.');
	}
	return each_ensure_array_like(arg);
}

/**
 * @returns {void} */
function validate_slots(name, slot, keys) {
	for (const slot_key of Object.keys(slot)) {
		if (!~keys.indexOf(slot_key)) {
			console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
		}
	}
}

/**
 * @param {unknown} tag
 * @returns {void}
 */
function validate_dynamic_element(tag) {
	const is_string = typeof tag === 'string';
	if (tag && !is_string) {
		throw new Error('<svelte:element> expects "this" attribute to be a string.');
	}
}

/**
 * @param {undefined | string} tag
 * @returns {void}
 */
function validate_void_dynamic_element(tag) {
	if (tag && is_void(tag)) {
		console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
	}
}

function construct_svelte_component_dev(component, props) {
	const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
	try {
		const instance = new component(props);
		if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
			throw new Error(error_message);
		}
		return instance;
	} catch (err) {
		const { message } = err;
		if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
			throw new Error(error_message);
		} else {
			throw err;
		}
	}
}

/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 *
 * Can be used to create strongly typed Svelte components.
 *
 * #### Example:
 *
 * You have component library on npm called `component-library`, from which
 * you export a component called `MyComponent`. For Svelte+TypeScript users,
 * you want to provide typings. Therefore you create a `index.d.ts`:
 * ```ts
 * import { SvelteComponent } from "svelte";
 * export class MyComponent extends SvelteComponent<{foo: string}> {}
 * ```
 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
 * to provide intellisense and to use the component like this in a Svelte file
 * with TypeScript:
 * ```svelte
 * <script lang="ts">
 * 	import { MyComponent } from "component-library";
 * </script>
 * <MyComponent foo={'bar'} />
 * ```
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 * @template {Record<string, any>} [Slots=any]
 * @extends {SvelteComponent<Props, Events>}
 */
class SvelteComponentDev extends SvelteComponent {
	/**
	 * For type checking capabilities only.
	 * Does not exist at runtime.
	 * ### DO NOT USE!
	 *
	 * @type {Props}
	 */
	$$prop_def;
	/**
	 * For type checking capabilities only.
	 * Does not exist at runtime.
	 * ### DO NOT USE!
	 *
	 * @type {Events}
	 */
	$$events_def;
	/**
	 * For type checking capabilities only.
	 * Does not exist at runtime.
	 * ### DO NOT USE!
	 *
	 * @type {Slots}
	 */
	$$slot_def;

	/** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
	constructor(options) {
		if (!options || (!options.target && !options.$$inline)) {
			throw new Error("'target' is a required option");
		}
		super();
	}

	/** @returns {void} */
	$destroy() {
		super.$destroy();
		this.$destroy = () => {
			console.warn('Component was already destroyed'); // eslint-disable-line no-console
		};
	}

	/** @returns {void} */
	$capture_state() {}

	/** @returns {void} */
	$inject_state() {}
}
/**
 * @template {Record<string, any>} [Props=any]
 * @template {Record<string, any>} [Events=any]
 * @template {Record<string, any>} [Slots=any]
 * @deprecated Use `SvelteComponent` instead. See PR for more information: https://github.com/sveltejs/svelte/pull/8512
 * @extends {SvelteComponentDev<Props, Events, Slots>}
 */
class SvelteComponentTyped extends (/* unused pure expression or super */ null && (SvelteComponentDev)) {}

/** @returns {() => void} */
function loop_guard(timeout) {
	const start = Date.now();
	return () => {
		if (Date.now() - start > timeout) {
			throw new Error('Infinite loop detected');
		}
	};
}

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/index.js
















;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/disclose-version/index.js


if (typeof window !== 'undefined')
	// @ts-ignore
	(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

;// CONCATENATED MODULE: ./node_modules/waveform-path/dist/waveform-path.min.js
const getAudioData=e=>{window.AudioContext=window.AudioContext||window.webkitAudioContext;const a=new AudioContext;return fetch(e).then(e=>e.arrayBuffer()).then(e=>a.decodeAudioData(e)).catch(e=>{console.error(e)})},linearPath=(e,a)=>{const{channel:t=0,samples:v=e.length,height:h=100,width:r=800,top:s=0,left:l=0,type:i="steps",paths:$=[{d:"Q",sx:0,sy:0,x:50,y:100,ex:100,ey:0}],animation:o=!1,animationframes:n=10,normalize:b=!0}=a;var a=getFramesData(e,t,o,n),e=getFilterData(a,v),w=b?getNormalizeData(e):e;let c="";var p,f,g="bars"!=i?(h+2*s)/2:h+s,m=r/v,y=$.length,u="mirror"==i?2*y:y,A=w.length;for(let n=0;n<A;n++){0<n&&(p=c.length,f=c.charAt(p-1),c+=";"==f||0===p?" M 0 0 ;":";");let s=-9999,o=-9999;for(let r=0;r<v;r++){var M="bars"==i||r%2?1:-1;let t=1;for(let e=0;e<u;e++){let a=e;e>=y&&(a=e-y,t=-1),$[a].minshow=$[a].minshow??0,$[a].maxshow=$[a].maxshow??1,$[a].normalize=$[a].normalize??!1;var d=$[a].normalize?1:w[n][r];if($[a].minshow<=w[n][r]&&$[a].maxshow>=w[n][r])switch($[a].d){case"L":var D=r*m+m*$[a].sx/100+l,x=g+d*$[a].sy/100*("bars"!=i?h/2:h)*-M*t,k=r*m+m*$[a].ex/100+l,z=g+d*$[a].ey/100*("bars"!=i?h/2:h)*-M*t;D===s&&x===o||(c+=`M ${D} ${x} `),c+=`L ${k} ${z} `,s=k,o=z;break;case"H":D=r*m+m*$[a].sx/100+l,x=g+d*$[a].y/100*("bars"!=i?h/2:h)*-M*t,k=r*m+m*$[a].ex/100+l;D===s&&x===o||(c+=`M ${D} ${x} `),c+=`H ${k} `,s=k,o=x;break;case"V":var z=r*m+m*$[a].x/100+l,C=g+d*$[a].sy/100*("bars"!=i?h/2:h)*-M*t,F=g+d*$[a].ey/100*("bars"!=i?h/2:h)*-M*t;z===s&&C===o||(c+=`M ${z} ${C} `),c+=`V ${F} `,s=z,o=F;break;case"C":var C=r*m+m*$[a].sx/100+l,F=g-g*$[a].sy/100*M,Q=r*m+m*$[a].x/100+l,P=g+d*$[a].y/100*("bars"!=i?h:2*h)*-M*t,L=r*m+m*$[a].ex/100+l,Z=g-g*$[a].ey/100*M;C===s&&F===o||(c+=`M ${C} ${F} `),c+=`C ${C} ${F} ${Q} ${P} ${L} ${Z} `,s=L,o=Z;break;case"Q":var Q=r*m+m*$[a].sx/100+l,P=g+d*$[a].sy/100*("bars"!=i?h/2:h)*-M*t,L=r*m+m*$[a].x/100+l,Z=g+d*$[a].y/100*("bars"!=i?h:2*h)*-M*t,N=r*m+m*$[a].ex/100+l,H=g+d*$[a].ey/100*("bars"!=i?h/2:h)*-M*t;Q===s&&P===o||(c+=`M ${Q} ${P} `),c+=`Q ${L} ${Z} ${N} ${H} `,s=N,o=H;break;case"A":{var N=r*m+m*$[a].sx/100+l,H=g+d*$[a].sy/100*("bars"!=i?h/2:h)*-M*t,V=r*m+m*$[a].ex/100+l,B=g+d*$[a].ey/100*("bars"!=i?h/2:h)*-M*t,I=(N===s&&H===o||(c+=`M ${N} ${H} `),$[a].rx*m/100),R=$[a].ry*m/100;let e=$[a].sweep;-1==M&&(e=1==e?0:1),-1==t&&(e=1==e?0:1),c+=`A ${I} ${R} ${$[a].angle} ${$[a].arc} ${e} ${V} ${B} `,s=V,o=B;break}case"Z":c+="Z "}}}}return c},polarPath=(e,a)=>{const{channel:t=0,samples:v=e.length,distance:h=50,length:l=100,top:i=0,left:$=0,type:b="steps",startdeg:r=0,enddeg:s=360,invertdeg:o=!1,invertpath:n=!1,paths:c=[{d:"Q",sdeg:0,sr:0,deg:50,r:100,edeg:100,er:0}],animation:w=!1,animationframes:p=10,normalize:f=!0}=a;var a=getFramesData(e,t,w,p),e=getFilterData(a,v),y=f?getNormalizeData(e):e;let g="";var u,A,a=s<r?s+360:s,m=o?(r-a)/v:(a-r)/v,D=o?90+r+180:90+r,M=n?-1:1,k=c.length,z="mirror"==b?2*k:k,C=Math.PI/180,F=y.length;for(let n=0;n<F;n++){0<n&&(u=g.length,A=g.charAt(u-1),g+=";"==A||0===u?" M 0 0 ;":";");let s=-9999,o=-9999;for(let r=0;r<v;r++){var d="bars"==b||r%2?1:-1;let t=1;for(let e=0;e<z;e++){let a=e;e>=k&&(a=e-k,t=-1),c[a].minshow=c[a].minshow??0,c[a].maxshow=c[a].maxshow??1,c[a].normalize=c[a].normalize??!1;var x=c[a].normalize?1:y[n][r];if(c[a].minshow<=y[n][r]&&c[a].maxshow>=y[n][r])switch(c[a].d){case"L":var Q=(m*(r+c[a].sdeg/100)-D)*C,P=(m*(r+c[a].edeg/100)-D)*C,L=$+(l*(c[a].sr/100)*x*d*t*M+h)*Math.cos(Q),Q=i+(l*(c[a].sr/100)*x*d*t*M+h)*Math.sin(Q),Z=$+(l*(c[a].er/100)*x*d*t*M+h)*Math.cos(P),P=i+(l*(c[a].er/100)*x*d*t*M+h)*Math.sin(P);L===s&&Q===o||(g+=`M ${L} ${Q} `),g+=`L ${Z} ${P} `,s=Z,o=P;break;case"C":var L=(m*(r+c[a].sdeg/100)-D)*C,Q=(m*(r+c[a].deg/100)-D)*C,Z=(m*(r+c[a].edeg/100)-D)*C,P=$+(l*(c[a].sr/100)*x*d*t*M+h)*Math.cos(L),N=i+(l*(c[a].sr/100)*x*d*t*M+h)*Math.sin(L),H=$+(l*(c[a].r/100)*x*d*t*M+h)*Math.cos(Q),V=i+(l*(c[a].r/100)*x*d*t*M+h)*Math.sin(Q),B=$+(l*(c[a].er/100)*x*d*t*M+h)*Math.cos(Z),I=i+(l*(c[a].er/100)*x*d*t*M+h)*Math.sin(Z);P===s&&N===o||(g+=`M ${P} ${N} `),g+=`C ${P} ${N} ${H} ${V} ${B} ${I} `,s=B,o=I;break;case"Q":var N=(m*(r+c[a].sdeg/100)-D)*C,H=(m*(r+c[a].deg/100)-D)*C,V=(m*(r+c[a].edeg/100)-D)*C,B=$+(l*(c[a].sr/100)*x*d*t*M+h)*Math.cos(N),I=i+(l*(c[a].sr/100)*x*d*t*M+h)*Math.sin(N),R=$+(l*(c[a].r/100)*x*d*t*M+h)*Math.cos(H),j=i+(l*(c[a].r/100)*x*d*t*M+h)*Math.sin(H),q=$+(l*(c[a].er/100)*x*d*t*M+h)*Math.cos(V),E=i+(l*(c[a].er/100)*x*d*t*M+h)*Math.sin(V);B===s&&I===o||(g+=`M ${B} ${I} `),g+=`Q ${R} ${j} ${q} ${E} `,s=q,o=E;break;case"A":{var R=(m*(r+c[a].sdeg/100)-D)*C,j=(m*(r+c[a].edeg/100)-D)*C,q=$+(l*(c[a].sr/100)*x*d*t*M+h)*Math.cos(R),E=i+(l*(c[a].sr/100)*x*d*t*M+h)*Math.sin(R),G=$+(l*(c[a].er/100)*x*d*t*M+h)*Math.cos(j),J=i+(l*(c[a].er/100)*x*d*t*M+h)*Math.sin(j),K=(q===s&&E===o||(g+=`M ${q} ${E} `),m*r*c[a].angle/100),O=c[a].rx*m/100,S=c[a].ry*m/100;let e=c[a].sweep;-1==d&&(e=1==e?0:1),-1==t&&(e=1==e?0:1),g+=`A ${O} ${S} ${K} ${c[a].arc} ${e} ${G} ${J} `,s=G,o=J;break}case"Z":g+="Z "}}}}return g},getFramesData=(e,a,t,r)=>{const s=e.getChannelData(a),o=[];if(t){var n=e.sampleRate/r;for(let e=0;e<s.length;e+=n){var h=s.slice(e,e+n);o.push(h)}}else o.push(s);return o},getFilterData=(r,a)=>{const e=[];var s=r.length;for(let t=0;t<s;t++){var o=Math.floor(r[t].length/a);const h=[];for(let e=0;e<a;e++){var n=o*e;let a=0;for(let e=0;e<o;e++)a+=Math.abs(r[t][n+e]);h.push(a/o)}e.push(h)}return e},getNormalizeData=a=>{const t=[];var r=a.length;for(let e=0;e<r;e++){var s=Math.max(...a[e]);t.push(s)}const o=Math.pow(Math.max(...t),-1),n=[];for(let e=0;e<r;e++){var h=a[e].map(e=>e*o);n.push(h)}return n};
;// CONCATENATED MODULE: ./src/wave-audio-path-player/dist/wave-audio-path-player.es.js



class AudioPathPlayer extends HTMLElement {
   
    constructor() {
        super();
        this.shadowDOM = this.attachShadow({mode: 'open' });
        this.audioData = null;
        // this.attributes['wave-options'] = `{"samples":40,"type":"steps","width":192,"height":40}`
        if(this.hasAttribute("wave-options")) {
            this.options = JSON.parse(this.attributes['wave-options'].value);
            this.options.width = parseInt(this.attributes['wave-width'].value);
            this.options.height = parseInt(this.attributes['wave-height'].value);
        } else {
            this.options =   { 
                samples: 4,  
                // type: 'mirror', 
                animation: true,
                // type: 'steps', 
                // width: parseInt(this.attributes['wave-width'].value), 
                // height: parseInt(this.attributes['wave-height'].value),
                width: 200, 
                height: 80,
                // paths: [
                //     {d:'V', sy: 0, x:50, ey:100 }
                // ], 
            }
        }
        if(this.options.hasOwnProperty("animation")) {
           this.animation = this.options.animation;
        } else {
            this.animation = false;
        }
        this.playPath = "M8.5 8.7c0-1.7 1.2-2.4 2.6-1.5l14.4 8.3c1.4.8 1.4 2.2 0 3l-14.4 8.3c-1.4.8-2.6.2-2.6-1.5V8.7z";
        this.pausePath = "M9.2 25c0 .5.4 1 .9 1h3.6c.5 0 .9-.4.9-1V9c0-.5-.4-.9-.9-.9h-3.6c-.4-.1-.9.3-.9.9v16zm11-17c-.5 0-1 .4-1 .9V25c0 .5.4 1 1 1h3.6c.5 0 1-.4 1-1V9c0-.5-.4-.9-1-.9 0-.1-3.6-.1-3.6-.1z";
        this.playPathButton = null;
        this.svg = null;
        this.path1 = null;
        this.path2 = null;
        this.animationsvg = null;
        this.animationsvgx = null;
        this.audio = null;
        this.durationContainer = null;
        this.seekSlider = null;
        this.currentTimeContainer = null;
        this.playIconContainer = null;
        this.raf = null;
        this.initialized = false
    }

    initComponent() {
        this.playPathButton = this.shadowDOM.getElementById('playPathButton');
        this.player = this.shadowDOM.querySelector('.player');
        this.svg = this.shadowDOM.getElementById('svg');
        this.path1 = this.shadowDOM.getElementById('path1');
        this.path2 = this.shadowDOM.getElementById('path2');
        this.animationsvg = this.shadowDOM.getElementById('animationsvg');
        this.animationsvgx = this.shadowDOM.getElementById('animationsvgx');
        this.audio =  this.shadowDOM.querySelector('audio');
        this.durationContainer = this.shadowDOM.getElementById('duration');
        this.seekSlider = this.shadowDOM.getElementById('seek-slider');
        this.currentTimeContainer = this.shadowDOM.getElementById('current-time');
        this.playIconContainer = this.shadowDOM.getElementById('play');
      
        
        this.svg.pauseAnimations();
        if (this.audio.readyState > 0) {
            this.loadSong();
        } else {
            this.audio.addEventListener('loadedmetadata', this.loadSong);
        }

        const lineElement = this.shadowDOM.querySelector("line")
        this.player.addEventListener('click', ()=>{
          if(!this.initialized){
            // this.initComponent();
            // this.render(false);
            this.audioPath().then(()=>{
              lineElement.style.display = "none"
            })
          }
          this.initialized = true
        });
        this.playIconContainer.addEventListener('click', this.playPause);
        this.audio.addEventListener('ended', this.onFinish);
        this.seekSlider.addEventListener('input', this.sliderInput);
        this.seekSlider.addEventListener('change', this.sliderChange);
        this.playIconContainer.addEventListener('click', this.playPause);
    }

    loadSong = () => {
        this.durationContainer.textContent = this.calculateTime(this.audio.duration);
        this.seekSlider.max = this.audio.duration;
        this.svg.unpauseAnimations();
        this.animationsvg.setAttribute("dur", ""+this.audio.duration +"s");
        if(!this.animation) {
            this.animationsvgx.setAttribute("dur", ""+this.audio.duration +"s");
        }
        this.svg.pauseAnimations();
        this.svg.setCurrentTime(0);
    }
    
    playPause = () => {
        if(this.audio.paused) {
            this.audio.play();
            this.svg.unpauseAnimations();
            this.path2.style.display = "block";
            this.playPathButton.setAttribute("d", this.pausePath);
            this.raf = requestAnimationFrame(this.whilePlaying);
        } else {
            this.audio.pause();
            this.svg.pauseAnimations();
            this.playPathButton.setAttribute("d", this.playPath);
            cancelAnimationFrame(this.raf);
        }
    }

    sliderInput = () => { 
        this.path2.style.display = "block";
        this.currentTimeContainer.textContent = this.calculateTime(this.seekSlider.value);
        this.svg.setCurrentTime(this.seekSlider.value);
        if(!this.audio.paused) {
            cancelAnimationFrame(this.raf);
        }
    }

    sliderChange = () => {
        this.audio.currentTime = this.seekSlider.value;
        this.path2.style.display = "block";
        this.svg.setCurrentTime(this.seekSlider.value);
        
        if(!this.audio.paused) {
            this.raf = requestAnimationFrame(this.whilePlaying);
        }
    }

    onFinish = () => {
        this.seekSlider.value = this.seekSlider.max;
        this.svg.setCurrentTime(this.audio.duration);
        this.svg.pauseAnimations();
        this.playPathButton.setAttribute("d", this.playPath);
        cancelAnimationFrame(this.raf);
    }

    whilePlaying = () => {
        
        this.seekSlider.value = this.audio.currentTime;
        this.currentTimeContainer.textContent = this.calculateTime(this.seekSlider.value);
        this.svg.setCurrentTime(this.seekSlider.value);
        this.raf = requestAnimationFrame(this.whilePlaying);
    }
    
    
    calculateTime = (secs) => {
        const minutes = Math.floor(secs / 60);
        const seconds = Math.floor(secs % 60);
        const returnedSeconds = seconds < 10 ? `0${seconds}` : `${seconds}`;
        return `${minutes}:${returnedSeconds}`;
    }

    mapComponentAttributes() {
        const attributesMapping = [
            'src', 'wave-height', 'wave-width', 'color', 'wave-options', 'wave-color', 'wave-progress-color', 'wave-slider'
        ];
        attributesMapping.forEach(key => {
            if (!this.attributes[key]) {
                this.attributes[key] = {value: null};
            }
        });
    }


    async audioPath() {
        // this.audioData = await getAudioData(this.attributes.src.value);
        getAudioData(this.attributes.src.value).then((data)=>{
          this.audioData = data
          this.svgDraw();
        })
    }
    svgDraw = () => {
        const path = linearPath(this.audioData, this.options);
        console.log(path)
        if(!this.animation) {
            this.path1.setAttribute('d', path);
            this.path2.setAttribute('d', path);
        } else {
            this.animationsvg.setAttribute('values', path)
        }
        this.svg.setCurrentTime(this.seekSlider.value);
    }

    connectedCallback() {
        this.mapComponentAttributes();
        this.render(true);
        this.initComponent();
        // this.audioPath();
    }

    render(init = false) {
        this.shadowDOM.innerHTML = `
            ${this.templateCss()}
            ${this.template(init)}
        `;
    }

    template(init) {
        let html = `
        <div part="player" class="player">
            <button id="play" part="play">
                <svg viewBox="0 0 34 34" width="34" height="34" part="button">
                    <path id="playPathButton" d="M8.5 8.7c0-1.7 1.2-2.4 2.6-1.5l14.4 8.3c1.4.8 1.4 2.2 0 3l-14.4 8.3c-1.4.8-2.6.2-2.6-1.5V8.7z"></path>
                    <!--<path fill="currentColor" d="M9.2 25c0 .5.4 1 .9 1h3.6c.5 0 .9-.4.9-1V9c0-.5-.4-.9-.9-.9h-3.6c-.4-.1-.9.3-.9.9v16zm11-17c-.5 0-1 .4-1 .9V25c0 .5.4 1 1 1h3.6c.5 0 1-.4 1-1V9c0-.5-.4-.9-1-.9 0-.1-3.6-.1-3.6-.1z"></path>-->
                </svg>
            </button>
        <div id="current-time" part="currenttime">0:00</div>
        <div id="slider" part="slider">
            <svg id="svg" part="svg" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 ${this.attributes['wave-width'].value} ${this.attributes['wave-height'].value}" width="${this.attributes['wave-width'].value}" height="${this.attributes['wave-height'].value}">
        `;
      
        if(!this.animation) {
            html += `
            <defs>
                <clipPath id="left-to-right-x">
                <rect x="-1" y="-100" width="${parseInt(this.attributes['wave-width'].value)+2}" height="${parseInt(this.attributes['wave-height'].value)+200}" >
                    <animate id="animationsvgx" attributeName="x" values="-1;${parseInt(this.attributes['wave-width'].value)+2}" dur="99999s" fill="freeze" />   
                </rect>
                </clipPath>
                <clipPath id="left-to-right">
                <rect x="-${parseInt(this.attributes['wave-width'].value)+2}" y="-100" width="${parseInt(this.attributes['wave-width'].value)+2}" height="${parseInt(this.attributes['wave-height'].value)+200}" >
                    <animate id="animationsvg" attributeName="x" values="-${parseInt(this.attributes['wave-width'].value)+2};-1" dur="99999s" fill="freeze" />   
                </rect>
                </clipPath>    
            </defs> 
            <line x1="0" y1="40" x2="200" y2="40" stroke="black" stroke-width="2.5"></line>
            <path id="path1" part="path1"  stroke-width="2" d="" clip-path="url(#left-to-right-x)"></path>
            <path id="path2" part="path2"  stroke-width="2" d="" clip-path="url(#left-to-right)" style="display:none;"></path>`;
        } else {
            html += `
            <line x1="0" y1="40" x2="200" y2="40" stroke="black" stroke-width="2.5"></line>
            <path id="path1" part="path1"  stroke-width="2" style="display:none;"></path>
            <path id="path2" part="path2"  stroke-width="2" style="display:block;">
                <animate id="animationsvg" attributeName="d" dur="99999s" calcMode="linear" values="" fill="freeze"></animate>
            </path>
            `;
        }
        
        html +=`
        </svg>
                <input type="range" part="input" id="seek-slider" max="100" value="0" step="any">
            </div>
            <div id="duration" part="duration">0:00</div>
        </div>
        <audio src="${this.attributes.src.value}"></audio>
        `;
        return html;
    }
 
    templateCss() {
        return `
            <style>
            *, :after, :before { 
                box-sizing: border-box;
                margin: 0;
            }
            :host {
                display: flex;
               
            }
            .player {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            #play {
                background: transparent;
                border: none;
                cursor:pointer;
                padding: 0 0 0 10px;
                margin: 0px;
                
            }
            #play svg {
                fill: ${this.attributes['color']?.value ?? '#858a8d'};
                position:relative;
                transition: transform 0.3s;
                top: -0.5px;
            }
            #play svg:hover {
                transform: scale(1.);
            }
            #play svg path {
                stroke-linecap: round;
                stroke-linejoin: round;
                transition: 0.2s;
            }
            #svg {
                margin: 0 10px;
                overflow: visible;
                stroke-width: 1px;
                fill: none;
            }
            #path1 {
                stroke: ${this.attributes['wave-color']?.value ?? '#dadcdd'}; 
                overflow: visible;
                stroke-linecap: round;
            }
            #path2 {
                stroke: ${this.attributes['wave-progress-color']?.value ?? '#858a8d'};
                overflow: visible;
                stroke-linecap: round;
            }
            #slider  {
                position:relative;
            }
            #duration, #current-time {
                position: relative;
                top:-1.1px;
                color: ${this.attributes['color']?.value ?? '#858a8d'};
                margin: 0px 10px;
                font-size: 16px;
                font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
                min-width:32px;
            }
            #seek-slider {
                position: absolute;
                width: 100%;
                left: 0;
            }
            input[type=range] {
                // clip: rect(0.01rem, 0.01rem, 0.01rem, 0.01rem);

                -webkit-appearance: none; 
                width: 100%; 
                background: transparent; 
                padding: 0px;
                margin: 0px;
                border: 0px;
                height: ${parseInt(this.attributes['wave-height'].value)}px;
            }  
            input[type=range]::-webkit-slider-thumb {
                -webkit-appearance: none;
            }
            input[type=range]:focus {
                outline: none; 
            }
            
            input[type=range]::-ms-track {
                width: 100%;
                cursor: pointer;
                /* Hides the slider so custom styles can be added */
                background: transparent; 
                border-color: transparent;
                color: transparent;
            }
            input[type=range]::-webkit-slider-thumb {
                -webkit-appearance: none;
                position:relative; 
                /*top: -1.5px;*/
                height: 12.5px;
                width: 12.5px;
                border-radius: 50%;
                background:  ${this.attributes['wave-slider']?.value ?? '#4fc3f7'};
                cursor: pointer;
                box-shadow: none;
            }
            input[type="range"]::-webkit-slider-thumb {
                transition: transform 0.3s;
            }
            input[type="range"]:active::-webkit-slider-thumb {
                transform: scale(1.5);
            }
            input[type="range"]::-moz-range-thumb {
                height: 12.5px;
                width: 12.5px;
                border-radius: 50%;
                background:  ${this.attributes['wave-slider']?.value ?? '#4fc3f7'};
                cursor: pointer;
                box-shadow: none;
                border: 0px;
            }

            input[type="range"]:active::-moz-range-thumb {
                transform: scale(1.5);
            }  
            </style>
        `;
    }
}
window.customElements.define('wave-audio-path-player', AudioPathPlayer);

;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/index.js


;// CONCATENATED MODULE: ./node_modules/@0b5vr/experimental/dist/0b5vr-experimental.esm.js
/*!
* @0b5vr/experimental v0.9.5
* Experimental edition of 0b5vr
*
* Copyright (c) 2019-2023 0b5vr
* @0b5vr/experimental is distributed under MIT License
* https://github.com/0b5vr/experimental-npm/blob/release/LICENSE
*/
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/algorithm/binarySearch.ts
function binarySearch(array, elementOrCompare) {
  if (typeof elementOrCompare !== "function") {
    return binarySearch(array, (element) => element < elementOrCompare);
  }
  const compare = elementOrCompare;
  let start = 0;
  let end = array.length;
  while (start < end) {
    const center = start + end >> 1;
    const centerElement = array[center];
    const compareResult = compare(centerElement);
    if (compareResult) {
      start = center + 1;
    } else {
      end = center;
    }
  }
  return start;
}

// src/algorithm/traverse.ts
function traverse(root, traverser) {
  const nodesNeedProcess = [root];
  const nodesSeen = new Set(nodesNeedProcess);
  while (nodesNeedProcess.length > 0) {
    const currentNode = nodesNeedProcess.shift();
    const children = traverser(currentNode);
    if (!children) {
      break;
    }
    const nodesFound = children.filter((node) => !nodesSeen.has(node));
    nodesNeedProcess.unshift(...nodesFound);
    nodesFound.map((node) => nodesSeen.add(node));
  }
}

// src/array/arrayRange.ts
function arrayRange(start, end, step) {
  let current = start;
  const ret = [];
  if (start < end) {
    step = step != null ? step : 1;
    while (current < end) {
      ret.push(current);
      current += step;
    }
  } else {
    step = step != null ? step : -1;
    while (current > end) {
      ret.push(current);
      current += step;
    }
  }
  return ret;
}

// src/array/arraySerial.ts
var arraySerial = (count) => [...Array(count)].map((_, i) => i);

// src/array/arraySet.ts
function arraySetDelete(array, value) {
  const index = array.indexOf(value);
  if (index === -1) {
    return false;
  }
  array.splice(index, 1);
  return true;
}
function arraySetHas(array, value) {
  return array.indexOf(value) !== -1;
}
function arraySetAdd(array, value) {
  const index = array.indexOf(value);
  if (index !== -1) {
    return false;
  }
  array.push(value);
  return true;
}
function arraySetUnion(a, b) {
  const out = [...a];
  b.forEach((v) => {
    if (!arraySetHas(out, v)) {
      out.push(v);
    }
  });
  return out;
}
function arraySetDiff(from, diff) {
  const out = [...from];
  diff.forEach((v) => {
    arraySetDelete(out, v);
  });
  return out;
}

// src/array/constants.ts
var TRIANGLE_STRIP_QUAD = (/* unused pure expression or super */ null && ([-1, -1, 1, -1, -1, 1, 1, 1]));
var TRIANGLE_STRIP_QUAD_3D = (/* unused pure expression or super */ null && ([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]));
var TRIANGLE_STRIP_QUAD_NORMAL = (/* unused pure expression or super */ null && ([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]));
var TRIANGLE_STRIP_QUAD_UV = (/* unused pure expression or super */ null && ([0, 0, 1, 0, 0, 1, 1, 1]));

// src/array/utils.ts
function shuffleArray(array, dice) {
  const f = dice ? dice : () => Math.random();
  for (let i = 0; i < array.length - 1; i++) {
    const ir = i + Math.floor(f() * (array.length - i));
    const temp = array[ir];
    array[ir] = array[i];
    array[i] = temp;
  }
  return array;
}
function triIndexToLineIndex(array) {
  const ret = [];
  for (let i = 0; i < array.length / 3; i++) {
    const head = i * 3;
    ret.push(array[head], array[head + 1], array[head + 1], array[head + 2], array[head + 2], array[head]);
  }
  return ret;
}
function matrix2d(w, h) {
  const arr = [];
  for (let iy = 0; iy < h; iy++) {
    for (let ix = 0; ix < w; ix++) {
      arr.push(ix, iy);
    }
  }
  return arr;
}
function matrix3d(w, h, d) {
  const arr = [];
  for (let iz = 0; iz < d; iz++) {
    for (let iy = 0; iy < h; iy++) {
      for (let ix = 0; ix < w; ix++) {
        arr.push(ix, iy, iz);
      }
    }
  }
  return arr;
}

// src/CDS/CDS.ts
var CDS = class {
  constructor() {
    this.factor = 100;
    this.ratio = 1;
    this.velocity = 0;
    this.value = 0;
    this.target = 0;
  }
  update(deltaTime) {
    this.velocity += (-this.factor * (this.value - this.target) - 2 * this.velocity * Math.sqrt(this.factor) * this.ratio) * deltaTime;
    this.value += this.velocity * deltaTime;
    return this.value;
  }
};

// src/Clock/Clock.ts
var Clock = class {
  constructor() {
    this.__time = 0;
    this.__deltaTime = 0;
    this.__isPlaying = false;
  }
  get time() {
    return this.__time;
  }
  get deltaTime() {
    return this.__deltaTime;
  }
  get isPlaying() {
    return this.__isPlaying;
  }
  update(time) {
    const prevTime = this.__time;
    this.__time = time || 0;
    this.__deltaTime = this.__time - prevTime;
  }
  play() {
    this.__isPlaying = true;
  }
  pause() {
    this.__isPlaying = false;
  }
  setTime(time) {
    this.__time = time;
  }
};

// src/Clock/ClockFrame.ts
var ClockFrame = class extends (/* unused pure expression or super */ null && (Clock)) {
  constructor(fps = 60) {
    super();
    this.__frame = 0;
    this.__fps = fps;
  }
  get frame() {
    return this.__frame;
  }
  get fps() {
    return this.__fps;
  }
  update() {
    if (this.__isPlaying) {
      this.__time = this.__frame / this.__fps;
      this.__deltaTime = 1 / this.__fps;
      this.__frame++;
    } else {
      this.__deltaTime = 0;
    }
  }
  setTime(time) {
    this.__frame = Math.floor(this.__fps * time);
    this.__time = this.__frame / this.__fps;
  }
};

// src/Clock/ClockRealtime.ts
var ClockRealtime = class extends (/* unused pure expression or super */ null && (Clock)) {
  constructor() {
    super(...arguments);
    this.__rtTime = 0;
    this.__rtDate = performance.now();
  }
  get isRealtime() {
    return true;
  }
  update() {
    const now = performance.now();
    if (this.__isPlaying) {
      const prevTime = this.__time;
      const deltaDate = now - this.__rtDate;
      this.__time = this.__rtTime + deltaDate / 1e3;
      this.__deltaTime = this.time - prevTime;
    } else {
      this.__rtTime = this.time;
      this.__rtDate = now;
      this.__deltaTime = 0;
    }
  }
  setTime(time) {
    this.__time = time;
    this.__rtTime = this.time;
    this.__rtDate = performance.now();
  }
};

// src/color/colorFromAtariST.ts
function colorFromAtariST(stColor) {
  return [
    (stColor >> 8 & 7) / 7,
    (stColor >> 4 & 7) / 7,
    (stColor & 7) / 7
  ];
}

// src/math/utils.ts
function lerp(a, b, x) {
  return a + (b - a) * x;
}
function clamp(x, l, h) {
  return Math.min(Math.max(x, l), h);
}
function saturate(x) {
  return clamp(x, 0, 1);
}
function range(x, x0, x1, y0, y1) {
  return (x - x0) * (y1 - y0) / (x1 - x0) + y0;
}
function linearstep(a, b, x) {
  return saturate((x - a) / (b - a));
}
function smoothstep(a, b, x) {
  const t = linearstep(a, b, x);
  return t * t * (3 - 2 * t);
}
function smootherstep(a, b, x) {
  const t = linearstep(a, b, x);
  return t * t * t * (t * (t * 6 - 15) + 10);
}
function smootheststep(a, b, x) {
  const t = linearstep(a, b, x);
  return t * t * t * t * (t * (t * (-20 * t + 70) - 84) + 35);
}

// src/color/colorHSV2RGB.ts
function colorHSV2RGB([h, s, v]) {
  const ht = h % 1 * 6;
  return [0, 4, 2].map((p) => {
    const colH = Math.min(Math.max(Math.abs((ht + p) % 6 - 3) - 1, 0), 1);
    const colS = lerp(1, colH, s);
    return v * colS;
  });
}

// src/color/colorToHex.ts
function colorToHex(color) {
  return "#" + color.map((v) => ("0" + Math.round(saturate(v) * 255).toString(16)).slice(-2)).join("");
}

// src/math/vec/vecDot.ts
function vecDot(vecA, vecB) {
  return vecA.reduce((sum, v, i) => sum + v * vecB[i], 0);
}

// src/color/colorTurbo.ts
function colorTurbo(x) {
  const kr = [
    0.13572138,
    4.6153926,
    -42.66032258,
    132.13108234,
    -152.94239396,
    59.28637943
  ];
  const kg = [
    0.09140261,
    2.19418839,
    4.84296658,
    -14.18503333,
    4.27729857,
    2.82956604
  ];
  const kb = [
    0.1066733,
    12.64194608,
    -60.58204836,
    110.36276771,
    -89.90310912,
    27.34824973
  ];
  const xt = saturate(x);
  const xv = [
    1,
    xt,
    xt * xt,
    xt * xt * xt,
    xt * xt * xt * xt,
    xt * xt * xt * xt * xt
  ];
  const col = [
    saturate(vecDot(kr, xv)),
    saturate(vecDot(kg, xv)),
    saturate(vecDot(kb, xv))
  ];
  return col;
}

// src/color/eotfRec709.ts
function eotfRec709(value) {
  return value.map((v) => v < 0.081 ? v / 4.5 : Math.pow((v + 0.099) / 1.099, 1 / 0.45));
}

// src/color/oetfRec709.ts
function oetfRec709(luminance) {
  return luminance.map((l) => l < 0.018 ? 4.5 * l : 1.099 * Math.pow(l, 0.45) - 0.099);
}

// src/dag/dagEdgesParents.ts
function dagEdgesParents(edges, destination) {
  return edges.filter((edge) => edge[1] === destination).map((edge) => edge[0]);
}

// src/dag/dagEdgesAncestors.ts
function dagEdgesAncestors(edges, destination) {
  const ancestors = /* @__PURE__ */ new Set();
  traverse(destination, (node) => {
    const parents = dagEdgesParents(edges, node);
    parents.map((parent) => ancestors.add(parent));
    return parents;
  });
  return Array.from(ancestors);
}

// src/dag/dagEdgesChildren.ts
function dagEdgesChildren(edges, source) {
  return edges.filter((edge) => edge[0] === source).map((edge) => edge[1]);
}

// src/dag/dagEdgesDescendants.ts
function dagEdgesDescendants(edges, source) {
  const descendants = /* @__PURE__ */ new Set();
  traverse(source, (node) => {
    const children = dagEdgesChildren(edges, node);
    children.map((child) => descendants.add(child));
    return children;
  });
  return Array.from(descendants);
}

// src/dag/dagEdgesParent.ts
function dagEdgesParent(edges, destination) {
  var _a, _b;
  return (_b = (_a = edges.find((edge) => edge[1] === destination)) == null ? void 0 : _a[0]) != null ? _b : null;
}

// src/dag/dagEdgesResolve.ts
function dagEdgesResolve(edges, nodes) {
  const order = [];
  const nodeSet = new Set(nodes);
  let tempEdges = edges.concat();
  while (tempEdges.length > 0) {
    nodeSet.forEach((node) => {
      const hasParents = dagEdgesParent(tempEdges, node) != null;
      if (!hasParents) {
        nodeSet.delete(node);
        order.push(node);
        tempEdges = tempEdges.filter(([src]) => src !== node);
      }
    });
  }
  return order.concat(Array.from(nodeSet));
}

// src/edt/edt.ts
function edt1d(data, offset, stride, length) {
  let k = 0;
  const v = new Float32Array(length);
  v[0] = 0;
  const z = new Float32Array(length + 1);
  z[0] = -Infinity;
  z[1] = Infinity;
  const f = new Float32Array(length);
  for (let q = 0; q < length; q++) {
    f[q] = data[offset + q * stride];
  }
  for (let q = 1; q < length; q++) {
    let s = 0;
    while (0 <= k) {
      s = (f[q] + q * q - f[v[k]] - v[k] * v[k]) / (2 * q - 2 * v[k]);
      if (s <= z[k]) {
        k--;
      } else {
        break;
      }
    }
    k++;
    v[k] = q;
    z[k] = s;
    z[k + 1] = Infinity;
  }
  k = 0;
  for (let q = 0; q < length; q++) {
    while (z[k + 1] < q) {
      k++;
    }
    const qSubVK = q - v[k];
    data[offset + q * stride] = f[v[k]] + qSubVK * qSubVK;
  }
}
function edt2d(data, width, height) {
  for (let x = 0; x < width; x++) {
    edt1d(data, x, width, height);
  }
  for (let y = 0; y < height; y++) {
    edt1d(data, y * width, 1, width);
  }
}

// src/ExpSmooth/ExpSmooth.ts
var ExpSmooth = class {
  constructor() {
    this.factor = 10;
    this.target = 0;
    this.value = 0;
  }
  update(deltaTime) {
    this.value = lerp(this.target, this.value, Math.exp(-this.factor * deltaTime));
    return this.value;
  }
};

// src/Pool/Pool.ts
var Pool = class {
  constructor(array) {
    this.index = 0;
    this.array = array;
  }
  get current() {
    return this.array[this.index];
  }
  next() {
    this.index = (this.index + 1) % this.array.length;
    return this.current;
  }
};

// src/GPUTimer/GPUTimer.ts
var GPUTimer = class {
  static isSupported(gl) {
    return new Set(gl.getSupportedExtensions()).has("EXT_disjoint_timer_query_webgl2");
  }
  constructor(gl) {
    this.gl = gl;
    const queries = new Array(1024).fill(1).map(() => gl.createQuery());
    this.queries = new Pool(queries);
    this.stack = [];
    this.ext = gl.getExtension("EXT_disjoint_timer_query_webgl2");
    this.__loopTasks = /* @__PURE__ */ new Set();
    const update = () => {
      this.update();
      requestAnimationFrame(update);
    };
    update();
  }
  update() {
    Array.from(this.__loopTasks).forEach((task) => task());
  }
  measure(func) {
    return __async(this, null, function* () {
      const { gl } = this;
      if (this.stack.length !== 0) {
        gl.endQuery(this.ext.TIME_ELAPSED_EXT);
        const promiseFinishingPrev = this.check(this.queries.current);
        this.stack = this.stack.map((promiseAccum2) => __async(this, null, function* () {
          return (yield promiseAccum2) + (yield promiseFinishingPrev);
        }));
      }
      this.stack.push(Promise.resolve(0));
      gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.queries.next());
      func();
      gl.endQuery(this.ext.TIME_ELAPSED_EXT);
      const promiseAccum = this.stack.pop();
      const promiseThis = this.check(this.queries.current);
      if (this.stack.length !== 0) {
        this.stack = this.stack.map((promiseAccum2) => __async(this, null, function* () {
          return (yield promiseAccum2) + (yield promiseThis);
        }));
        gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.queries.next());
      }
      return (yield promiseAccum) + (yield promiseThis);
    });
  }
  check(query) {
    const { gl } = this;
    return new Promise((resolve) => {
      const task = () => {
        const isAvailable = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
        if (isAvailable) {
          this.__loopTasks.delete(task);
          resolve(gl.getQueryParameter(query, gl.QUERY_RESULT) * 1e-3 * 1e-3);
        }
      };
      this.__loopTasks.add(task);
    });
  }
};

// src/HistoryMeanCalculator/HistoryMeanCalculator.ts
var HistoryMeanCalculator = class {
  constructor(length) {
    this.__recalcForEach = 0;
    this.__countUntilRecalc = 0;
    this.__history = [];
    this.__index = 0;
    this.__count = 0;
    this.__cache = 0;
    this.__length = length;
    this.__recalcForEach = length;
    for (let i = 0; i < length; i++) {
      this.__history[i] = 0;
    }
  }
  get mean() {
    const count = Math.min(this.__count, this.__length);
    return count === 0 ? 0 : this.__cache / count;
  }
  get recalcForEach() {
    return this.__recalcForEach;
  }
  set recalcForEach(value) {
    const delta = value - this.__recalcForEach;
    this.__recalcForEach = value;
    this.__countUntilRecalc = Math.max(0, this.__countUntilRecalc + delta);
  }
  reset() {
    this.__index = 0;
    this.__count = 0;
    this.__cache = 0;
    this.__countUntilRecalc = 0;
    for (let i = 0; i < this.__length; i++) {
      this.__history[i] = 0;
    }
  }
  push(value) {
    const prev = this.__history[this.__index];
    this.__history[this.__index] = value;
    this.__count++;
    this.__index = (this.__index + 1) % this.__length;
    if (this.__countUntilRecalc === 0) {
      this.recalc();
    } else {
      this.__countUntilRecalc--;
      this.__cache -= prev;
      this.__cache += value;
    }
  }
  recalc() {
    this.__countUntilRecalc = this.__recalcForEach;
    const sum = this.__history.slice(0, Math.min(this.__count, this.__length)).reduce((sum2, v) => sum2 + v, 0);
    this.__cache = sum;
  }
};

// src/HistoryMeanCalculator/HistoryPercentileCalculator.ts
var HistoryPercentileCalculator = class {
  constructor(length) {
    this.__history = [];
    this.__sorted = [];
    this.__index = 0;
    this.__length = length;
  }
  get median() {
    return this.percentile(50);
  }
  percentile(percentile) {
    if (this.__history.length === 0) {
      return 0;
    }
    return this.__sorted[Math.round(percentile * 0.01 * (this.__history.length - 1))];
  }
  reset() {
    this.__index = 0;
    this.__history = [];
    this.__sorted = [];
  }
  push(value) {
    const prev = this.__history[this.__index];
    this.__history[this.__index] = value;
    this.__index = (this.__index + 1) % this.__length;
    if (this.__sorted.length === this.__length) {
      const prevIndex = binarySearch(this.__sorted, prev);
      this.__sorted.splice(prevIndex, 1);
    }
    const index = binarySearch(this.__sorted, value);
    this.__sorted.splice(index, 0, value);
  }
};

// src/HistoryMeanCalculator/HistoryMedianCalculator.ts
var HistoryMedianCalculator = class extends (/* unused pure expression or super */ null && (HistoryPercentileCalculator)) {
  constructor(length) {
    super(length);
    console.warn("HistoryMedianCalculator: Deprecated. Use HistoryPercentileCalculator instead");
  }
};

// src/MapOfSet/MapOfSet.ts
var MapOfSet = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    var _a;
    return (_a = this.map.get(key)) != null ? _a : /* @__PURE__ */ new Set();
  }
  add(key, value) {
    let set = this.map.get(key);
    if (set == null) {
      set = /* @__PURE__ */ new Set();
      this.map.set(key, set);
    }
    set.add(value);
  }
};

// src/math/vec/vecAbs.ts
function vecAbs(vec) {
  return vec.map((v) => Math.abs(v));
}

// src/math/vec/vecAdd.ts
function vecAdd(...vecs) {
  if (vecs.length < 2) {
    return vecs[0];
  }
  const a = vecs.shift();
  const b = vecAdd(...vecs);
  return a.map((v, i) => v + b[i]);
}

// src/math/vec/vecDivide.ts
function vecDivide(vecA, vecB) {
  return vecA.map((v, i) => v / vecB[i]);
}

// src/math/vec/vecLength.ts
function vecLength(vec) {
  return Math.sqrt(vec.reduce((sum, v) => sum + v * v, 0));
}

// src/math/vec/vecLengthSq.ts
function vecLengthSq(vec) {
  return vec.reduce((sum, v) => sum + v * v, 0);
}

// src/math/vec/vecManhattanLength.ts
function vecManhattanLength(vec) {
  return vec.reduce((sum, v) => sum + Math.abs(v), 0);
}

// src/math/vec/vecMultiply.ts
function vecMultiply(...vecs) {
  if (vecs.length < 2) {
    return vecs[0];
  }
  const a = vecs.shift();
  const b = vecMultiply(...vecs);
  return a.map((v, i) => v * b[i]);
}

// src/math/vec/vecNeg.ts
function vecNeg(vec) {
  return vec.map((v) => -v);
}

// src/math/vec/vecScale.ts
function vecScale(vec, scalar) {
  return vec.map((v) => v * scalar);
}

// src/math/vec/vecNormalize.ts
function vecNormalize(vec) {
  const len = vecLength(vec);
  const invLen = len === 0 ? 0 : 1 / len;
  return vecScale(vec, invLen);
}

// src/math/vec/vecSub.ts
function vecSub(vecA, vecB) {
  return vecA.map((v, i) => v - vecB[i]);
}

// src/math/vec/Vector.ts
var Vector = class {
  get length() {
    return vecLength(this.elements);
  }
  get lengthSq() {
    return vecLengthSq(this.elements);
  }
  get manhattanLength() {
    return vecManhattanLength(this.elements);
  }
  get normalized() {
    return this.__new(vecNormalize(this.elements));
  }
  get negated() {
    return this.__new(vecNeg(this.elements));
  }
  get abs() {
    return this.__new(vecAbs(this.elements));
  }
  clone() {
    return this.__new(this.elements.concat());
  }
  add(...vectors) {
    return this.__new(vecAdd(this.elements, ...vectors.map((v) => v.elements)));
  }
  sub(vector) {
    return this.__new(vecSub(this.elements, vector.elements));
  }
  multiply(...vectors) {
    return this.__new(vecMultiply(this.elements, ...vectors.map((v) => v.elements)));
  }
  divide(vector) {
    return this.__new(vecDivide(this.elements, vector.elements));
  }
  scale(scalar) {
    return this.__new(vecScale(this.elements, scalar));
  }
  dot(vector) {
    return vecDot(this.elements, vector.elements);
  }
};

// src/math/vec4/vec4ApplyMatrix4.ts
function vec4ApplyMatrix4(v, m) {
  return [
    m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3],
    m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3],
    m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3],
    m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3]
  ];
}

// src/math/vec3/vec3ApplyMatrix4.ts
function vec3ApplyMatrix4(v, m) {
  const vec4 = vec4ApplyMatrix4([...v, 1], m);
  const xyz = [vec4[0], vec4[1], vec4[2]];
  const w = vec4[3];
  return vecScale(xyz, 1 / w);
}

// src/math/quat/quatInverse.ts
function quatInverse(quat) {
  return [-quat[0], -quat[1], -quat[2], quat[3]];
}

// src/math/quat/quatMultiply.ts
function quatMultiply(...quats) {
  if (quats.length < 2) {
    return quats[0];
  }
  const a = quats.shift();
  const b = quatMultiply(...quats);
  return [
    a[3] * b[0] + a[0] * b[3] + a[1] * b[2] - a[2] * b[1],
    a[3] * b[1] - a[0] * b[2] + a[1] * b[3] + a[2] * b[0],
    a[3] * b[2] + a[0] * b[1] - a[1] * b[0] + a[2] * b[3],
    a[3] * b[3] - a[0] * b[0] - a[1] * b[1] - a[2] * b[2]
  ];
}

// src/math/vec3/vec3ApplyQuaternion.ts
function vec3ApplyQuaternion(vec, quat) {
  const p = [...vec, 0];
  const r = quatInverse(quat);
  const res = quatMultiply(quat, p, r);
  res.pop();
  return res;
}

// src/math/vec3/vec3Cross.ts
function vec3Cross(vecA, vecB) {
  return [
    vecA[1] * vecB[2] - vecA[2] * vecB[1],
    vecA[2] * vecB[0] - vecA[0] * vecB[2],
    vecA[0] * vecB[1] - vecA[1] * vecB[0]
  ];
}

// src/math/vec3/vec3OrthoNormalize.ts
function vec3OrthoNormalize(normal, tangent = [0, 1, 0], binormal) {
  const n = vecNormalize(normal);
  let t = vecNormalize(tangent);
  let dotNT = vecDot(n, t);
  if (dotNT === 1) {
    if (Math.abs(n[1]) > Math.abs(n[2])) {
      t = [0, 0, 1];
    } else {
      t = [0, 1, 0];
    }
    dotNT = vecDot(n, t);
  }
  t = vecNormalize(vecSub(t, vecScale(n, dotNT)));
  let b = vec3Cross(t, n);
  if (binormal && vecDot(b, binormal) < 0) {
    b = vecNeg(b);
  }
  return {
    normal: n,
    tangent: t,
    binormal: b
  };
}

// src/math/vec3/Vector3.ts
var Vector3 = class extends (/* unused pure expression or super */ null && (Vector)) {
  constructor(v = [0, 0, 0]) {
    super();
    this.elements = v;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  toString() {
    return `Vector3( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)} )`;
  }
  cross(vector) {
    return new Vector3(vec3Cross(this.elements, vector.elements));
  }
  applyQuaternion(quaternion) {
    return new Vector3(vec3ApplyQuaternion(this.elements, quaternion.elements));
  }
  applyMatrix4(matrix) {
    return new Vector3(vec3ApplyMatrix4(this.elements, matrix.elements));
  }
  __new(v) {
    return new Vector3(v);
  }
  static get zero() {
    return new Vector3([0, 0, 0]);
  }
  static get px() {
    return new Vector3([1, 0, 0]);
  }
  static get nx() {
    return new Vector3([-1, 0, 0]);
  }
  static get py() {
    return new Vector3([0, 1, 0]);
  }
  static get ny() {
    return new Vector3([0, -1, 0]);
  }
  static get pz() {
    return new Vector3([0, 0, 1]);
  }
  static get nz() {
    return new Vector3([0, 0, -1]);
  }
  static get one() {
    return new Vector3([1, 1, 1]);
  }
  static orthoNormalize(normal, tangent, binormal) {
    const result = vec3OrthoNormalize(normal.elements, tangent.elements, binormal.elements);
    return {
      normal: new Vector3(result.normal),
      tangent: new Vector3(result.tangent),
      binormal: new Vector3(result.binormal)
    };
  }
};

// src/math/box3/box3ContainsPoint.ts
function box3ContainsPoint(box, point) {
  return box[0][0] <= point[0] && box[1][0] >= point[0] && box[0][1] <= point[1] && box[1][1] >= point[1] && box[0][2] <= point[2] && box[1][2] >= point[2];
}

// src/math/box3/Box3.ts
var Box3 = class {
  constructor(min = Vector3.zero, max = Vector3.zero) {
    this.min = min;
    this.max = max;
  }
  get raw() {
    return [this.min.elements, this.max.elements];
  }
  containsPoint(point) {
    return box3ContainsPoint(this.raw, point.elements);
  }
  static fromRaw(box) {
    return new Box3(new Vector3(box[0]), new Vector3(box[1]));
  }
};

// src/math/mat3/mat3FromMat4Transpose.ts
function mat3FromMat4Transpose(source) {
  return [
    source[0],
    source[4],
    source[8],
    source[1],
    source[5],
    source[9],
    source[2],
    source[6],
    source[10]
  ];
}

// src/math/mat3/mat3Inverse.ts
function mat3Inverse(m) {
  const n11 = m[0], n21 = m[1], n31 = m[2], n12 = m[3], n22 = m[4], n32 = m[5], n13 = m[6], n23 = m[7], n33 = m[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
  if (det === 0) {
    return vecScale(m, 0);
  }
  return vecScale([
    t11,
    n31 * n23 - n33 * n21,
    n32 * n21 - n31 * n22,
    t12,
    n33 * n11 - n31 * n13,
    n31 * n12 - n32 * n11,
    t13,
    n21 * n13 - n23 * n11,
    n22 * n11 - n21 * n12
  ], 1 / det);
}

// src/math/mat3/mat3CreateNormalMatrix.ts
function mat3CreateNormalMatrix(m) {
  return mat3Inverse(mat3FromMat4Transpose(m));
}

// src/math/mat3/mat3Determinant.ts
function mat3Determinant(m) {
  const n11 = m[0], n21 = m[1], n31 = m[2], n12 = m[3], n22 = m[4], n32 = m[5], n13 = m[6], n23 = m[7], n33 = m[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13;
  return n11 * t11 + n21 * t12 + n31 * t13;
}

// src/math/mat3/mat3FromMat4.ts
function mat3FromMat4(source) {
  return [
    source[0],
    source[1],
    source[2],
    source[4],
    source[5],
    source[6],
    source[8],
    source[9],
    source[10]
  ];
}

// src/math/mat3/mat3FromQuaternion.ts
function mat3FromQuaternion(quat) {
  const x = quat[0];
  const y = quat[1];
  const z = quat[2];
  const w = quat[3];
  return [
    1 - 2 * y * y - 2 * z * z,
    2 * x * y + 2 * z * w,
    2 * x * z - 2 * y * w,
    2 * x * y - 2 * z * w,
    1 - 2 * x * x - 2 * z * z,
    2 * y * z + 2 * x * w,
    2 * x * z + 2 * y * w,
    2 * y * z - 2 * x * w,
    1 - 2 * x * x - 2 * y * y
  ];
}

// src/math/mat3/mat3Multiply.ts
function mat3Multiply(...mats) {
  if (mats.length < 2) {
    return mats[0];
  }
  const a = mats.shift();
  const b = mat3Multiply(...mats);
  const a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
  return [
    a00 * b00 + a10 * b01 + a20 * b02,
    a01 * b00 + a11 * b01 + a21 * b02,
    a02 * b00 + a12 * b01 + a22 * b02,
    a00 * b10 + a10 * b11 + a20 * b12,
    a01 * b10 + a11 * b11 + a21 * b12,
    a02 * b10 + a12 * b11 + a22 * b12,
    a00 * b20 + a10 * b21 + a20 * b22,
    a01 * b20 + a11 * b21 + a21 * b22,
    a02 * b20 + a12 * b21 + a22 * b22
  ];
}

// src/math/mat3/mat3Transpose.ts
function mat3Transpose(source) {
  return [
    source[0],
    source[3],
    source[6],
    source[1],
    source[4],
    source[7],
    source[2],
    source[5],
    source[8]
  ];
}

// src/math/mat3/Matrix3.ts
var rawIdentityMatrix3 = (/* unused pure expression or super */ null && ([
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1
]));
var Matrix3 = class {
  constructor(v = rawIdentityMatrix3) {
    this.elements = v;
  }
  get transpose() {
    return new Matrix3(mat3Transpose(this.elements));
  }
  get determinant() {
    return mat3Determinant(this.elements);
  }
  get inverse() {
    return new Matrix3(mat3Inverse(this.elements));
  }
  get matrix4() {
    return Matrix4.fromMatrix3(this);
  }
  toString() {
    const m = this.elements.map((v) => v.toFixed(3));
    return `Matrix3( ${m[0]}, ${m[3]}, ${m[6]}; ${m[1]}, ${m[4]}, ${m[7]}; ${m[2]}, ${m[5]}, ${m[8]} )`;
  }
  clone() {
    return new Matrix3(this.elements.concat());
  }
  multiply(...matrices) {
    return Matrix3.multiply(this, ...matrices);
  }
  scaleScalar(scalar) {
    return new Matrix3(vecScale(this.elements, scalar));
  }
  static get identity() {
    return new Matrix3(rawIdentityMatrix3);
  }
  static multiply(...matrices) {
    if (matrices.length === 0) {
      return Matrix3.identity;
    } else {
      return new Matrix3(mat3Multiply(...matrices.map((m) => m.elements)));
    }
  }
  static createNormalMatrix(matrix4) {
    return new Matrix3(mat3CreateNormalMatrix(matrix4.elements));
  }
  static fromMatrix4(matrix4) {
    return new Matrix3(mat3FromMat4(matrix4.elements));
  }
  static fromQuaternion(quaternion) {
    return new Matrix3(mat3FromQuaternion(quaternion.elements));
  }
};

// src/math/mat4/mat4FromQuaternion.ts
function mat4FromQuaternion(quat) {
  const x = quat[0];
  const y = quat[1];
  const z = quat[2];
  const w = quat[3];
  return [
    1 - 2 * y * y - 2 * z * z,
    2 * x * y + 2 * z * w,
    2 * x * z - 2 * y * w,
    0,
    2 * x * y - 2 * z * w,
    1 - 2 * x * x - 2 * z * z,
    2 * y * z + 2 * x * w,
    0,
    2 * x * z + 2 * y * w,
    2 * y * z - 2 * x * w,
    1 - 2 * x * x - 2 * y * y,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Compose.ts
function mat4Compose(position, rotation, scale) {
  const matRot = mat4FromQuaternion(rotation);
  const sx = scale[0], sy = scale[1], sz = scale[2];
  return [
    matRot[0] * sx,
    matRot[1] * sx,
    matRot[2] * sx,
    0,
    matRot[4] * sy,
    matRot[5] * sy,
    matRot[6] * sy,
    0,
    matRot[8] * sz,
    matRot[9] * sz,
    matRot[10] * sz,
    0,
    position[0],
    position[1],
    position[2],
    1
  ];
}

// src/math/mat4/mat4Determinant.ts
function mat4Determinant(m) {
  const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3], a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7], a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11], a30 = m[12], a31 = m[13], a32 = m[14], a33 = m[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

// src/math/quat/quatFromMatrix3.ts
function quatFromMatrix3(m) {
  const m11 = m[0], m12 = m[3], m13 = m[6], m21 = m[1], m22 = m[4], m23 = m[7], m31 = m[2], m32 = m[5], m33 = m[8], trace = m11 + m22 + m33;
  if (trace > 0) {
    const s = 0.5 / Math.sqrt(trace + 1);
    return [
      (m32 - m23) * s,
      (m13 - m31) * s,
      (m21 - m12) * s,
      0.25 / s
    ];
  } else if (m11 > m22 && m11 > m33) {
    const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
    return [
      0.25 * s,
      (m12 + m21) / s,
      (m13 + m31) / s,
      (m32 - m23) / s
    ];
  } else if (m22 > m33) {
    const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
    return [
      (m12 + m21) / s,
      0.25 * s,
      (m23 + m32) / s,
      (m13 - m31) / s
    ];
  } else {
    const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
    return [
      (m13 + m31) / s,
      (m23 + m32) / s,
      0.25 * s,
      (m21 - m12) / s
    ];
  }
}

// src/math/quat/quatFromMatrix4.ts
function quatFromMatrix4(m) {
  return quatFromMatrix3(mat3FromMat4(m));
}

// src/math/mat4/mat4Decompose.ts
function mat4Decompose(m) {
  let sx = vecLength([m[0], m[1], m[2]]);
  const sy = vecLength([m[4], m[5], m[6]]);
  const sz = vecLength([m[8], m[9], m[10]]);
  const det = mat4Determinant(m);
  if (det < 0) {
    sx = -sx;
  }
  const invSx = 1 / sx;
  const invSy = 1 / sy;
  const invSz = 1 / sz;
  const rotationMatrix = m.concat();
  rotationMatrix[0] *= invSx;
  rotationMatrix[1] *= invSx;
  rotationMatrix[2] *= invSx;
  rotationMatrix[4] *= invSy;
  rotationMatrix[5] *= invSy;
  rotationMatrix[6] *= invSy;
  rotationMatrix[8] *= invSz;
  rotationMatrix[9] *= invSz;
  rotationMatrix[10] *= invSz;
  return {
    position: [m[12], m[13], m[14]],
    scale: [sx, sy, sz],
    rotation: quatFromMatrix4(rotationMatrix)
  };
}

// src/math/mat4/mat4FromMat3.ts
function mat4FromMat3(source) {
  return [
    source[0],
    source[1],
    source[2],
    0,
    source[3],
    source[4],
    source[5],
    0,
    source[6],
    source[7],
    source[8],
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Inverse.ts
function mat4Inverse(m) {
  const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3], a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7], a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11], a30 = m[12], a31 = m[13], a32 = m[14], a33 = m[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
  const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (det === 0) {
    return vecScale(m, 0);
  }
  return vecScale([
    a11 * b11 - a12 * b10 + a13 * b09,
    a02 * b10 - a01 * b11 - a03 * b09,
    a31 * b05 - a32 * b04 + a33 * b03,
    a22 * b04 - a21 * b05 - a23 * b03,
    a12 * b08 - a10 * b11 - a13 * b07,
    a00 * b11 - a02 * b08 + a03 * b07,
    a32 * b02 - a30 * b05 - a33 * b01,
    a20 * b05 - a22 * b02 + a23 * b01,
    a10 * b10 - a11 * b08 + a13 * b06,
    a01 * b08 - a00 * b10 - a03 * b06,
    a30 * b04 - a31 * b02 + a33 * b00,
    a21 * b02 - a20 * b04 - a23 * b00,
    a11 * b07 - a10 * b09 - a12 * b06,
    a00 * b09 - a01 * b07 + a02 * b06,
    a31 * b01 - a30 * b03 - a32 * b00,
    a20 * b03 - a21 * b01 + a22 * b00
  ], 1 / det);
}

// src/math/mat4/mat4LookAt.ts
function mat4LookAt(position, target = [0, 0, 0], up = [0, 1, 0], roll = 0) {
  const dir = vecNormalize(vecSub(position, target));
  let sid = vecNormalize(vec3Cross(up, dir));
  if (roll !== 0) {
    sid = vecAdd(vecScale(sid, Math.cos(roll)), vecScale(vec3Cross(dir, sid), Math.sin(roll)));
  }
  const top = vec3Cross(dir, sid);
  return [
    sid[0],
    sid[1],
    sid[2],
    0,
    top[0],
    top[1],
    top[2],
    0,
    dir[0],
    dir[1],
    dir[2],
    0,
    position[0],
    position[1],
    position[2],
    1
  ];
}

// src/math/mat4/mat4LookAtInverse.ts
function mat4LookAtInverse(position, target = [0, 0, 0], up = [0, 1, 0], roll = 0) {
  const dir = vecNormalize(vecSub(position, target));
  let sid = vecNormalize(vec3Cross(up, dir));
  if (roll !== 0) {
    sid = vecAdd(vecScale(sid, Math.cos(roll)), vecScale(vec3Cross(dir, sid), Math.sin(roll)));
  }
  const top = vec3Cross(dir, sid);
  return [
    sid[0],
    top[0],
    dir[0],
    0,
    sid[1],
    top[1],
    dir[1],
    0,
    sid[2],
    top[2],
    dir[2],
    0,
    -vecDot(sid, position),
    -vecDot(top, position),
    -vecDot(dir, position),
    1
  ];
}

// src/math/mat4/mat4Multiply.ts
function mat4Multiply(...mats) {
  if (mats.length < 2) {
    return mats[0];
  }
  const a = mats.shift();
  const b = mat4Multiply(...mats);
  const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3], b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7], b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11], b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
  return [
    a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03,
    a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03,
    a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03,
    a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03,
    a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13,
    a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13,
    a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13,
    a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13,
    a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23,
    a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23,
    a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23,
    a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23,
    a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33,
    a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33,
    a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33,
    a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33
  ];
}

// src/math/mat4/mat4Perspective.ts
function mat4Perspective(fov = 45, near = 0.01, far = 100, aspect = 1) {
  const p = 1 / Math.tan(fov * Math.PI / 360);
  const d = far - near;
  return [
    p / aspect,
    0,
    0,
    0,
    0,
    p,
    0,
    0,
    0,
    0,
    -(far + near) / d,
    -1,
    0,
    0,
    -2 * far * near / d,
    0
  ];
}

// src/math/mat4/mat4RotationX.ts
function mat4RotationX(theta) {
  const c = Math.cos(theta);
  const s = Math.sin(theta);
  return [
    1,
    0,
    0,
    0,
    0,
    c,
    -s,
    0,
    0,
    s,
    c,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4RotationY.ts
function mat4RotationY(theta) {
  const c = Math.cos(theta);
  const s = Math.sin(theta);
  return [
    c,
    0,
    s,
    0,
    0,
    1,
    0,
    0,
    -s,
    0,
    c,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4RotationZ.ts
function mat4RotationZ(theta) {
  const c = Math.cos(theta);
  const s = Math.sin(theta);
  return [
    c,
    -s,
    0,
    0,
    s,
    c,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Scale.ts
function mat4Scale(vec) {
  return [
    vec[0],
    0,
    0,
    0,
    0,
    vec[1],
    0,
    0,
    0,
    0,
    vec[2],
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4ScaleScalar.ts
function mat4ScaleScalar(scalar) {
  return [
    scalar,
    0,
    0,
    0,
    0,
    scalar,
    0,
    0,
    0,
    0,
    scalar,
    0,
    0,
    0,
    0,
    1
  ];
}

// src/math/mat4/mat4Translate.ts
function mat4Translate(vec) {
  return [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    vec[0],
    vec[1],
    vec[2],
    1
  ];
}

// src/math/mat4/mat4Transpose.ts
function mat4Transpose(m) {
  return [
    m[0],
    m[4],
    m[8],
    m[12],
    m[1],
    m[5],
    m[9],
    m[13],
    m[2],
    m[6],
    m[10],
    m[14],
    m[3],
    m[7],
    m[11],
    m[15]
  ];
}

// src/math/mat4/Matrix4.ts
var rawIdentityMatrix4 = (/* unused pure expression or super */ null && ([
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
]));
var Matrix4 = class {
  constructor(v = rawIdentityMatrix4) {
    this.elements = v;
  }
  get transpose() {
    return new Matrix4(mat4Transpose(this.elements));
  }
  get determinant() {
    return mat4Determinant(this.elements);
  }
  get inverse() {
    return new Matrix4(mat4Inverse(this.elements));
  }
  get matrix3() {
    return Matrix3.fromMatrix4(this);
  }
  get normalMatrix() {
    return Matrix3.createNormalMatrix(this);
  }
  toString() {
    const m = this.elements.map((v) => v.toFixed(3));
    return `Matrix4( ${m[0]}, ${m[4]}, ${m[8]}, ${m[12]}; ${m[1]}, ${m[5]}, ${m[9]}, ${m[13]}; ${m[2]}, ${m[6]}, ${m[10]}, ${m[14]}; ${m[3]}, ${m[7]}, ${m[11]}, ${m[15]} )`;
  }
  clone() {
    return new Matrix4(this.elements.concat());
  }
  multiply(...matrices) {
    return Matrix4.multiply(this, ...matrices);
  }
  scaleScalar(scalar) {
    return new Matrix4(vecScale(this.elements, scalar));
  }
  decompose() {
    const { position, scale, rotation } = mat4Decompose(this.elements);
    return {
      position: new Vector3(position),
      scale: new Vector3(scale),
      rotation: new Quaternion(rotation)
    };
  }
  static get identity() {
    return new Matrix4(rawIdentityMatrix4);
  }
  static multiply(...matrices) {
    if (matrices.length === 0) {
      return Matrix4.identity;
    } else {
      return new Matrix4(mat4Multiply(...matrices.map((m) => m.elements)));
    }
  }
  static fromQuaternion(quaternion) {
    return new Matrix4(mat4FromQuaternion(quaternion.elements));
  }
  static fromMatrix3(matrix3) {
    return new Matrix4(mat4FromMat3(matrix3.elements));
  }
  static translate(vector) {
    return new Matrix4(mat4Translate(vector.elements));
  }
  static scale(vector) {
    return new Matrix4(mat4Scale(vector.elements));
  }
  static scaleScalar(scalar) {
    return new Matrix4(mat4ScaleScalar(scalar));
  }
  static rotationX(theta) {
    return new Matrix4(mat4RotationX(theta));
  }
  static rotationY(theta) {
    return new Matrix4(mat4RotationY(theta));
  }
  static rotationZ(theta) {
    return new Matrix4(mat4RotationZ(theta));
  }
  static lookAt(position, target = new Vector3([0, 0, 0]), up = new Vector3([0, 1, 0]), roll = 0) {
    return new Matrix4(mat4LookAt(position.elements, target.elements, up.elements, roll));
  }
  static lookAtInverse(position, target = new Vector3([0, 0, 0]), up = new Vector3([0, 1, 0]), roll = 0) {
    return new Matrix4(mat4LookAtInverse(position.elements, target.elements, up.elements, roll));
  }
  static perspective(fov = 45, near = 0.01, far = 100) {
    return new Matrix4(mat4Perspective(fov, near, far));
  }
  static compose(position, rotation, scale) {
    return new Matrix4(mat4Compose(position.elements, rotation.elements, scale.elements));
  }
};

// src/math/quat/quatFromAxisAngle.ts
function quatFromAxisAngle(axis, angle) {
  const halfAngle = angle / 2;
  const sinHalfAngle = Math.sin(halfAngle);
  return [
    axis[0] * sinHalfAngle,
    axis[1] * sinHalfAngle,
    axis[2] * sinHalfAngle,
    Math.cos(halfAngle)
  ];
}

// src/math/quat/quatLookRotation.ts
function quatLookRotation(look, up) {
  const { normal, tangent, binormal } = vec3OrthoNormalize(look, up != null ? up : [0, 1, 0]);
  const w = Math.sqrt(1 + binormal[0] + tangent[1] + normal[2]) * 0.5;
  const invW4 = 0.25 / w;
  return [
    (tangent[2] - normal[1]) * invW4,
    (normal[0] - binormal[2]) * invW4,
    (binormal[1] - tangent[0]) * invW4,
    w
  ];
}

// src/math/quat/quatNormalize.ts
function quatNormalize(vec) {
  const len = vecLength(vec);
  if (len === 0) {
    return [0, 0, 0, 1];
  }
  return vecScale(vec, 1 / len);
}

// src/math/quat/quatRotationX.ts
function quatRotationX(theta) {
  return [Math.sin(theta / 2), 0, 0, Math.cos(theta / 2)];
}

// src/math/quat/quatRotationY.ts
function quatRotationY(theta) {
  return [0, Math.sin(theta / 2), 0, Math.cos(theta / 2)];
}

// src/math/quat/quatRotationZ.ts
function quatRotationZ(theta) {
  return [0, 0, Math.sin(theta / 2), Math.cos(theta / 2)];
}

// src/math/quat/quatSlerp.ts
function quatSlerp(a, b, t) {
  if (t === 0) {
    return a.concat();
  }
  if (t === 1) {
    return b.concat();
  }
  let cosHalfTheta = vecDot(a, b);
  if (cosHalfTheta < 0) {
    b = vecNeg(b);
    cosHalfTheta = -cosHalfTheta;
  }
  if (cosHalfTheta >= 1) {
    return a.concat();
  }
  const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
  if (sqrSinHalfTheta <= Number.EPSILON) {
    const s = 1 - t;
    return vecNormalize([
      s * a[0] + t * b[0],
      s * a[1] + t * b[1],
      s * a[2] + t * b[2],
      s * a[3] + t * b[3]
    ]);
  }
  const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
  const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
  const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
  const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
  return [
    a[0] * ratioA + b[0] * ratioB,
    a[1] * ratioA + b[1] * ratioB,
    a[2] * ratioA + b[2] * ratioB,
    a[3] * ratioA + b[3] * ratioB
  ];
}

// src/math/quat/Quaternion.ts
var rawIdentityQuaternion = (/* unused pure expression or super */ null && ([0, 0, 0, 1]));
var Quaternion = class {
  constructor(elements = rawIdentityQuaternion) {
    this.elements = elements;
  }
  get x() {
    return this.elements[0];
  }
  get y() {
    return this.elements[1];
  }
  get z() {
    return this.elements[2];
  }
  get w() {
    return this.elements[3];
  }
  toString() {
    return `Quaternion( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)} )`;
  }
  clone() {
    return new Quaternion(this.elements.concat());
  }
  get matrix4() {
    return new Matrix4(mat4FromQuaternion(this.elements));
  }
  get inversed() {
    return new Quaternion(quatInverse(this.elements));
  }
  get length() {
    return vecLength(this.elements);
  }
  get lengthSq() {
    return vecLengthSq(this.elements);
  }
  get normalized() {
    return new Quaternion(quatNormalize(this.elements));
  }
  multiply(...quaternions) {
    return Quaternion.multiply(this, ...quaternions);
  }
  slerp(b, t) {
    return Quaternion.slerp(this, b, t);
  }
  static get identity() {
    return new Quaternion(rawIdentityQuaternion);
  }
  static multiply(...quaternions) {
    if (quaternions.length === 0) {
      return Quaternion.identity;
    } else {
      return new Quaternion(quatMultiply(...quaternions.map((q) => q.elements)));
    }
  }
  static slerp(a, b, t) {
    return new Quaternion(quatSlerp(a.elements, b.elements, t));
  }
  static rotationX(theta) {
    return new Quaternion(quatRotationX(theta));
  }
  static rotationY(theta) {
    return new Quaternion(quatRotationY(theta));
  }
  static rotationZ(theta) {
    return new Quaternion(quatRotationZ(theta));
  }
  static lookRotation(look, up) {
    return new Quaternion(quatLookRotation(look.elements, up.elements));
  }
  static fromAxisAngle(axis, angle) {
    return new Quaternion(quatFromAxisAngle(axis.elements, angle));
  }
  static fromMatrix4(matrix) {
    return new Quaternion(quatFromMatrix4(matrix.elements));
  }
};

// src/math/mod.ts
function _0b5vr_experimental_esm_mod(value, divisor) {
  return value - Math.floor(value / divisor) * divisor;
}

// src/math/sanitizeAngle.ts
function sanitizeAngle(angle) {
  return _0b5vr_experimental_esm_mod(angle + Math.PI, 2 * Math.PI) - Math.PI;
}

// src/math/euler/eulerFromMat3.ts
function eulerFromMat3(m, order) {
  const [i, j, k, sign] = !order || order === "XYZ" ? [0, 1, 2, 1] : order === "XZY" ? [0, 2, 1, -1] : order === "YXZ" ? [1, 0, 2, -1] : order === "YZX" ? [1, 2, 0, 1] : order === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1];
  const result = [0, 0, 0];
  const c = m[k + i * 3];
  result[j] = -sign * Math.asin(clamp(c, -1, 1));
  if (Math.abs(c) < 0.999999) {
    result[i] = sign * Math.atan2(m[k + j * 3], m[k * 4]);
    result[k] = sign * Math.atan2(m[j + i * 3], m[i * 4]);
  } else {
    result[i] = sign * Math.atan2(-m[j + k * 3], m[j * 4]);
  }
  if (vecManhattanLength(result) > 1.5 * Math.PI) {
    result[i] = sanitizeAngle(result[i] + Math.PI);
    result[j] = sanitizeAngle(Math.PI - result[j]);
    result[k] = sanitizeAngle(result[k] + Math.PI);
  }
  return result;
}

// src/math/euler/eulerFromMat4.ts
function eulerFromMat4(m, order) {
  return eulerFromMat3(mat3FromMat4(m), order);
}

// src/math/euler/eulerFromQuaternion.ts
function eulerFromQuaternion(m, order) {
  return eulerFromMat3(mat3FromQuaternion(m), order);
}

// src/math/quat/quatFromEuler.ts
function quatFromEuler(euler, order) {
  const [i, j, k, sign] = !order || order === "XYZ" ? [0, 1, 2, 1] : order === "XZY" ? [0, 2, 1, -1] : order === "YXZ" ? [1, 0, 2, -1] : order === "YZX" ? [1, 2, 0, 1] : order === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1];
  const ti = 0.5 * euler[i];
  const tj = 0.5 * sign * euler[j];
  const tk = 0.5 * euler[k];
  const ci = Math.cos(ti);
  const cj = Math.cos(tj);
  const ck = Math.cos(tk);
  const si = Math.sin(ti);
  const sj = Math.sin(tj);
  const sk = Math.sin(tk);
  const result = [
    0,
    0,
    0,
    ck * cj * ci + sk * sj * si
  ];
  result[i] = ck * cj * si - sk * sj * ci;
  result[j] = sign * (ck * sj * ci + sk * cj * si);
  result[k] = sk * cj * ci - ck * sj * si;
  return result;
}

// src/math/euler/Euler.ts
var Euler = class {
  constructor(elements = [0, 0, 0], order = "XYZ") {
    this.elements = elements;
    this.order = order;
  }
  get x() {
    return this.elements[0];
  }
  get y() {
    return this.elements[1];
  }
  get z() {
    return this.elements[2];
  }
  toString() {
    return `Euler( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)} (${this.order}) )`;
  }
  clone() {
    return new Euler(this.elements.concat(), this.order);
  }
  get quaternion() {
    return new Quaternion(quatFromEuler(this.elements, this.order));
  }
  get matrix4() {
    return this.quaternion.matrix4;
  }
  static fromMatrix3(matrix, order) {
    return new Euler(eulerFromMat3(matrix.elements, order), order);
  }
  static fromMatrix4(matrix, order) {
    return new Euler(eulerFromMat4(matrix.elements, order), order);
  }
  static fromQuaternion(quaternion, order) {
    return new Euler(eulerFromQuaternion(quaternion.elements, order), order);
  }
};

// src/math/ray3/ray3DistanceToSphere.ts
function ray3DistanceToSphere([ro, rd], sphere) {
  const v = vecSub(ro, sphere[0]);
  const b = vecDot(v, rd);
  const c = vecDot(v, v) - sphere[1];
  const d = b * b - c;
  if (d < 0) {
    return null;
  }
  const sqrtD = Math.sqrt(d);
  return [-b - sqrtD, -b + sqrtD];
}

// src/math/line3/line3Delta.ts
function line3Delta(line) {
  return vecSub(line[1], line[0]);
}

// src/math/ray3/ray3FromLine3.ts
function ray3FromLine3(line) {
  return [
    line[0],
    vecNormalize(line3Delta(line))
  ];
}

// src/math/ray3/Ray3.ts
var Ray3 = class {
  constructor(start = Vector3.zero, end = Vector3.pz) {
    this.origin = start;
    this.direction = end;
  }
  get raw() {
    return [this.origin.elements, this.direction.elements];
  }
  distanceToSphere(sphere) {
    return ray3DistanceToSphere(this.raw, sphere.raw);
  }
  static fromRaw(ray) {
    return new Ray3(new Vector3(ray[0]), new Vector3(ray[1]));
  }
  static fromLine3(line) {
    return Ray3.fromRaw(ray3FromLine3(line.raw));
  }
};

// src/math/line3/line3ApplyMatrix4.ts
function line3ApplyMatrix4([start, end], matrix) {
  return [
    vec3ApplyMatrix4(start, matrix),
    vec3ApplyMatrix4(end, matrix)
  ];
}

// src/math/line3/line3At.ts
function line3At(line, t) {
  return vecAdd(vecScale(line[0], 1 - t), vecScale(line[1], t));
}

// src/math/line3/line3ClosestPointToPoint.ts
function line3ClosestPointToPoint(line, point, segment) {
  const ap = vecSub(point, line[0]);
  const ab = vecSub(line[1], line[0]);
  let t = vecDot(ap, ab) / vecDot(ab, ab);
  segment && (t = saturate(t));
  return line3At(line, t);
}

// src/math/line3/line3DistanceToPoint.ts
function line3DistanceToPoint(line, point, segment) {
  return vecLength(vecSub(line3ClosestPointToPoint(line, point, segment), point));
}

// src/math/line3/Line3.ts
var Line3 = class {
  constructor(start = Vector3.zero, end = Vector3.zero) {
    this.start = start;
    this.end = end;
  }
  get raw() {
    return [this.start.elements, this.end.elements];
  }
  get ray() {
    return Ray3.fromLine3(this);
  }
  delta() {
    return new Vector3(line3Delta(this.raw));
  }
  length() {
    return this.delta.length;
  }
  at(t) {
    return new Vector3(line3At(this.raw, t));
  }
  applyMatrix4(matrix) {
    return Line3.fromRaw(line3ApplyMatrix4(this.raw, matrix.elements));
  }
  closestPointToPoint(point, segment) {
    return new Vector3(line3ClosestPointToPoint(this.raw, point.elements, segment));
  }
  distanceToPoint(point, segment) {
    return line3DistanceToPoint(this.raw, point.elements, segment);
  }
  static fromRaw(line) {
    return new Line3(new Vector3(line[0]), new Vector3(line[1]));
  }
};

// src/math/mat2/mat2Determinant.ts
function mat2Determinant(m) {
  return m[0] * m[3] - m[2] * m[1];
}

// src/math/mat2/mat2Inverse.ts
function mat2Inverse(m) {
  const n11 = m[0], n21 = m[1], n12 = m[2], n22 = m[3], det = n11 * n22 - n12 * n21;
  if (det === 0) {
    return vecScale(m, 0);
  }
  return vecScale([
    n22,
    -n21,
    -n12,
    n11
  ], 1 / det);
}

// src/math/mat2/mat2Multiply.ts
function mat2Multiply(...mats) {
  if (mats.length < 2) {
    return mats[0];
  }
  const a = mats.shift();
  const b = mat2Multiply(...mats);
  const a00 = a[0], a01 = a[1], a10 = a[2], a11 = a[3], b00 = b[0], b01 = b[1], b10 = b[2], b11 = b[3];
  return [
    a00 * b00 + a10 * b01,
    a01 * b00 + a11 * b01,
    a00 * b10 + a10 * b11,
    a01 * b10 + a11 * b11
  ];
}

// src/math/mat2/mat2Transpose.ts
function mat2Transpose(source) {
  return [
    source[0],
    source[2],
    source[1],
    source[3]
  ];
}

// src/math/mat2/Matrix2.ts
var rawIdentityMatrix2 = (/* unused pure expression or super */ null && ([
  1,
  0,
  0,
  1
]));
var Matrix2 = class {
  constructor(v = rawIdentityMatrix2) {
    this.elements = v;
  }
  get transpose() {
    return new Matrix2(mat2Transpose(this.elements));
  }
  get determinant() {
    return mat2Determinant(this.elements);
  }
  get inverse() {
    return new Matrix2(mat2Inverse(this.elements));
  }
  toString() {
    const m = this.elements.map((v) => v.toFixed(3));
    return `Matrix2( ${m[0]}, ${m[2]}; ${m[1]}, ${m[3]} )`;
  }
  clone() {
    return new Matrix2(this.elements.concat());
  }
  multiply(...matrices) {
    return Matrix2.multiply(this, ...matrices);
  }
  scaleScalar(scalar) {
    return new Matrix2(vecScale(this.elements, scalar));
  }
  static get identity() {
    return new Matrix2(rawIdentityMatrix2);
  }
  static multiply(...matrices) {
    if (matrices.length === 0) {
      return Matrix2.identity;
    } else {
      return new Matrix2(mat2Multiply(...matrices.map((m) => m.elements)));
    }
  }
};

// src/math/vec3/vec3ApplyMatrix3.ts
function vec3ApplyMatrix3(v, m) {
  return [
    m[0] * v[0] + m[3] * v[1] + m[6] * v[2],
    m[1] * v[0] + m[4] * v[1] + m[7] * v[2],
    m[2] * v[0] + m[5] * v[1] + m[8] * v[2]
  ];
}

// src/math/plane3/plane3ApplyMatrix4.ts
function plane3ApplyMatrix4([normal, distance], matrix, normalMatrix) {
  const newNormal = vecNormalize(vec3ApplyMatrix3(normal, normalMatrix));
  const coplanar = vecScale(normal, -distance);
  const refPoint = vec3ApplyMatrix4(coplanar, matrix);
  const newDistance = -vecDot(refPoint, normal);
  return [newNormal, newDistance];
}

// src/math/plane3/plane3DistanceToPoint.ts
function plane3DistanceToPoint([normal, distance], point) {
  return vecDot(normal, point) + distance;
}

// src/math/plane3/plane3Normalize.ts
function plane3Normalize([normal, distance]) {
  const invL = 1 / vecLength(normal);
  return [vecScale(normal, invL), distance * invL];
}

// src/math/plane3/Plane3.ts
var Plane3 = class {
  get raw() {
    return [this.normal.elements, this.distance];
  }
  get normalized() {
    return Plane3.fromRaw(plane3Normalize(this.raw));
  }
  constructor(normal = Vector3.pz, distance = 0) {
    this.normal = normal;
    this.distance = distance;
  }
  applyMatrix4(matrix, normalMatrix) {
    var _a;
    return Plane3.fromRaw(plane3ApplyMatrix4(this.raw, matrix.elements, (_a = normalMatrix == null ? void 0 : normalMatrix.elements) != null ? _a : matrix.normalMatrix.elements));
  }
  distanceToPoint(point) {
    return plane3DistanceToPoint(this.raw, point.elements);
  }
  static fromRaw(plane) {
    return new Plane3(new Vector3(plane[0]), plane[1]);
  }
};

// src/math/plane3/planes3ContainPoint.ts
function planes3ContainPoint(planes, point) {
  return planes.every((plane) => plane3DistanceToPoint(plane, point) >= 0);
}

// src/math/plane3/planes3FromBox3.ts
function planes3FromBox3(box) {
  return [
    [[1, 0, 0], -box[0][0]],
    [[-1, 0, 0], box[1][0]],
    [[0, 1, 0], -box[0][1]],
    [[0, -1, 0], box[1][1]],
    [[0, 0, 1], -box[0][2]],
    [[0, 0, -1], box[1][2]]
  ];
}

// src/math/plane3/planes3FromProjectionMatrix.ts
function planes3FromProjectionMatrix(m) {
  const m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
  return [
    plane3Normalize([[m41 - m11, m42 - m12, m43 - m13], m44 - m14]),
    plane3Normalize([[m41 + m11, m42 + m12, m43 + m13], m44 + m14]),
    plane3Normalize([[m41 - m21, m42 - m22, m43 - m23], m44 - m24]),
    plane3Normalize([[m41 + m21, m42 + m22, m43 + m23], m44 + m24]),
    plane3Normalize([[m41 - m31, m42 - m32, m43 - m33], m44 - m34]),
    plane3Normalize([[m41 + m31, m42 + m32, m43 + m33], m44 + m34])
  ];
}

// src/math/plane3/planes3IntersectBox3.ts
function planes3IntersectBox3(planes, box) {
  return planes.every((plane) => {
    const v = plane[0].map((nc, i) => box[nc > 0 ? 1 : 0][i]);
    return plane3DistanceToPoint(plane, v) >= 0;
  });
}

// src/math/plane3/planes3IntersectSphere3.ts
function planes3IntersectSphere3(planes, sphere) {
  return planes.every((plane) => plane3DistanceToPoint(plane, sphere[0]) >= -sphere[1]);
}

// src/math/plane3/Planes3.ts
var Planes3 = class {
  get raw() {
    return this.planes.map((plane) => plane.raw);
  }
  constructor(planes) {
    this.planes = planes;
  }
  containPoint(point) {
    return planes3ContainPoint(this.raw, point.elements);
  }
  intersectBox3(box) {
    return planes3IntersectBox3(this.raw, box.raw);
  }
  intersectSphere3(sphere) {
    return planes3IntersectSphere3(this.raw, sphere.raw);
  }
  static fromRaw(planes) {
    return new Planes3(planes.map((plane) => Plane3.fromRaw(plane)));
  }
  static fromBox3(box) {
    return Planes3.fromRaw(planes3FromBox3(box.raw));
  }
  static fromProjectionMatrix(matrix) {
    return Planes3.fromRaw(planes3FromProjectionMatrix(matrix.elements));
  }
};

// src/math/sphere3/sphere3ContainsPoint.ts
function sphere3ContainsPoint(sphere, point) {
  return vecLengthSq(vecSub(sphere[0], point)) <= sphere[1] * sphere[1];
}

// src/math/sphere3/Sphere3.ts
var Sphere3 = class {
  constructor(origin = Vector3.zero, radius = 0) {
    this.origin = origin;
    this.radius = radius;
  }
  get raw() {
    return [this.origin.elements, this.radius];
  }
  containsPoint(point) {
    return sphere3ContainsPoint(this.raw, point.elements);
  }
  static fromRaw(sphere) {
    return new Sphere3(new Vector3(sphere[0]), sphere[1]);
  }
};

// src/math/vec4/vec4ApplyMatrix3.ts
function vec4ApplyMatrix3(v, m) {
  const v3 = [v[0], v[1], v[2]];
  const xyz = vec3ApplyMatrix3(v3, m);
  const w = v[3];
  return [xyz[0], xyz[1], xyz[2], w];
}

// src/math/vec4/Vector4.ts
var Vector4 = class extends (/* unused pure expression or super */ null && (Vector)) {
  constructor(v = [0, 0, 0, 0]) {
    super();
    this.elements = v;
  }
  get x() {
    return this.elements[0];
  }
  set x(x) {
    this.elements[0] = x;
  }
  get y() {
    return this.elements[1];
  }
  set y(y) {
    this.elements[1] = y;
  }
  get z() {
    return this.elements[2];
  }
  set z(z) {
    this.elements[2] = z;
  }
  get w() {
    return this.elements[3];
  }
  set w(z) {
    this.elements[3] = z;
  }
  toString() {
    return `Vector4( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)} )`;
  }
  applyMatrix3(matrix) {
    return new Vector4(vec4ApplyMatrix3(this.elements, matrix.elements));
  }
  applyMatrix4(matrix) {
    return new Vector4(vec4ApplyMatrix4(this.elements, matrix.elements));
  }
  __new(v) {
    return new Vector4(v);
  }
  static get zero() {
    return new Vector4([0, 0, 0, 0]);
  }
  static get one() {
    return new Vector4([1, 1, 1, 1]);
  }
};

// src/midi/midiParse.ts
function readU8(array, headBox) {
  return array[headBox[0]++];
}
function readU16(array, headBox) {
  return readU8(array, headBox) * 256 + readU8(array, headBox);
}
function readU32(array, headBox) {
  return readU16(array, headBox) * 65536 + readU16(array, headBox);
}
function readUVar(array, headBox) {
  let v = 0;
  for (; ; ) {
    const vv = readU8(array, headBox);
    v = v * 128 + (vv & 127);
    if (vv < 128) {
      return v;
    }
  }
}
function parseHeader(array, headBox) {
  headBox[0] += 8;
  return [
    readU16(array, headBox),
    readU16(array, headBox),
    readU16(array, headBox)
  ];
}
function parseTrack(array, headBox) {
  headBox[0] += 4;
  const endOfTrack = headBox[0] + readU32(array, headBox) + 4;
  const track = [];
  let type = 0;
  while (headBox[0] < endOfTrack) {
    const delta = readUVar(array, headBox);
    const status = readU8(array, headBox);
    type = status < 128 ? type : status;
    const data0 = status < 128 ? status : readU8(array, headBox);
    if (type < 192) {
      track.push([
        delta,
        type,
        data0,
        readU8(array, headBox)
      ]);
    } else if (type === 255) {
      const eventLength = readU8(array, headBox);
      track.push([
        delta,
        type,
        data0,
        arraySerial(eventLength).map(() => readU8(array, headBox))
      ]);
      if (data0 === 47) {
        break;
      }
    } else {
      throw new Error(`${type}`);
    }
  }
  return track;
}
function midiParse(buffer) {
  const array = new Uint8Array(buffer);
  const headBox = [0];
  const header = parseHeader(array, headBox);
  const tracks = [];
  while (headBox[0] < array.length) {
    tracks.push(parseTrack(array, headBox));
  }
  return [header, tracks];
}

// src/poker/pokerRanksByStrength.ts
var pokerRanksByStrength = (/* unused pure expression or super */ null && ([
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "T",
  "J",
  "Q",
  "K",
  "A"
]));

// src/poker/pokerSuitsByIndex.ts
var pokerSuitsByIndex = (/* unused pure expression or super */ null && ([
  "c",
  "d",
  "h",
  "s"
]));

// src/poker/createPokerDeck.ts
function createPokerDeck() {
  const array = [];
  pokerSuitsByIndex.map((suit) => pokerRanksByStrength.map((rank) => array.push(rank + suit)));
  return array;
}

// src/poker/pokerHandStrengthMap.ts
var pokerHandStrengthMap = {
  "HighCard": 0,
  "OnePair": 1,
  "TwoPair": 2,
  "ThreeOfAKind": 3,
  "Straight": 4,
  "Flush": 5,
  "FullHouse": 6,
  "FourOfAKind": 7,
  "StraightFlush": 8
};

// src/poker/pokerRankStrengthMap.ts
var pokerRankStrengthMap = {
  "2": 0,
  "3": 1,
  "4": 2,
  "5": 3,
  "6": 4,
  "7": 5,
  "8": 6,
  "9": 7,
  "T": 8,
  "J": 9,
  "Q": 10,
  "K": 11,
  "A": 12
};

// src/poker/pokerSuitIndexMap.ts
var pokerSuitIndexMap = {
  "c": 0,
  "d": 1,
  "h": 2,
  "s": 3
};

// src/poker/sortPokerCardsByRank.ts
function sortPokerCardsByRank(cards) {
  return cards.sort((a, b) => pokerSuitIndexMap[a[1]] - pokerSuitIndexMap[b[1]]).sort((a, b) => pokerRankStrengthMap[a[0]] - pokerRankStrengthMap[b[0]]);
}

// src/poker/evaluatePokerHand.ts
function evaluatePokerHand(cards) {
  const cards_ = cards.concat();
  const cardsByRank = new MapOfSet();
  const cardsBySuit = new MapOfSet();
  cards_.map((card) => {
    const rank = card[0];
    const suit = card[1];
    cardsByRank.add(rank, card);
    cardsBySuit.add(suit, card);
  });
  const fours = [];
  const threes = [];
  const twos = [];
  pokerRanksByStrength.map((rank) => {
    const cards2 = cardsByRank.get(rank);
    if (cards2.size > 3) {
      fours.push(rank);
    } else if (cards2.size > 2) {
      threes.push(rank);
    } else if (cards2.size > 1) {
      twos.push(rank);
    }
  });
  let straightCards;
  {
    let current = [];
    const a = Array.from(cardsByRank.get("A"))[0];
    if (a) {
      current.push(a);
    }
    pokerRanksByStrength.map((rank) => {
      const card = Array.from(cardsByRank.get(rank))[0];
      if (card) {
        current.push(card);
        if (current.length > 4) {
          straightCards = current;
        }
      } else {
        current = [];
      }
    });
  }
  if (straightCards) {
    for (const [suit, cardsSet] of cardsBySuit.map) {
      if (cardsSet.size > 0) {
        let straightFlushCards;
        let current = [];
        const target = "A" + suit;
        const a = cardsSet.has(target);
        if (a) {
          current.push(target);
        }
        pokerRanksByStrength.map((rank) => {
          const target2 = rank + suit;
          if (cardsSet.has(target2)) {
            current.push(target2);
            if (current.length > 4) {
              straightFlushCards = current;
            }
          } else {
            current = [];
          }
        });
        if (straightFlushCards) {
          straightFlushCards.splice(0, straightFlushCards.length - 5);
          const hand = "StraightFlush";
          const strength = [
            pokerHandStrengthMap[hand],
            pokerRankStrengthMap[straightFlushCards[4][0]]
          ];
          return {
            hand,
            cards: straightFlushCards,
            strength
          };
        }
      }
    }
  }
  if (fours.length > 0) {
    fours.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    fours.splice(0, fours.length - 1);
    const sameCards = Array.from(cardsByRank.get(fours[0]));
    sameCards.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 1);
    const hand = "FourOfAKind";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[fours[0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...sameCards);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  if (threes.length > 0 && threes.length + twos.length > 1) {
    threes.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    twos.push(...threes.splice(0, threes.length - 1));
    twos.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    twos.splice(0, twos.length - 1);
    const sameCards = Array.from(cardsByRank.get(threes[0]));
    sameCards.push(...Array.from(cardsByRank.get(twos[0])));
    sortPokerCardsByRank(sameCards).splice(0, sameCards.length - 5);
    const hand = "FullHouse";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[threes[0]],
      pokerRankStrengthMap[twos[0]]
    ];
    return {
      hand,
      cards: sameCards,
      strength
    };
  }
  for (const [_suit, cardsSet] of cardsBySuit.map) {
    if (cardsSet.size > 4) {
      const cards2 = sortPokerCardsByRank(Array.from(cardsSet));
      cards2.splice(0, cards2.length - 5);
      const hand = "Flush";
      const strength = [
        pokerHandStrengthMap[hand],
        ...cards2.concat().reverse().map((card) => pokerRankStrengthMap[card[0]])
      ];
      return {
        hand,
        cards: cards2,
        strength
      };
    }
  }
  if (straightCards) {
    straightCards.splice(0, straightCards.length - 5);
    const hand = "Straight";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[straightCards[4][0]]
    ];
    return {
      hand,
      cards: straightCards,
      strength
    };
  }
  if (threes.length > 0) {
    threes.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    threes.splice(0, threes.length - 1);
    const sameCards = Array.from(cardsByRank.get(threes[0]));
    sameCards.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 2);
    const hand = "ThreeOfAKind";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[threes[0]],
      pokerRankStrengthMap[cards_[1][0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...sameCards);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  if (twos.length > 1) {
    twos.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);
    twos.splice(0, twos.length - 2);
    const pairs = Array.from(cardsByRank.get(twos[0]));
    pairs.push(...Array.from(cardsByRank.get(twos[1])));
    pairs.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 1);
    const hand = "TwoPair";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[twos[1]],
      pokerRankStrengthMap[twos[0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...pairs);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  if (twos.length > 0) {
    const pair = Array.from(cardsByRank.get(twos[0]));
    pair.map((card) => cards_.splice(cards_.indexOf(card), 1));
    sortPokerCardsByRank(cards_).splice(0, cards_.length - 3);
    const hand = "OnePair";
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[twos[0]],
      pokerRankStrengthMap[cards_[2][0]],
      pokerRankStrengthMap[cards_[1][0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    cards_.push(...pair);
    sortPokerCardsByRank(cards_);
    return {
      hand,
      cards: cards_,
      strength
    };
  }
  {
    const hand = "HighCard";
    sortPokerCardsByRank(cards_);
    cards_.splice(0, cards_.length - 5);
    const strength = [
      pokerHandStrengthMap[hand],
      pokerRankStrengthMap[cards_[4][0]],
      pokerRankStrengthMap[cards_[3][0]],
      pokerRankStrengthMap[cards_[2][0]],
      pokerRankStrengthMap[cards_[1][0]],
      pokerRankStrengthMap[cards_[0][0]]
    ];
    return {
      hand,
      cards: cards_,
      strength
    };
  }
}

// src/poker/pokerHandsByStrength.ts
var pokerHandsByStrength = (/* unused pure expression or super */ null && ([
  "HighCard",
  "OnePair",
  "TwoPair",
  "ThreeOfAKind",
  "Straight",
  "Flush",
  "FullHouse",
  "FourOfAKind",
  "StraightFlush"
]));

// src/retry/asyncRetry.ts
function asyncRetry(func, n) {
  return __async(this, null, function* () {
    return yield func().catch((error) => {
      if (n <= 1) {
        throw error;
      }
      return asyncRetry(func, n - 1);
    });
  });
}

// src/retry/retry.ts
function retry(func, n) {
  try {
    return func();
  } catch (error) {
    if (n <= 1) {
      throw error;
    }
    return retry(func, n - 1);
  }
}

// src/stniccc/parseSTNICCC.ts
function parseSTNICCC(buffer) {
  const frames = [];
  const array = new Uint8Array(buffer);
  const palette = new Uint16Array(16);
  let head = 0;
  let shouldSkip = false;
  let shouldEnd = false;
  for (; ; ) {
    const flags = array[head++];
    const needsClear = (flags & 1) === 1;
    const hasPalette = (flags >> 1 & 1) === 1;
    const indexedMode = (flags >> 2 & 1) === 1;
    if (hasPalette) {
      const bitmask = array[head++] << 8 | array[head++];
      for (let i = 0; i < 16; i++) {
        if (bitmask >> 15 - i & 1) {
          palette[i] = array[head++] << 8 | array[head++];
        }
      }
    }
    if (indexedMode) {
      const nVertices = array[head++];
      const vertices = array.subarray(head, head + 2 * nVertices);
      head += 2 * nVertices;
      const polygons = [];
      for (; ; ) {
        const descriptor = array[head++];
        if (descriptor === 255) {
          break;
        } else if (descriptor === 254) {
          shouldSkip = true;
          break;
        } else if (descriptor === 253) {
          shouldEnd = true;
          break;
        }
        const colorIndex = descriptor >> 4 & 15;
        const nIndices = descriptor & 15;
        const indices = array.subarray(head, head + nIndices);
        head += nIndices;
        polygons.push({
          colorIndex,
          indices: Array.from(indices)
        });
      }
      frames.push({
        needsClear,
        indexedMode,
        palette: Array.from(palette),
        vertices: Array.from(vertices),
        polygons
      });
    } else {
      const polygons = [];
      for (; ; ) {
        const descriptor = array[head++];
        if (descriptor === 255) {
          break;
        } else if (descriptor === 254) {
          shouldSkip = true;
          break;
        } else if (descriptor === 253) {
          shouldEnd = true;
          break;
        }
        const colorIndex = descriptor >> 4 & 15;
        const nVertices = descriptor & 15;
        const vertices = array.subarray(head, head + 2 * nVertices);
        head += 2 * nVertices;
        polygons.push({
          colorIndex,
          vertices: Array.from(vertices)
        });
      }
      frames.push({
        needsClear,
        indexedMode,
        palette: Array.from(palette),
        polygons
      });
    }
    if (shouldSkip) {
      head = (Math.floor(head / 65536) + 1) * 65536;
      shouldSkip = false;
    }
    if (shouldEnd) {
      break;
    }
  }
  return frames;
}

// src/stniccc/stnicccToSVG.ts
function stnicccToSVG(frames, options = {}) {
  var _a;
  const delta = 1 / ((_a = options == null ? void 0 : options.fps) != null ? _a : 30);
  let svg = '<svg width="256" height="200" viewBox="0 0 256 200" xmlns="http://www.w3.org/2000/svg">';
  let style = `g{visibility:hidden;animation-duration:${(delta * frames.length).toFixed(3)}s;animation-iteration-count:infinite;animation-name:frame}@keyframes frame{0%{visibility:visible}${200 / frames.length}%{visibility:hidden}}`;
  frames.map((frame, iFrame) => {
    const { indexedMode, palette, polygons } = frame;
    style += `#f${iFrame}{animation-delay:${(delta * iFrame).toFixed(3)}s}`;
    const paletteInHex = palette.map((stColor) => {
      const color = colorFromAtariST(stColor);
      return colorToHex(color);
    });
    let childrenStr = '<rect width="256" height="200" fill="#000" />';
    let currentColorIndex = -1;
    let d = "";
    if (indexedMode) {
      const { vertices } = frame;
      polygons.map(({ colorIndex, indices }) => {
        if (currentColorIndex !== colorIndex) {
          if (currentColorIndex !== -1) {
            const colorHex2 = paletteInHex[currentColorIndex];
            childrenStr += `<path d="${d}" fill="${colorHex2}" />`;
          }
          currentColorIndex = colorIndex;
          d = "";
        }
        for (let i = 0; i < indices.length; i++) {
          const index = indices[i];
          const x = vertices[2 * index];
          const y = vertices[2 * index + 1];
          d += i === 0 ? `M${x},${y}` : `L${x},${y}`;
        }
      });
    } else {
      polygons.map(({ colorIndex, vertices }) => {
        if (currentColorIndex !== colorIndex) {
          if (currentColorIndex !== -1) {
            const colorHex2 = paletteInHex[currentColorIndex];
            childrenStr += `<path d="${d}" fill="${colorHex2}" />`;
          }
          currentColorIndex = colorIndex;
          d = "";
        }
        for (let i = 0; i < vertices.length; i += 2) {
          const x = vertices[i];
          const y = vertices[i + 1];
          d += i === 0 ? `M${x},${y}` : `L${x},${y}`;
        }
      });
    }
    const colorHex = paletteInHex[currentColorIndex];
    childrenStr += `<path d="${d}" fill="${colorHex}" />`;
    svg += `<g id="f${iFrame}">${childrenStr}</g>`;
  });
  svg += `<style>${style}</style></svg>`;
  return svg;
}

// src/SmoothDamp/SmoothDamp.ts
var SmoothDamp = class {
  constructor() {
    this.smoothTime = 1;
    this.velocity = 0;
    this.value = 0;
    this.target = 0;
  }
  update(deltaTime) {
    const omega = 2 / this.smoothTime;
    const x = omega * deltaTime;
    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
    const delta = this.value - this.target;
    const temp = (this.velocity + omega * delta) * deltaTime;
    this.velocity = (this.velocity - omega * temp) * exp;
    this.value = this.target + (delta + temp) * exp;
    return this.value;
  }
};

// src/Swap/Swap.ts
var Swap = class {
  constructor(a, b) {
    this.i = a;
    this.o = b;
  }
  swap() {
    const i = this.i;
    this.i = this.o;
    this.o = i;
  }
};

// src/TapTempo/TapTempo.ts
var TapTempo = class {
  constructor() {
    this.__bpm = 0;
    this.__lastTap = 0;
    this.__lastBeat = 0;
    this.__lastTime = 0;
    this.__calc = new HistoryMeanCalculator(16);
  }
  get beatDuration() {
    return 60 / this.__bpm;
  }
  get bpm() {
    return this.__bpm;
  }
  set bpm(bpm) {
    this.__lastBeat = this.beat;
    this.__lastTime = performance.now();
    this.__bpm = bpm;
  }
  get beat() {
    return this.__lastBeat + (performance.now() - this.__lastTime) * 1e-3 / this.beatDuration;
  }
  reset() {
    this.__calc.reset();
  }
  nudge(amount) {
    this.__lastBeat = this.beat + amount;
    this.__lastTime = performance.now();
  }
  tap() {
    const now = performance.now();
    const delta = (now - this.__lastTap) * 1e-3;
    if (2 < delta) {
      this.reset();
    } else {
      this.__calc.push(delta);
      this.__bpm = 60 / this.__calc.mean;
    }
    this.__lastTap = now;
    this.__lastTime = now;
    this.__lastBeat = 0;
  }
};

// src/tinyseq/createTinyseqPolyReader.ts
function createTinyseqPolyReader(buffer, options = {}) {
  var _a, _b, _c, _d;
  const poly = (_a = options.poly) != null ? _a : 8;
  const blockSize = (_b = options.blockSize) != null ? _b : 128;
  const sampleRate = (_c = options.sampleRate) != null ? _c : 48e3;
  const stepsPerSecond = (_d = options.stepsPerSecond) != null ? _d : 1;
  let samples = 0;
  let pos = 0;
  let note;
  const notes = arraySerial(poly).fill(-1);
  const notesTime = arraySerial(poly).fill(-Infinity);
  const notesOffTime = arraySerial(poly).fill(-Infinity);
  let nextStep = 0;
  return () => {
    const ret = arraySerial(poly).map(() => new Float32Array(4 * blockSize));
    arraySerial(blockSize).map((iSample) => {
      const t = samples / sampleRate;
      const s = t * stepsPerSecond;
      if (s >= nextStep) {
        const eventNote = buffer[pos];
        const eventDeltaStep = buffer[pos + 1];
        note = (pos === 0 ? 60 : note) + eventNote & 127;
        let iPoly = notes.indexOf(note);
        let tEarliest = Infinity;
        if (iPoly === -1) {
          notesTime.map((tOn, jPoly) => {
            const tOff = notesOffTime[jPoly];
            if (tOn <= tOff) {
              if (tOff < tEarliest) {
                iPoly = jPoly;
                tEarliest = tOff;
              }
            }
          });
        }
        if (iPoly === -1) {
          notesTime.map((tOn, jPoly) => {
            if (tOn < tEarliest) {
              iPoly = jPoly;
              tEarliest = tOn;
            }
          });
        }
        notes[iPoly] = note;
        if (eventNote & 128) {
          if (notesOffTime[iPoly] < notesTime[iPoly]) {
            notesOffTime[iPoly] = t;
          }
        } else {
          if (notesOffTime[iPoly] >= notesTime[iPoly]) {
            notesTime[iPoly] = t;
          }
        }
        nextStep += eventDeltaStep;
        pos = (pos + 2) % buffer.length;
      }
      samples++;
      arraySerial(poly).map((iPoly) => {
        const noteTime = notesTime[iPoly];
        const noteOffTime = notesOffTime[iPoly];
        ret[iPoly][4 * iSample + 0] = t - noteTime;
        ret[iPoly][4 * iSample + 1] = noteOffTime < noteTime ? 0 : t - noteOffTime;
        ret[iPoly][4 * iSample + 2] = notes[iPoly];
        ret[iPoly][4 * iSample + 3] = 0;
      });
    });
    return ret;
  };
}

// src/tinyseq/createTinyseqReader.ts
function createTinyseqReader(buffer, options = {}) {
  var _a, _b, _c;
  const blockSize = (_a = options.blockSize) != null ? _a : 128;
  const sampleRate = (_b = options.sampleRate) != null ? _b : 48e3;
  const stepsPerSecond = (_c = options.stepsPerSecond) != null ? _c : 960;
  let samples = 0;
  let pos = 0;
  let note;
  let noteTime = -Infinity;
  let noteOffTime = -Infinity;
  let nextStep = 0;
  return () => {
    return new Float32Array(arraySerial(blockSize).map(() => {
      const t = samples / sampleRate;
      const s = t * stepsPerSecond;
      if (s >= nextStep) {
        const eventNote = buffer[pos];
        const eventDeltaStep = buffer[pos + 1];
        note = (pos === 0 ? 60 : note) + eventNote & 127;
        if (eventNote & 128) {
          if (noteOffTime < noteTime) {
            noteOffTime = t;
          }
        } else {
          if (noteOffTime >= noteTime) {
            noteTime = t;
          }
        }
        nextStep += eventDeltaStep;
        pos = (pos + 2) % buffer.length;
      }
      samples++;
      return [
        t - noteTime,
        noteOffTime < noteTime ? 0 : t - noteOffTime,
        note,
        0
      ];
    }).flat());
  };
}

// src/tinyseq/tinyseqFromMidiParseResult.ts
function tinyseqFromMidiParseResult(midi, { track, tickMultiplier } = {}) {
  const data = [];
  let lastNote = 60;
  let delta = 0;
  const trackEvents = midi[1][track != null ? track : 0];
  arraySerial(trackEvents.length + 1).map((i) => {
    var _a, _b, _c, _d, _e, _f;
    delta += ((_b = (_a = trackEvents[i]) == null ? void 0 : _a[0]) != null ? _b : 0) * (tickMultiplier != null ? tickMultiplier : 1);
    if (delta === 0 && i === 0) {
      return;
    }
    const evMsg = (_d = (_c = trackEvents[i - 1]) == null ? void 0 : _c[1]) != null ? _d : 128;
    const evNote = (_f = (_e = trackEvents[i - 1]) == null ? void 0 : _e[2]) != null ? _f : 60;
    if (evMsg >= 160) {
      return;
    }
    const noteDelta = evNote - lastNote + 128 & 127;
    lastNote = evNote;
    const onoff = evMsg < 144 ? 128 : 0;
    let deltaConsume = Math.floor(Math.min(delta, 240));
    data.push(noteDelta + onoff, deltaConsume);
    delta -= deltaConsume;
    while (delta >= 1) {
      deltaConsume = Math.floor(Math.min(delta, 240));
      data.push(onoff, deltaConsume);
      delta -= deltaConsume;
    }
  });
  return new Uint8Array(data);
}

// src/Xorshift/Xorshift.ts
var Xorshift = class {
  constructor(seed) {
    this.seed = seed || 1;
  }
  gen(seed) {
    if (seed) {
      this.seed = seed;
    }
    this.seed = this.seed ^ this.seed << 13;
    this.seed = this.seed ^ this.seed >>> 17;
    this.seed = this.seed ^ this.seed << 5;
    return this.seed / Math.pow(2, 32) + 0.5;
  }
  set(seed) {
    this.seed = seed || this.seed || 1;
  }
};

// src/yugop/getYugopText.ts
function getYugopText(text, phase, randomRatio = 0.5) {
  if (phase >= 1) {
    return text;
  }
  if (phase < 0) {
    return "";
  }
  const displayTween = linearstep(0, 1 - randomRatio, phase);
  const fixTween = linearstep(randomRatio, 1, phase);
  const displayLength = 1 + Math.floor(displayTween * (text.length - 1));
  const fixLength = phase < randomRatio ? 0 : 1 + Math.floor(fixTween * (text.length - 1));
  const randomLength = displayLength - fixLength;
  const randomStr = [...Array(randomLength)].map(() => String.fromCharCode(33 + Math.floor(93 * Math.random()))).join("");
  return text.substring(0, fixLength) + randomStr;
}

// src/BinaryHeap.ts
var BinaryHeap = class {
  static defaultComparator(a, b) {
    const aStr = `${a}`;
    const bStr = `${b}`;
    if (aStr > bStr) {
      return 1;
    } else if (aStr < bStr) {
      return -1;
    } else {
      return 0;
    }
  }
  get length() {
    return this.array.length;
  }
  get isEmpty() {
    return this.array.length === 0;
  }
  get root() {
    return this.array[0];
  }
  constructor(init, comparator) {
    this.array = [];
    this.elementIndexMap = /* @__PURE__ */ new Map();
    this.comparator = comparator != null ? comparator : BinaryHeap.defaultComparator;
    if (init != null) {
      for (const el of init) {
        this.push(el);
      }
    }
  }
  push(...elements) {
    elements.map((el) => {
      const i = this.length;
      this.array.push(el);
      this.elementIndexMap.set(el, i);
      this.__up(i, el);
    });
  }
  pop() {
    if (this.isEmpty) {
      return null;
    }
    const el = this.array[0];
    this.elementIndexMap.delete(el);
    if (this.length === 1) {
      this.array.splice(0);
    } else {
      const rep = this.array.pop();
      this.__down(0, rep);
    }
    return el;
  }
  delete(i) {
    this.elementIndexMap.delete(this.array[i]);
    const rep = this.array.pop();
    if (rep != null) {
      i = this.__up(i, rep);
      i = this.__down(i, rep);
    }
    return true;
  }
  replace(i, rep) {
    if (i != null) {
      this.elementIndexMap.delete(this.array[i]);
      i = this.__up(i, rep);
      i = this.__down(i, rep);
    }
    return i != null ? i : null;
  }
  __up(i, el) {
    let ic = i;
    while (ic !== 0) {
      const ip = ic - 1 >> 1;
      const p = this.array[ip];
      if (this.comparator(el, p) < 0) {
        this.array[ic] = p;
        this.elementIndexMap.set(p, ic);
        ic = ip;
      } else {
        break;
      }
    }
    this.array[ic] = el;
    this.elementIndexMap.set(el, ic);
    return ic;
  }
  __down(i, el) {
    let ip = i;
    while ((ip << 1) + 1 < this.length) {
      const ic1 = (ip << 1) + 1;
      const ic2 = (ip << 1) + 2;
      if (ic2 < this.length) {
        const c1 = this.array[ic1];
        const c2 = this.array[ic2];
        const pickLeft = this.comparator(c1, c2) < 0;
        const c = pickLeft ? c1 : c2;
        const ic = pickLeft ? ic1 : ic2;
        if (this.comparator(c, el) < 0) {
          this.array[ip] = c;
          this.elementIndexMap.set(c, ip);
          ip = ic;
        } else {
          break;
        }
      } else if (this.comparator(this.array[ic1], el) < 0) {
        this.array[ip] = this.array[ic1];
        this.elementIndexMap.set(this.array[ip], ip);
        ip = ic1;
      } else {
        break;
      }
    }
    this.array[ip] = el;
    this.elementIndexMap.set(el, ip);
    return ip;
  }
};

// src/notifyObservers.ts
function notifyObservers(observers, param) {
  for (const observer of observers) {
    observer(param);
  }
}

/*!
 * Turbo colormap
 *
 * Copyright 2019 Google LLC. (Apache-2.0)
 *
 * https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7
 */

;// CONCATENATED MODULE: ./src/wmath.ts

function fract(a) {
    return _0b5vr_experimental_esm_mod(a, 1);
}
const tau = Math.PI * 2.0;
const pi = Math.PI;
const halfPi = Math.PI / 2;
function max(a, b) {
    return Math.max(a, b);
}
function min(a, b) {
    return Math.min(a, b);
}
function mix(a, b, f) {
    return a * (1.0 - f) + b * f;
}
function log(a) {
    return Math.log(a);
}
function log2(a) {
    return Math.log2(a);
}
class Hash {
    seed = 0;
    constructor(seed = 1251254) {
        Hash.seed = seed;
    }
    static h11(p) {
        p = fract(p * 0.1031);
        p *= p + 33.33;
        p *= p + p;
        return fract(p);
    }
    h11(p) {
        return this.seeded(125124 + p * 1250);
    }
    seeded(a) {
        var t = (a += 0x6d2b79f5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
    valueNoise(a) {
        const fla = floor(a);
        const ceila = fla + 1;
        const rcurr = Hash.h11(fla);
        const rnext = Hash.h11(ceila);
        let fr = fract(a);
        fr = wmath_smoothstep(0, 1, fr);
        return wmath_lerp(rcurr, rnext, fr);
    }
    valueNoiseSmooth(a, smoothness) {
        const fla = floor(a);
        const ceila = fla + 1;
        const rcurr = this.h11(fla);
        const rnext = this.h11(ceila);
        let fr = fract(a);
        for (let i = 0; i < smoothness; i++) {
            if (floor(i) === floor(smoothness)) {
                fr = wmath_lerp(fr, wmath_smoothstep(0, 1, fr), smoothness - i);
                break;
            }
            else {
                fr = wmath_smoothstep(0, 1, fr);
            }
        }
        return wmath_lerp(rcurr, rnext, fr);
    }
}
const r2pi = 0.63661977236;
const nkingSin = (x) => {
    const xtau = x * tau;
    if (xtau - Math.floor(xtau) > pi) {
        const mod = (x - pi) * r2pi - 1;
        return mod * mod - 1;
    }
    else {
        const mod = x * r2pi - 1;
        return 1 - mod * mod;
    }
};
const smoothsin = (x) => {
    const b = x * x * (3.0 - 2.0 * x);
    const a = x * (3 - 1.0 * x);
    return a + (b - a) * b;
};
const oneOverHalfPi = 1 / (pi / 2);
const fastSin = (x) => {
    x *= oneOverHalfPi;
    const id = Math.floor(x);
    x = x % 1;
    let side = 1;
    if ((id - 2) % 4 < 2) {
        side = -1;
    }
    if (id % 2 === 1) {
        x = 1 - x;
    }
    let approx = smoothsin(x);
    approx *= side;
    return approx;
};
function quantize(a, b) {
    return Math.floor(a / b) * b;
}
function dmod(a, b, c = 2) {
    return max(mod(a, b) - b + 2, 0);
}
function abs(a) {
    return Math.abs(a);
}
function sign(a) {
    return a < 0 ? -1 : 1;
}
function tri(a) {
    const fr = a - Math.floor(a);
    return abs(fr - 0.5) * 2 - 1;
}
function sin(a) {
    return Math.sin(a);
}
function cos(a) {
    return Math.cos(a);
}
function floor(a) {
    return Math.floor(a);
}
function pow(a, b) {
    return Math.pow(a, b);
}
function sqrt(a) {
    return Math.sqrt(a);
}
function wrap(a, from, to) {
    const range = to - from;
    a -= from;
    a = mod(a, range);
    return from + a;
}
const wmath_lerp = (a, b, x) => a + (b - a) * x;
const wmath_clamp = (x, l, h) => Math.min(Math.max(x, l), h);
const wmath_saturate = (x) => Math.min(Math.max(x, 0.0), 1.0);
const wmath_linearstep = (a, b, x) => wmath_saturate((x - a) / (b - a));
const wmath_smoothstep = (a, b, x) => {
    const t = wmath_linearstep(a, b, x);
    return t * t * (3.0 - 2.0 * t);
};
function rand() {
    return Math.random();
}
class Ease {
    static linear(t) {
        ;
        (t) => t;
    }
    static easeInQuad(t) {
        return t * t;
    }
    static easeOutQuad(t) {
        return t * (2 - t);
    }
    static easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    static easeInCubic(t) {
        return t * t * t;
    }
    static easeOutCubic(t) {
        return --t * t * t + 1;
    }
    static easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }
    static easeInQuart(t) {
        return t * t * t * t;
    }
    static easeOutQuart(t) {
        return 1 - --t * t * t * t;
    }
    static easeInOutQuart(t) {
        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    }
    static easeInQuint(t) {
        return t * t * t * t * t;
    }
    static easeOutQuint(t) {
        return 1 + --t * t * t * t * t;
    }
    static easeInOutQuint(t) {
        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
    static easeInElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
    }
    static easeOutElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }
}
class WMath {
    static macos(x) {
        return Math.acos(x);
    }
    static masin(x) {
        return Math.asin(x);
    }
    static matan(y, x) {
        return Math.atan2(y, x);
    }
    static mcos(x) {
        return Math.cos(x);
    }
    static msin(x) {
        return Math.sin(x);
    }
    static cos2(x) {
        return [Math.cos(x[0]), Math.cos(x[1])];
    }
    static cos3(x) {
        return [Math.cos(x[0]), Math.cos(x[1]), Math.cos(x[2])];
    }
    static sin2(x) {
        return [Math.sin(x[0]), Math.sin(x[1])];
    }
    static sin3(x) {
        return [Math.sin(x[0]), Math.sin(x[1]), Math.sin(x[2])];
    }
    static sin4(x) {
        return [Math.sin(x[0]), Math.sin(x[1]), Math.sin(x[2]), Math.sin(x[3])];
    }
    static SC(x) {
        return [Math.sin(x), Math.cos(x)];
    }
    static add2(a, b) {
        return [a[0] + b[0], a[1] + b[1]];
    }
    static add3(a, b) {
        return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
    }
    static add31(a, b) {
        return [a[0] + b, a[1] + b, a[2] + b];
    }
    static add4(a, b) {
        return [a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3]];
    }
    static sub3(a, b) {
        return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }
    static sub2(a, b) {
        return [a[0] - b[0], a[1] - b[1]];
    }
    static dot3(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    static abs3(a) {
        return [a[0] > 0 ? a[0] : -a[0], a[1] > 0 ? a[1] : -a[1], a[2] > 0 ? a[2] : -a[2]];
    }
    static scale2(a, b) {
        return [a[0] * b, a[1] * b];
    }
    static scale3(a, b) {
        return [a[0] * b, a[1] * b, a[2] * b];
    }
    static scale4(a, b) {
        return [a[0] * b, a[1] * b, a[2] * b, a[3] * b];
    }
    static mul3(a, b) {
        return [a[0] * b[0], a[1] * b[1], a[2] * b[2]];
    }
    static mul4(a, b) {
        return [a[0] * b[0], a[1] * b[1], a[2] * b[2], a[3] * b[3]];
    }
    static mymix(a, b, f) {
        return a * (1.0 - f) + b * f;
    }
    static mymix22(a, b, f) {
        return [a[0] * (1.0 - f[0]) + b[0] * f[0], a[1] * (1.0 - f[1]) + b[1] * f[1]];
    }
    static mix1(a, b, f) {
        return a * (1.0 - f) + b * f;
    }
    static mix3(a, b, f) {
        return add3(scale3(a, 1.0 - f), scale3(b, f));
    }
    static length2(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
    }
    static length3(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    }
    static length4(a) {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3]);
    }
    static normalize3(a) {
        return scale3(a, 1.0 / length3(a));
    }
    static normalize4(a) {
        return scale4(a, 1.0 / length4(a));
    }
    static cross(a, b) {
        return [a[1] * b[2] - b[1] * a[2], a[2] * b[0] - b[2] * a[0], a[0] * b[1] - b[0] * a[1]];
    }
    G = 0.5 + Math.sqrt(5 / 4);
    static fract1(a) {
        return a - Math.floor(a);
    }
    static floor2(a) {
        return [Math.floor(a[0]), Math.floor(a[1])];
    }
    static fract2(a) {
        return [fract1(a[0]), fract1(a[1])];
    }
    static fract3(a) {
        return [fract1(a[0]), fract1(a[1]), fract1(a[2])];
    }
    static fract4(a) {
        return [fract1(a[0]), fract1(a[1]), fract1(a[2]), fract1(a[3])];
    }
    static clamp1(a, a1, a2) {
        return a < a1 ? a1 : a > a2 ? a2 : a;
    }
    static clamp31(a, a1, a2) {
        return [clamp1(a[0], a1, a2), clamp1(a[1], a1, a2), clamp1(a[2], a1, a2)];
    }
    static rotX(ph, v) {
        return [v[0], v[1] * mcos(ph) + v[2] * msin(ph), v[2] * mcos(ph) - v[1] * msin(ph)];
    }
    static rotY(ph, v) {
        return [v[0] * mcos(ph) + v[2] * msin(ph), v[1], v[2] * mcos(ph) - v[0] * msin(ph)];
    }
    static rotZ(ph, v) {
        return [v[0] * mcos(ph) + v[1] * msin(ph), v[1] * mcos(ph) - v[0] * msin(ph), v[2]];
    }
    static hsv2rgb(c) {
        var K = [1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0];
        var p = abs3(sub3(scale3(fract3(add3([c[0], c[0], c[0]], K)), 6.0), [3, 3, 3]));
        return scale3(mix3([1, 1, 1], clamp31(sub3(p, [1, 1, 1]), 0.0, 1.0), c[1]), c[2]);
    }
}

;// CONCATENATED MODULE: ./src/gl/Texture.ts



class Texture {
    tex;
    internal_format;
    format;
    type;
    res;
    is_float;
    mipmapped;
    mip_levels;
    constructor(res, internal_format = gl.RGBA, mipmapped = false, mip_levels = 0) {
        const eq_any = (a, b) => {
            let eq = false;
            b.forEach((b) => {
                if (b === a) {
                    eq = true;
                }
            });
            return eq;
        };
        this.res = [...res];
        this.internal_format = internal_format;
        this.mipmapped = mipmapped;
        this.mip_levels = mip_levels;
        this.is_float = eq_any(internal_format, [gl.RGBA32F, gl.RGBA16F, gl.RGB16F, gl.RGB32F]);
        let comp_cnt = 4;
        if (eq_any(internal_format, [gl.RGBA32F, gl.RGBA16F, gl.RGBA, gl.RGBA16I, gl.RGBA16UI, gl.RGBA32I, gl.RGBA8I, gl.RGBA8UI])) {
            comp_cnt = 4;
        }
        if (eq_any(internal_format, [gl.RGB32F, gl.RGB16F, gl.RGB, gl.RGB16I, gl.RGB16UI, gl.RGB32I, gl.RGB8I, gl.RGB8UI])) {
            comp_cnt = 3;
        }
        this.format = comp_cnt === 4 ? gl.RGBA : gl.RGB;
        this.type = this.is_float ? gl.FLOAT : gl.UNSIGNED_BYTE;
        if (eq_any(internal_format, [gl.RGBA8UI, gl.RGBA16UI, gl.RGBA32UI, gl.RGB8UI, gl.RGB16UI, gl.RGB32UI])) {
            this.type = gl.UNSIGNED_INT;
        }
        if (eq_any(internal_format, [gl.RGBA8I, gl.RGBA16I, gl.RGBA32I, gl.RGB8I, gl.RGB16I, gl.RGB32I])) {
            this.type = gl.INT;
        }
        this.recreate();
    }
    recreate() {
        if (this.tex) {
            gl.deleteTexture(this.tex);
        }
        this.tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
        if (this.is_float) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }
        else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (this.mipmapped) {
            if (this.mip_levels === 0) {
                if (this.res[0] > 4 && this.res[1] > 4) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texStorage2D(gl.TEXTURE_2D, log2(min(this.res[0], this.res[1])), this.internal_format, this.res[0], this.res[1]);
                }
                else {
                    gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, null);
                }
            }
            pause_on_gl_error();
        }
        else {
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, null);
        }
        if (!gl.isTexture(this.tex)) {
            console.error('TEXTURE INCOMPLETE');
        }
    }
    resize(new_res) {
        this.res = [...new_res];
        if (this.mipmapped) {
            gl.deleteTexture(this.tex);
            this.recreate();
        }
        else {
            gl.activeTexture(gl.TEXTURE15);
            gl.bindTexture(gl.TEXTURE_2D, this.tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, null);
        }
    }
    static async from_image_path(img_path) {
        function loadImage(url) {
            return new Promise((resolve) => {
                const image = new Image();
                image.crossOrigin = 'anonymous';
                image.addEventListener('load', () => {
                    resolve(image);
                });
                image.src = url;
            });
        }
        const img = await loadImage(img_path);
        const tex = new Texture([img.naturalWidth, img.naturalHeight], gl.RGBA8, true, 0);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, tex.res[0], tex.res[1], tex.format, tex.type, img);
        gl.generateMipmap(gl.TEXTURE_2D);
        pause_on_gl_error();
        gl.finish();
        img.remove();
        return tex;
    }
    upload_from_cpu(image) {
        if (image instanceof HTMLImageElement) {
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internal_format, this.res[0], this.res[1], 0, this.format, this.type, image);
        }
        else {
            debugger;
        }
    }
    clone() {
        return new Texture(this.res, this.internal_format, this.mipmapped, this.mip_levels);
    }
    bind_to_unit(unit) {
        gl.activeTexture(gl.TEXTURE0 + unit);
        gl.bindTexture(gl.TEXTURE_2D, this.tex);
    }
    read_back_array(offs = [0, 0], read_back_res = [...this.res]) {
        let temp_fb = gl.createFramebuffer();
        let prev_bound_fb = Framebuffer.currently_bound;
        gl.bindFramebuffer(gl.FRAMEBUFFER, temp_fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.tex, 0);
        const data = this.is_float
            ? new Float32Array(read_back_res[0] * read_back_res[1] * 4)
            : new Uint8Array(read_back_res[0] * read_back_res[1] * 4);
        gl.readPixels(offs[0], offs[1], read_back_res[0], read_back_res[1], this.format, this.type, data);
        gl.deleteFramebuffer(temp_fb);
        gl.bindFramebuffer(gl.FRAMEBUFFER, prev_bound_fb.fb);
        return data;
    }
    read_back_pixel(offs) {
        let data = this.read_back_array(offs, [1, 1]);
        if (this.is_float) {
            data.forEach((e, i, a) => {
                a[i] *= 255;
            });
        }
        data[3] = 255;
        return Array.from(data);
    }
    async read_back_image(gamma_correct = false, offs = [0, 0], read_back_res = [...this.res]) {
        let data = this.read_back_array(offs, read_back_res);
        let data_reflected = new Float32Array(data.length);
        let i = 0;
        let idx = 0;
        for (let pixel of data) {
            if (i === 3) {
                if (this.is_float) {
                    data[idx] = 255;
                }
                else {
                    data[idx] = 255;
                }
                i = -1;
            }
            else {
                if (gamma_correct) {
                    if (this.is_float) {
                        data[idx] = 255 * pow(data[idx], 0.4545454545);
                    }
                    else {
                        data[idx] = 255 * pow(data[idx] / 255, 0.4545454545);
                    }
                }
            }
            idx++;
            i++;
        }
        for (let y = 0; y < read_back_res[1]; y++) {
            for (let x = 0; x < read_back_res[0]; x++) {
                const idx = y * read_back_res[0] * 4 + x * 4;
                const idx_refl = (read_back_res[1] - y - 1) * read_back_res[0] * 4 + x * 4;
                data_reflected[idx + 0] = data[idx_refl];
                data_reflected[idx + 1] = data[idx_refl + 1];
                data_reflected[idx + 2] = data[idx_refl + 2];
                data_reflected[idx + 3] = data[idx_refl + 3];
            }
        }
        const canvas = document.createElement('canvas');
        canvas.width = this.res[0];
        canvas.height = this.res[1];
        const context = canvas.getContext('2d');
        let blob;
        const getCanvasBlob = (canvas) => {
            return new Promise(function (resolve, reject) {
                canvas.toBlob(function (blob) {
                    resolve(blob);
                }, 'image/png');
            });
        };
        blob = await getCanvasBlob(canvas);
        const imageData = context.createImageData(canvas.width, canvas.height);
        imageData.data.set(data_reflected);
        context.putImageData(imageData, 0, 0);
        const img = new Image();
        img.src = canvas.toDataURL();
        canvas.remove();
        return [img, blob];
    }
}

;// CONCATENATED MODULE: ./src/gl/Framebuffer.ts

class Framebuffer {
    static currently_bound;
    static framebuffers = [];
    _textures;
    _back_textures;
    _fb;
    _fb_back = undefined;
    default = false;
    pongable = false;
    needs_pong = false;
    pong_idx = 0;
    get textures() {
        if (this.pong_idx === 0)
            return this._textures;
        else
            return this._back_textures;
    }
    get back_textures() {
        if (this.pong_idx === 0)
            return this._back_textures;
        else
            return this._textures;
    }
    get fb() {
        if (this.pong_idx === 0)
            return this._fb;
        else
            return this._fb_back;
    }
    get fb_back() {
        if (this.pong_idx === 0)
            return this._fb_back;
        else
            return this._fb;
    }
    pong() {
        this.pong_idx = 1 - this.pong_idx;
        this.needs_pong = false;
    }
    recreate() {
        if (this.pongable) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fb_back);
            let i = 0;
            for (let tex of this._back_textures) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, tex.tex, 0);
            }
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                console.error('FRAMEBUFFER INCOMPLETE');
            }
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fb);
        let i = 0;
        for (let tex of this._textures) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, tex.tex, 0);
            i++;
        }
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
            console.error('FRAMEBUFFER INCOMPLETE');
        }
    }
    constructor(textures, pongable = false) {
        this._fb = gl.createFramebuffer();
        this._textures = [...textures];
        this.pongable = pongable;
        this._back_textures = [];
        if (this.pongable) {
            this._fb_back = gl.createFramebuffer();
            for (let tex of this.textures) {
                this._back_textures.push(tex.clone());
            }
        }
        this.recreate();
        gl.bindFramebuffer(gl.FRAMEBUFFER, Framebuffer.currently_bound._fb);
        Framebuffer.framebuffers.push(this);
    }
    bind() {
        if (this.pongable)
            this.needs_pong = true;
        let draw_buffs = [];
        if (this.default) {
            draw_buffs = [gl.BACK];
        }
        else {
            let i = 0;
            for (let tex of this.textures) {
                draw_buffs.push(gl.COLOR_ATTACHMENT0 + i);
                i++;
            }
        }
        gl.viewport(0, 0, this.textures[0].res[0], this.textures[0].res[1]);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);
        Framebuffer.currently_bound = this;
    }
    clear(colour = [0, 0, 0, 0]) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb);
        gl.clearColor(colour[0], colour[1], colour[2], colour[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindFramebuffer(gl.FRAMEBUFFER, Framebuffer.currently_bound.fb);
    }
}

;// CONCATENATED MODULE: ./src/gl_utils.ts


function init_gl_error_handling() {
    if (!gl.debugEnabled)
        return;
    gl.glEnums = {};
    gl.enumStringToValue = {};
    for (let propertyName in gl) {
        if (typeof gl[propertyName] === 'number') {
            gl.glEnums[gl[propertyName]] = propertyName;
            gl.enumStringToValue[propertyName] = gl[propertyName];
        }
    }
}
function gl_enum_to_string(value) {
    const name = window.gl.glEnums[value];
    return name !== undefined ? 'gl.' + name : '/*UNKNOWN WebGL ENUM*/ 0x' + value.toString(16) + '';
}
function print_on_gl_error() {
    if (!gl.debugEnabled)
        return;
    let err = window.gl.getError();
    if (err !== 0) {
        console.error(err);
        console.error(gl_enum_to_string(err));
    }
}
function pause_on_gl_error() {
    if (!gl.debugEnabled)
        return;
    let err = window.gl.getError();
    if (err !== 0) {
        console.error(err);
        console.error(gl_enum_to_string(err));
        debugger;
    }
}
function copy_fb_to_texture(in_framebuffer, out_texture) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, in_framebuffer);
    gl.bindTexture(gl.TEXTURE_2D, out_texture.tex);
    gl.copyTexImage2D(gl.TEXTURE_2D, 0, out_texture.internal_format, 0, 0, out_texture.res[0], out_texture.res[1], 0);
}
function copy_fb_to_fb(in_framebuffer, out_framebuffer, res) {
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, in_framebuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, out_framebuffer);
    gl.blitFramebuffer(0, 0, res[0], res[1], 0, 0, res[0], res[1], gl.COLOR_BUFFER_BIT, gl.NEAREST);
}
function resizeIfNeeded(canvas, default_framebuffer, client_res) {
    const displayWidth = canvas.clientWidth;
    const displayHeight = canvas.clientHeight;
    const needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;
    if (needResize) {
        client_res[0] = canvas.width = displayWidth;
        client_res[1] = canvas.height = displayHeight;
        default_framebuffer._textures[0].res = [...client_res];
        for (let fb of Framebuffer.framebuffers) {
            if (fb.default) {
                continue;
            }
            for (let tex of fb._textures) {
                tex.resize(client_res);
            }
            for (let tex of fb._back_textures) {
                tex.resize(client_res);
            }
            fb.recreate();
        }
    }
    return needResize;
}

;// CONCATENATED MODULE: ./src/gl/ShaderProgram.ts

class ShaderProgram {
    program;
    loadShader(type, source) {
        source = source.replaceAll('export default "', ``);
        source = source.replaceAll('";', ``);
        source = source.replaceAll('"', ``);
        source = source.replaceAll(`\\n`, `
		`);
        source = source.replace(/(.*)(#version 300 es)[\t\s]*/g, `$2
			`);
        source = source.replaceAll(/(#define .+)[\t\s]*/g, `
		$1
		`);
        source = source.replaceAll(/	+precision highp float;/gm, `precision highp float;
			`);
        source = source.replaceAll(`\\t`, `	`);
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(`An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`);
            console.error(source);
        }
        return shader;
    }
    constructor(vs, fs) {
        const vertexShader = this.loadShader(gl.VERTEX_SHADER, vs);
        const fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fs);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error(`Unable to initialize the shader program: ${gl.getProgramInfoLog(shaderProgram)}`);
            console.error(vs);
            console.error(fs);
        }
        this.program = shaderProgram;
        gl.useProgram(this.program);
        gl.uniformBlockBinding(this.program, 0, 0);
    }
    use() {
        gl.useProgram(this.program);
    }
    setUniformVec(name, vec) {
        if (vec.length == 2)
            gl.uniform2fv(gl.getUniformLocation(this.program, name), vec);
        else if (vec.length == 3)
            gl.uniform3fv(gl.getUniformLocation(this.program, name), vec);
        else if (vec.length == 4)
            gl.uniform4fv(gl.getUniformLocation(this.program, name), vec);
    }
    setUniformFloat(name, value) {
        gl.uniform1f(gl.getUniformLocation(this.program, name), value);
    }
    setUniformInt(name, value) {
        gl.uniform1i(gl.getUniformLocation(this.program, name), value);
    }
    setUniformTexture(name, texture, binding = 0) {
        gl.activeTexture(gl.TEXTURE0 + binding);
        gl.bindTexture(gl.TEXTURE_2D, texture.tex);
        gl.uniform1i(gl.getUniformLocation(this.program, name), binding);
    }
}

;// CONCATENATED MODULE: ./src/gl/Thing.ts


class Thing {
    vao;
    buffs;
    shader;
    prim_type;
    constructor(buffs, prim_type = gl.TRIANGLES, shader) {
        this.prim_type = prim_type;
        this.shader = shader;
        this.vao = gl.createVertexArray();
        this.buffs = [...buffs];
        gl.bindVertexArray(this.vao);
        let i = 0;
        for (let buff of this.buffs) {
            gl.enableVertexAttribArray(i);
            buff.bindToAttrib(i);
            i++;
        }
    }
    static draw_external_buffs_and_shader(buffs, shader, params) {
        shader.use();
        let i = 0;
        params.prim_type = params.prim_type ?? gl.TRIANGLES;
        params.draw_cnt = params.draw_cnt ?? buffs[0].buff.sz / buffs[0].buff.single_vert_sz;
        if (params.prim_type === gl.TRIANGLES) {
            gl.drawArrays(gl.TRIANGLES, 0, params.draw_cnt);
            console.log('DREW');
            console.log(params.draw_cnt);
        }
        else {
            alert('bleep bloop errrorrr');
        }
    }
    upload_all_buffs() {
        for (let buff of this.buffs) {
            buff.upload();
        }
    }
    draw_with_external_shader(shader) {
        shader.use();
        if (this.prim_type === gl.TRIANGLES) {
            let draw_cnt = this.buffs[0].sz / this.buffs[0].single_vert_sz;
            gl.drawArrays(this.prim_type, 0, draw_cnt);
        }
        else {
            alert('bleep bloop errrorrr');
        }
    }
    draw(offs = 0) {
        this.draw_with_external_shader(this.shader);
    }
}

;// CONCATENATED MODULE: ./src/gl/Buffer.ts


class UBO {
    buff;
    uniforms = [];
    constructor() {
        this.buff = new VertexBuffer(0, gl.FLOAT, 96, gl.UNIFORM_BUFFER);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, this.buff.buff);
    }
}
class VertexBuffer {
    buff;
    cpu_buff;
    type;
    usage;
    stride;
    single_vert_sz;
    sz;
    max_sz;
    constructor(single_vert_sz, type = gl.FLOAT, max_size = 10000000, usage = gl.ARRAY_BUFFER) {
        this.buff = gl.createBuffer();
        this.usage = usage;
        gl.bindBuffer(usage, this.buff);
        this.type = type;
        this.single_vert_sz = single_vert_sz;
        this.max_sz = max_size;
        this.stride = 0;
        if (type === gl.FLOAT) {
            this.cpu_buff = new Float32Array(max_size);
        }
        else if (type === gl.INT) {
            this.cpu_buff = new Int32Array(max_size);
        }
        else {
            this.cpu_buff = new Uint32Array(max_size);
        }
        gl.bufferData(usage, this.cpu_buff.byteLength, gl.DYNAMIC_DRAW);
        this.sz = this.cpu_buff.length / 4;
    }
    bindToAttrib(idx, params = undefined) {
        if (params) {
            gl.bindBuffer(this.usage, this.buff);
            gl.vertexAttribPointer(idx, params.vert_sz ?? this.single_vert_sz, params.type ?? this.type, false, params.stride ?? this.stride, params.offset ?? 0);
        }
        else {
            gl.bindBuffer(this.usage, this.buff);
            gl.vertexAttribPointer(idx, this.single_vert_sz, this.type, false, this.stride, 0);
        }
    }
    push_vert(vert) {
        if (vert.length !== this.single_vert_sz) {
        }
        for (let v of vert) {
            this.cpu_buff[this.sz++] = v;
        }
    }
    upload_external_array(input_buff) {
        if (input_buff instanceof Array) {
            gl.bindBuffer(this.usage, this.buff);
            let _buff = Float32Array.from(input_buff);
            this.sz = _buff.length;
            const sz_in_bytes = _buff.byteLength;
            gl.bufferSubData(this.usage, 0, _buff);
            pause_on_gl_error();
        }
        else {
            gl.bindBuffer(this.usage, this.buff);
            const sz_in_bytes = input_buff.byteLength;
            gl.bufferSubData(this.usage, 0, input_buff);
            pause_on_gl_error();
        }
    }
    upload() {
        gl.bindBuffer(this.usage, this.buff);
        const sz_in_bytes = this.sz * this.cpu_buff.BYTES_PER_ELEMENT;
        gl.bufferSubData(this.usage, 0, this.cpu_buff, 0, sz_in_bytes);
        pause_on_gl_error();
    }
}

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Link.svelte.9.css!./src/components/Link.svelte
var Link_svelte = __webpack_require__(201);
;// CONCATENATED MODULE: ./src/components/Link.svelte.9.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Link.svelte.9.css!./src/components/Link.svelte

      
      
      
      
      
      
      
      
      

var Link_svelte_options = {};

Link_svelte_options.styleTagTransform = (styleTagTransform_default());
Link_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      Link_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
Link_svelte_options.domAPI = (styleDomAPI_default());
Link_svelte_options.insertStyleElement = (insertStyleElement_default());

var Link_svelte_update = injectStylesIntoStyleTag_default()(Link_svelte/* default */.Z, Link_svelte_options);




       /* harmony default export */ const components_Link_svelte = (Link_svelte/* default */.Z && Link_svelte/* default */.Z.locals ? Link_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/Link.svelte
/* src\components\Link.svelte generated by Svelte v4.0.1 */


const { console: console_1 } = globals;



const file = "src\\components\\Link.svelte";

function create_fragment(ctx) {
	let a;
	let a_class_value;

	const block = {
		c: function create() {
			a = dom_element("a");
			attr_dev(a, "href", /*link*/ ctx[0]);
			attr_dev(a, "class", a_class_value = "menu-item " + /*add_classes*/ ctx[2] + " svelte-1j874il");
			add_location(a, file, 1, 0, 2);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			a.innerHTML = /*text*/ ctx[1];
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*text*/ 2) a.innerHTML = /*text*/ ctx[1];;

			if (dirty & /*link*/ 1) {
				attr_dev(a, "href", /*link*/ ctx[0]);
			}

			if (dirty & /*add_classes*/ 4 && a_class_value !== (a_class_value = "menu-item " + /*add_classes*/ ctx[2] + " svelte-1j874il")) {
				attr_dev(a, "class", a_class_value);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let path_name;
	let add_classes;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Link', slots, []);
	const is_dev = "production" === 'development';
	let { text } = $$props;
	let { link } = $$props;

	if (is_dev) {
		link += ".html";
	}

	onMount(async () => {
		
	});

	onDestroy(() => {
		
	});

	$$self.$$.on_mount.push(function () {
		if (text === undefined && !('text' in $$props || $$self.$$.bound[$$self.$$.props['text']])) {
			console_1.warn("<Link> was created without expected prop 'text'");
		}

		if (link === undefined && !('link' in $$props || $$self.$$.bound[$$self.$$.props['link']])) {
			console_1.warn("<Link> was created without expected prop 'link'");
		}
	});

	const writable_props = ['text', 'link'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Link> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('text' in $$props) $$invalidate(1, text = $$props.text);
		if ('link' in $$props) $$invalidate(0, link = $$props.link);
	};

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		is_dev,
		text,
		link,
		path_name,
		add_classes
	});

	$$self.$inject_state = $$props => {
		if ('text' in $$props) $$invalidate(1, text = $$props.text);
		if ('link' in $$props) $$invalidate(0, link = $$props.link);
		if ('path_name' in $$props) $$invalidate(3, path_name = $$props.path_name);
		if ('add_classes' in $$props) $$invalidate(2, add_classes = $$props.add_classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*path_name, link*/ 9) {
			$: $$invalidate(2, add_classes = path_name === link || path_name === link.replace('.html', '')
			? " selected"
			: "");
		}

		if ($$self.$$.dirty & /*path_name, link*/ 9) {
			$: {
				console.log(path_name);
				console.log(link);
			}
		}
	};

	$: $$invalidate(3, path_name = location.pathname);
	return [link, text, add_classes, path_name];
}

class Link extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { text: 1, link: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link",
			options,
			id: create_fragment.name
		});
	}

	get text() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const src_components_Link_svelte = (Link);

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Bar.svelte.1.css!./src/components/Bar.svelte
var Bar_svelte = __webpack_require__(582);
;// CONCATENATED MODULE: ./src/components/Bar.svelte.1.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Bar.svelte.1.css!./src/components/Bar.svelte

      
      
      
      
      
      
      
      
      

var Bar_svelte_options = {};

Bar_svelte_options.styleTagTransform = (styleTagTransform_default());
Bar_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      Bar_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
Bar_svelte_options.domAPI = (styleDomAPI_default());
Bar_svelte_options.insertStyleElement = (insertStyleElement_default());

var Bar_svelte_update = injectStylesIntoStyleTag_default()(Bar_svelte/* default */.Z, Bar_svelte_options);




       /* harmony default export */ const components_Bar_svelte = (Bar_svelte/* default */.Z && Bar_svelte/* default */.Z.locals ? Bar_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/Bar.svelte
/* src\components\Bar.svelte generated by Svelte v4.0.1 */


const { console: Bar_svelte_console_1 } = globals;




const Bar_svelte_file = "src\\components\\Bar.svelte";

function Bar_svelte_create_fragment(ctx) {
	let div3;
	let a0;
	let mark;
	let a0_class_value;
	let t1;
	let a1;
	let t2;
	let a1_class_value;
	let t3;
	let a2;
	let t4;
	let a2_class_value;
	let t5;
	let div2;
	let div0;
	let t6;
	let div1;
	let link0;
	let t7;
	let link1;
	let t8;
	let link2;
	let t9;
	let link3;
	let t10;
	let link4;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	link0 = new src_components_Link_svelte({
			props: { link: "/art", text: "/art" },
			$$inline: true
		});

	link1 = new src_components_Link_svelte({
			props: { link: "/music", text: "/music" },
			$$inline: true
		});

	link2 = new src_components_Link_svelte({
			props: {
				link: "/favdemos",
				text: "/fav <br> demos"
			},
			$$inline: true
		});

	link3 = new src_components_Link_svelte({
			props: { link: "/projects", text: "/projects" },
			$$inline: true
		});

	link4 = new src_components_Link_svelte({
			props: { link: "/about", text: "/about" },
			$$inline: true
		});

	const block = {
		c: function create() {
			div3 = dom_element("div");
			a0 = dom_element("a");
			mark = dom_element("mark");
			mark.textContent = "wrighter";
			t1 = space();
			a1 = dom_element("a");
			t2 = dom_text("wrighter");
			t3 = space();
			a2 = dom_element("a");
			t4 = dom_text("wrighter");
			t5 = space();
			div2 = dom_element("div");
			div0 = dom_element("div");
			if (default_slot) default_slot.c();
			t6 = space();
			div1 = dom_element("div");
			create_component(link0.$$.fragment);
			t7 = space();
			create_component(link1.$$.fragment);
			t8 = space();
			create_component(link2.$$.fragment);
			t9 = space();
			create_component(link3.$$.fragment);
			t10 = space();
			create_component(link4.$$.fragment);
			attr_dev(mark, "class", "svelte-19glm00");
			add_location(mark, Bar_svelte_file, 2, 2, 89);
			attr_dev(a0, "href", "./");
			attr_dev(a0, "class", a0_class_value = "logo logo-behind logo-behind-a " + /*hovered_class*/ ctx[1] + " svelte-19glm00");
			add_location(a0, Bar_svelte_file, 1, 1, 17);
			attr_dev(a1, "href", "./");
			attr_dev(a1, "class", a1_class_value = "logo logo-behind logo-behind-b " + /*hovered_class*/ ctx[1] + " svelte-19glm00");
			add_location(a1, Bar_svelte_file, 6, 1, 128);
			attr_dev(a2, "href", "./");
			attr_dev(a2, "class", a2_class_value = "logo " + /*hovered_class*/ ctx[1] + " svelte-19glm00");
			add_location(a2, Bar_svelte_file, 9, 1, 218);
			attr_dev(div0, "id", "menu");
			attr_dev(div0, "class", "svelte-19glm00");
			add_location(div0, Bar_svelte_file, 13, 2, 327);
			attr_dev(div1, "id", "menu");
			attr_dev(div1, "class", "svelte-19glm00");
			add_location(div1, Bar_svelte_file, 21, 2, 627);
			attr_dev(div2, "id", "menus");
			attr_dev(div2, "class", "svelte-19glm00");
			add_location(div2, Bar_svelte_file, 12, 1, 307);
			attr_dev(div3, "id", "bar");
			attr_dev(div3, "class", "svelte-19glm00");
			add_location(div3, Bar_svelte_file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, a0);
			append_dev(a0, mark);
			append_dev(div3, t1);
			append_dev(div3, a1);
			append_dev(a1, t2);
			append_dev(div3, t3);
			append_dev(div3, a2);
			append_dev(a2, t4);
			/*a2_binding*/ ctx[4](a2);
			append_dev(div3, t5);
			append_dev(div3, div2);
			append_dev(div2, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div2, t6);
			append_dev(div2, div1);
			mount_component(link0, div1, null);
			append_dev(div1, t7);
			mount_component(link1, div1, null);
			append_dev(div1, t8);
			mount_component(link2, div1, null);
			append_dev(div1, t9);
			mount_component(link3, div1, null);
			append_dev(div1, t10);
			mount_component(link4, div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*hovered_class*/ 2 && a0_class_value !== (a0_class_value = "logo logo-behind logo-behind-a " + /*hovered_class*/ ctx[1] + " svelte-19glm00")) {
				attr_dev(a0, "class", a0_class_value);
			}

			if (!current || dirty & /*hovered_class*/ 2 && a1_class_value !== (a1_class_value = "logo logo-behind logo-behind-b " + /*hovered_class*/ ctx[1] + " svelte-19glm00")) {
				attr_dev(a1, "class", a1_class_value);
			}

			if (!current || dirty & /*hovered_class*/ 2 && a2_class_value !== (a2_class_value = "logo " + /*hovered_class*/ ctx[1] + " svelte-19glm00")) {
				attr_dev(a2, "class", a2_class_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(default_slot, local);
			transitions_transition_in(link0.$$.fragment, local);
			transitions_transition_in(link1.$$.fragment, local);
			transitions_transition_in(link2.$$.fragment, local);
			transitions_transition_in(link3.$$.fragment, local);
			transitions_transition_in(link4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(default_slot, local);
			transitions_transition_out(link0.$$.fragment, local);
			transitions_transition_out(link1.$$.fragment, local);
			transitions_transition_out(link2.$$.fragment, local);
			transitions_transition_out(link3.$$.fragment, local);
			transitions_transition_out(link4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div3);
			}

			/*a2_binding*/ ctx[4](null);
			if (default_slot) default_slot.d(detaching);
			destroy_component(link0);
			destroy_component(link1);
			destroy_component(link2);
			destroy_component(link3);
			destroy_component(link4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Bar_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Bar_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Bar', slots, ['default']);
	let logo_element;
	let hovered_class = "";
	let effect_idx = 1;
	let last_t_during_fx_change = new Date();

	onMount(async () => {
		logo_element.addEventListener('mouseenter', () => {
			let new_date = new Date();
			let seconds = Math.abs(last_t_during_fx_change.getTime() - new_date.getTime()) / 1000;
			$$invalidate(1, hovered_class = "hovered");

			if (seconds > 0.5) {
				$$invalidate(1, hovered_class += " hover-effect-" + effect_idx);
			}

			console.log("hovered");
		});

		logo_element.addEventListener('mouseleave', () => {
			$$invalidate(1, hovered_class = "");
			effect_idx = (effect_idx + 1) % 2;
		});
	});

	onDestroy(() => {
		
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') Bar_svelte_console_1.warn(`<Bar> was created with unknown prop '${key}'`);
	});

	function a2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			logo_element = $$value;
			$$invalidate(0, logo_element);
		});
	}

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		Link: src_components_Link_svelte,
		logo_element,
		hovered_class,
		effect_idx,
		last_t_during_fx_change
	});

	$$self.$inject_state = $$props => {
		if ('logo_element' in $$props) $$invalidate(0, logo_element = $$props.logo_element);
		if ('hovered_class' in $$props) $$invalidate(1, hovered_class = $$props.hovered_class);
		if ('effect_idx' in $$props) effect_idx = $$props.effect_idx;
		if ('last_t_during_fx_change' in $$props) last_t_during_fx_change = $$props.last_t_during_fx_change;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [logo_element, hovered_class, $$scope, slots, a2_binding];
}

class Bar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, Bar_svelte_instance, Bar_svelte_create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Bar",
			options,
			id: Bar_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const src_components_Bar_svelte = (Bar);

;// CONCATENATED MODULE: ./node_modules/svelte-routing/src/contexts.js


const LOCATION = {};
const ROUTER = {};
const HISTORY = {};

const useLocation = () => getContext(LOCATION);
const useRouter = () => getContext(ROUTER);
const useHistory = () => getContext(HISTORY);

;// CONCATENATED MODULE: ./node_modules/svelte-routing/src/utils.js
/**
 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
 * https://github.com/reach/router/blob/master/LICENSE
 */

const PARAM = /^:(.+)/;
const SEGMENT_POINTS = 4;
const STATIC_POINTS = 3;
const DYNAMIC_POINTS = 2;
const SPLAT_PENALTY = 1;
const ROOT_POINTS = 1;

/**
 * Split up the URI into segments delimited by `/`
 * Strip starting/ending `/`
 * @param {string} uri
 * @return {string[]}
 */
const segmentize = (uri) => uri.replace(/(^\/+|\/+$)/g, "").split("/");
/**
 * Strip `str` of potential start and end `/`
 * @param {string} string
 * @return {string}
 */
const stripSlashes = (string) => string.replace(/(^\/+|\/+$)/g, "");
/**
 * Score a route depending on how its individual segments look
 * @param {object} route
 * @param {number} index
 * @return {object}
 */
const rankRoute = (route, index) => {
    const score = route.default
        ? 0
        : segmentize(route.path).reduce((score, segment) => {
              score += SEGMENT_POINTS;

              if (segment === "") {
                  score += ROOT_POINTS;
              } else if (PARAM.test(segment)) {
                  score += DYNAMIC_POINTS;
              } else if (segment[0] === "*") {
                  score -= SEGMENT_POINTS + SPLAT_PENALTY;
              } else {
                  score += STATIC_POINTS;
              }

              return score;
          }, 0);

    return { route, score, index };
};
/**
 * Give a score to all routes and sort them on that
 * If two routes have the exact same score, we go by index instead
 * @param {object[]} routes
 * @return {object[]}
 */
const rankRoutes = (routes) =>
    routes
        .map(rankRoute)
        .sort((a, b) =>
            a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
        );
/**
 * Ranks and picks the best route to match. Each segment gets the highest
 * amount of points, then the type of segment gets an additional amount of
 * points where
 *
 *  static > dynamic > splat > root
 *
 * This way we don't have to worry about the order of our routes, let the
 * computers do it.
 *
 * A route looks like this
 *
 *  { path, default, value }
 *
 * And a returned match looks like:
 *
 *  { route, params, uri }
 *
 * @param {object[]} routes
 * @param {string} uri
 * @return {?object}
 */
const pick = (routes, uri) => {
    let match;
    let default_;

    const [uriPathname] = uri.split("?");
    const uriSegments = segmentize(uriPathname);
    const isRootUri = uriSegments[0] === "";
    const ranked = rankRoutes(routes);

    for (let i = 0, l = ranked.length; i < l; i++) {
        const route = ranked[i].route;
        let missed = false;

        if (route.default) {
            default_ = {
                route,
                params: {},
                uri,
            };
            continue;
        }

        const routeSegments = segmentize(route.path);
        const params = {};
        const max = Math.max(uriSegments.length, routeSegments.length);
        let index = 0;

        for (; index < max; index++) {
            const routeSegment = routeSegments[index];
            const uriSegment = uriSegments[index];

            if (routeSegment && routeSegment[0] === "*") {
                // Hit a splat, just grab the rest, and return a match
                // uri:   /files/documents/work
                // route: /files/* or /files/*splatname
                const splatName =
                    routeSegment === "*" ? "*" : routeSegment.slice(1);

                params[splatName] = uriSegments
                    .slice(index)
                    .map(decodeURIComponent)
                    .join("/");
                break;
            }

            if (typeof uriSegment === "undefined") {
                // URI is shorter than the route, no match
                // uri:   /users
                // route: /users/:userId
                missed = true;
                break;
            }

            const dynamicMatch = PARAM.exec(routeSegment);

            if (dynamicMatch && !isRootUri) {
                const value = decodeURIComponent(uriSegment);
                params[dynamicMatch[1]] = value;
            } else if (routeSegment !== uriSegment) {
                // Current segments don't match, not dynamic, not splat, so no match
                // uri:   /users/123/settings
                // route: /users/:id/profile
                missed = true;
                break;
            }
        }

        if (!missed) {
            match = {
                route,
                params,
                uri: "/" + uriSegments.slice(0, index).join("/"),
            };
            break;
        }
    }

    return match || default_ || null;
};
/**
 * Add the query to the pathname if a query is given
 * @param {string} pathname
 * @param {string} [query]
 * @return {string}
 */
const addQuery = (pathname, query) => pathname + (query ? `?${query}` : "");
/**
 * Resolve URIs as though every path is a directory, no files. Relative URIs
 * in the browser can feel awkward because not only can you be "in a directory",
 * you can be "at a file", too. For example:
 *
 *  browserSpecResolve('foo', '/bar/') => /bar/foo
 *  browserSpecResolve('foo', '/bar') => /foo
 *
 * But on the command line of a file system, it's not as complicated. You can't
 * `cd` from a file, only directories. This way, links have to know less about
 * their current path. To go deeper you can do this:
 *
 *  <Link to="deeper"/>
 *  // instead of
 *  <Link to=`{${props.uri}/deeper}`/>
 *
 * Just like `cd`, if you want to go deeper from the command line, you do this:
 *
 *  cd deeper
 *  # not
 *  cd $(pwd)/deeper
 *
 * By treating every path as a directory, linking to relative paths should
 * require less contextual information and (fingers crossed) be more intuitive.
 * @param {string} to
 * @param {string} base
 * @return {string}
 */
const resolve = (to, base) => {
    // /foo/bar, /baz/qux => /foo/bar
    if (to.startsWith("/")) return to;

    const [toPathname, toQuery] = to.split("?");
    const [basePathname] = base.split("?");
    const toSegments = segmentize(toPathname);
    const baseSegments = segmentize(basePathname);

    // ?a=b, /users?b=c => /users?a=b
    if (toSegments[0] === "") return addQuery(basePathname, toQuery);

    // profile, /users/789 => /users/789/profile

    if (!toSegments[0].startsWith(".")) {
        const pathname = baseSegments.concat(toSegments).join("/");
        return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
    }

    // ./       , /users/123 => /users/123
    // ../      , /users/123 => /users
    // ../..    , /users/123 => /
    // ../../one, /a/b/c/d   => /a/b/one
    // .././one , /a/b/c/d   => /a/b/c/one
    const allSegments = baseSegments.concat(toSegments);
    const segments = [];

    allSegments.forEach((segment) => {
        if (segment === "..") segments.pop();
        else if (segment !== ".") segments.push(segment);
    });

    return addQuery("/" + segments.join("/"), toQuery);
};
/**
 * Combines the `basepath` and the `path` into one path.
 * @param {string} basepath
 * @param {string} path
 */
const combinePaths = (basepath, path) =>
    `${stripSlashes(
        path === "/"
            ? basepath
            : `${stripSlashes(basepath)}/${stripSlashes(path)}`
    )}/`;
/**
 * Decides whether a given `event` should result in a navigation or not.
 * @param {object} event
 */
const utils_shouldNavigate = (event) =>
    !event.defaultPrevented &&
    event.button === 0 &&
    !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);

// svelte seems to kill anchor.host value in ie11, so fall back to checking href
const utils_hostMatches = (anchor) => {
    const host = location.host;
    return (
        anchor.host === host ||
        anchor.href.indexOf(`https://${host}`) === 0 ||
        anchor.href.indexOf(`http://${host}`) === 0
    );
};

const canUseDOM = () =>
    typeof window !== "undefined" &&
    "document" in window &&
    "location" in window;



;// CONCATENATED MODULE: ./node_modules/svelte-routing/src/Link.svelte
/* node_modules\svelte-routing\src\Link.svelte generated by Svelte v4.0.1 */






const Link_svelte_file = "node_modules\\svelte-routing\\src\\Link.svelte";
const get_default_slot_changes = dirty => ({ active: dirty & /*ariaCurrent*/ 4 });
const get_default_slot_context = ctx => ({ active: !!/*ariaCurrent*/ ctx[2] });

function Link_svelte_create_fragment(ctx) {
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], get_default_slot_context);

	let a_levels = [
		{ href: /*href*/ ctx[0] },
		{ "aria-current": /*ariaCurrent*/ ctx[2] },
		/*props*/ ctx[1],
		/*$$restProps*/ ctx[6]
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = utils_assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = dom_element("a");
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, Link_svelte_file, 40, 0, 1384);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, ariaCurrent*/ 32772)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
				(!current || dirty & /*ariaCurrent*/ 4) && { "aria-current": /*ariaCurrent*/ ctx[2] },
				dirty & /*props*/ 2 && /*props*/ ctx[1],
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Link_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Link_svelte_instance($$self, $$props, $$invalidate) {
	let ariaCurrent;
	const omit_props_names = ["to","replace","state","getProps"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $location;
	let $base;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Link', slots, ['default']);
	let { to = "#" } = $$props;
	let { replace = false } = $$props;
	let { state = {} } = $$props;
	let { getProps = () => ({}) } = $$props;
	const location = lifecycle_getContext(LOCATION);
	validate_store(location, 'location');
	component_subscribe($$self, location, value => $$invalidate(13, $location = value));
	const { base } = lifecycle_getContext(ROUTER);
	validate_store(base, 'base');
	component_subscribe($$self, base, value => $$invalidate(14, $base = value));
	const { navigate } = lifecycle_getContext(HISTORY);
	const dispatch = createEventDispatcher();
	let href, isPartiallyCurrent, isCurrent, props;

	const onClick = event => {
		dispatch("click", event);

		if (utils_shouldNavigate(event)) {
			event.preventDefault();

			// Don't push another entry to the history stack when the user
			// clicks on a Link to the page they are currently on.
			const shouldReplace = $location.pathname === href || replace;

			navigate(href, { state, replace: shouldReplace });
		}
	};

	$$self.$$set = $$new_props => {
		$$props = utils_assign(utils_assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('to' in $$new_props) $$invalidate(7, to = $$new_props.to);
		if ('replace' in $$new_props) $$invalidate(8, replace = $$new_props.replace);
		if ('state' in $$new_props) $$invalidate(9, state = $$new_props.state);
		if ('getProps' in $$new_props) $$invalidate(10, getProps = $$new_props.getProps);
		if ('$$scope' in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher: createEventDispatcher,
		getContext: lifecycle_getContext,
		HISTORY: HISTORY,
		LOCATION: LOCATION,
		ROUTER: ROUTER,
		resolve: resolve,
		shouldNavigate: utils_shouldNavigate,
		to,
		replace,
		state,
		getProps,
		location,
		base,
		navigate,
		dispatch,
		href,
		isPartiallyCurrent,
		isCurrent,
		props,
		onClick,
		ariaCurrent,
		$location,
		$base
	});

	$$self.$inject_state = $$new_props => {
		if ('to' in $$props) $$invalidate(7, to = $$new_props.to);
		if ('replace' in $$props) $$invalidate(8, replace = $$new_props.replace);
		if ('state' in $$props) $$invalidate(9, state = $$new_props.state);
		if ('getProps' in $$props) $$invalidate(10, getProps = $$new_props.getProps);
		if ('href' in $$props) $$invalidate(0, href = $$new_props.href);
		if ('isPartiallyCurrent' in $$props) $$invalidate(11, isPartiallyCurrent = $$new_props.isPartiallyCurrent);
		if ('isCurrent' in $$props) $$invalidate(12, isCurrent = $$new_props.isCurrent);
		if ('props' in $$props) $$invalidate(1, props = $$new_props.props);
		if ('ariaCurrent' in $$props) $$invalidate(2, ariaCurrent = $$new_props.ariaCurrent);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*to, $base*/ 16512) {
			$: $$invalidate(0, href = to === "/" ? $base.uri : resolve(to, $base.uri));
		}

		if ($$self.$$.dirty & /*$location, href*/ 8193) {
			$: $$invalidate(11, isPartiallyCurrent = $location.pathname.startsWith(href));
		}

		if ($$self.$$.dirty & /*href, $location*/ 8193) {
			$: $$invalidate(12, isCurrent = href === $location.pathname);
		}

		if ($$self.$$.dirty & /*isCurrent*/ 4096) {
			$: $$invalidate(2, ariaCurrent = isCurrent ? "page" : undefined);
		}

		$: $$invalidate(1, props = getProps({
			location: $location,
			href,
			isPartiallyCurrent,
			isCurrent,
			existingProps: $$restProps
		}));
	};

	return [
		href,
		props,
		ariaCurrent,
		location,
		base,
		onClick,
		$$restProps,
		to,
		replace,
		state,
		getProps,
		isPartiallyCurrent,
		isCurrent,
		$location,
		$base,
		$$scope,
		slots
	];
}

class Link_svelte_Link extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, Link_svelte_instance, Link_svelte_create_fragment, safe_not_equal, {
			to: 7,
			replace: 8,
			state: 9,
			getProps: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link",
			options,
			id: Link_svelte_create_fragment.name
		});
	}

	get to() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set to(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get replace() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set replace(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get state() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set state(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getProps() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getProps(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const src_Link_svelte = (Link_svelte_Link);
;// CONCATENATED MODULE: ./node_modules/svelte-routing/src/Route.svelte
/* node_modules\svelte-routing\src\Route.svelte generated by Svelte v4.0.1 */






const Route_svelte_file = "node_modules\\svelte-routing\\src\\Route.svelte";
const Route_svelte_get_default_slot_changes = dirty => ({ params: dirty & /*routeParams*/ 4 });
const Route_svelte_get_default_slot_context = ctx => ({ params: /*routeParams*/ ctx[2] });

// (42:0) {#if $activeRoute && $activeRoute.route === route}
function create_if_block(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*component*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transitions_transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transitions_transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(42:0) {#if $activeRoute && $activeRoute.route === route}",
		ctx
	});

	return block;
}

// (51:4) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], Route_svelte_get_default_slot_context);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, routeParams*/ 132)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, Route_svelte_get_default_slot_changes),
						Route_svelte_get_default_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(51:4) {:else}",
		ctx
	});

	return block;
}

// (43:4) {#if component}
function create_if_block_1(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 12,
		blocks: [,,,]
	};

	handle_promise(promise = /*component*/ ctx[0], info);

	const block = {
		c: function create() {
			await_block_anchor = empty();
			info.block.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*component*/ 1 && promise !== (promise = /*component*/ ctx[0]) && handle_promise(promise, info)) {
				
			} else {
				update_await_block_branch(info, ctx, dirty);
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(info.block);
			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transitions_transition_out(block);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(await_block_anchor);
			}

			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(43:4) {#if component}",
		ctx
	});

	return block;
}

// (1:0) <script>     import { getContext, onDestroy }
function create_catch_block(ctx) {
	const block = {
		c: utils_noop,
		m: utils_noop,
		p: utils_noop,
		i: utils_noop,
		o: utils_noop,
		d: utils_noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block.name,
		type: "catch",
		source: "(1:0) <script>     import { getContext, onDestroy }",
		ctx
	});

	return block;
}

// (44:49)              <svelte:component                 this={resolvedComponent?.default || resolvedComponent}
function create_then_block(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*routeParams*/ ctx[2], /*routeProps*/ ctx[3]];
	var switch_value = /*resolvedComponent*/ ctx[12]?.default || /*resolvedComponent*/ ctx[12];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = utils_assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*routeParams, routeProps*/ 12)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*routeParams*/ 4 && get_spread_object(/*routeParams*/ ctx[2]),
					dirty & /*routeProps*/ 8 && get_spread_object(/*routeProps*/ ctx[3])
				])
			: {};

			if (dirty & /*component*/ 1 && switch_value !== (switch_value = /*resolvedComponent*/ ctx[12]?.default || /*resolvedComponent*/ ctx[12])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transitions_transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transitions_transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transitions_transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transitions_transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block.name,
		type: "then",
		source: "(44:49)              <svelte:component                 this={resolvedComponent?.default || resolvedComponent}",
		ctx
	});

	return block;
}

// (1:0) <script>     import { getContext, onDestroy }
function create_pending_block(ctx) {
	const block = {
		c: utils_noop,
		m: utils_noop,
		p: utils_noop,
		i: utils_noop,
		o: utils_noop,
		d: utils_noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block.name,
		type: "pending",
		source: "(1:0) <script>     import { getContext, onDestroy }",
		ctx
	});

	return block;
}

function Route_svelte_create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$activeRoute*/ ctx[1] && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[5] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$activeRoute*/ ctx[1] && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$activeRoute*/ 2) {
						transitions_transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transitions_transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transitions_transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Route_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Route_svelte_instance($$self, $$props, $$invalidate) {
	let $activeRoute;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Route', slots, ['default']);
	let { path = "" } = $$props;
	let { component = null } = $$props;
	let routeParams = {};
	let routeProps = {};
	const { registerRoute, unregisterRoute, activeRoute } = lifecycle_getContext(ROUTER);
	validate_store(activeRoute, 'activeRoute');
	component_subscribe($$self, activeRoute, value => $$invalidate(1, $activeRoute = value));

	const route = {
		path,
		// If no path prop is given, this Route will act as the default Route
		// that is rendered if no other Route in the Router is a match.
		default: path === ""
	};

	registerRoute(route);

	onDestroy(() => {
		unregisterRoute(route);
	});

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = utils_assign(utils_assign({}, $$props), exclude_internal_props($$new_props)));
		if ('path' in $$new_props) $$invalidate(6, path = $$new_props.path);
		if ('component' in $$new_props) $$invalidate(0, component = $$new_props.component);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext: lifecycle_getContext,
		onDestroy: onDestroy,
		ROUTER: ROUTER,
		canUseDOM: canUseDOM,
		path,
		component,
		routeParams,
		routeProps,
		registerRoute,
		unregisterRoute,
		activeRoute,
		route,
		$activeRoute
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = utils_assign(utils_assign({}, $$props), $$new_props));
		if ('path' in $$props) $$invalidate(6, path = $$new_props.path);
		if ('component' in $$props) $$invalidate(0, component = $$new_props.component);
		if ('routeParams' in $$props) $$invalidate(2, routeParams = $$new_props.routeParams);
		if ('routeProps' in $$props) $$invalidate(3, routeProps = $$new_props.routeProps);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		$: if ($activeRoute && $activeRoute.route === route) {
			$$invalidate(2, routeParams = $activeRoute.params);
			const { component: c, path, ...rest } = $$props;
			$$invalidate(3, routeProps = rest);

			if (c) {
				if (c.toString().startsWith("class ")) $$invalidate(0, component = c); else $$invalidate(0, component = c());
			}

			canUseDOM() && window?.scrollTo(0, 0);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		component,
		$activeRoute,
		routeParams,
		routeProps,
		activeRoute,
		route,
		path,
		$$scope,
		slots
	];
}

class Route extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, Route_svelte_instance, Route_svelte_create_fragment, safe_not_equal, { path: 6, component: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Route",
			options,
			id: Route_svelte_create_fragment.name
		});
	}

	get path() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set path(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const Route_svelte = (Route);
;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/store/index.js


const subscriber_queue = [];

/**
 * Creates a `Readable` store that allows reading by subscription.
 *
 * https://svelte.dev/docs/svelte-store#readable
 * @template T
 * @param {T} [value] initial value
 * @param {import('./public.js').StartStopNotifier<T>} [start]
 * @returns {import('./public.js').Readable<T>}
 */
function readable(value, start) {
	return {
		subscribe: writable(value, start).subscribe
	};
}

/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 *
 * https://svelte.dev/docs/svelte-store#writable
 * @template T
 * @param {T} [value] initial value
 * @param {import('./public.js').StartStopNotifier<T>} [start]
 * @returns {import('./public.js').Writable<T>}
 */
function writable(value, start = utils_noop) {
	/** @type {import('./public.js').Unsubscriber} */
	let stop;
	/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
	const subscribers = new Set();
	/** @param {T} new_value
	 * @returns {void}
	 */
	function set(new_value) {
		if (safe_not_equal(value, new_value)) {
			value = new_value;
			if (stop) {
				// store is ready
				const run_queue = !subscriber_queue.length;
				for (const subscriber of subscribers) {
					subscriber[1]();
					subscriber_queue.push(subscriber, value);
				}
				if (run_queue) {
					for (let i = 0; i < subscriber_queue.length; i += 2) {
						subscriber_queue[i][0](subscriber_queue[i + 1]);
					}
					subscriber_queue.length = 0;
				}
			}
		}
	}

	/**
	 * @param {import('./public.js').Updater<T>} fn
	 * @returns {void}
	 */
	function update(fn) {
		set(fn(value));
	}

	/**
	 * @param {import('./public.js').Subscriber<T>} run
	 * @param {import('./private.js').Invalidator<T>} [invalidate]
	 * @returns {import('./public.js').Unsubscriber}
	 */
	function subscribe(run, invalidate = utils_noop) {
		/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
		const subscriber = [run, invalidate];
		subscribers.add(subscriber);
		if (subscribers.size === 1) {
			stop = start(set, update) || utils_noop;
		}
		run(value);
		return () => {
			subscribers.delete(subscriber);
			if (subscribers.size === 0 && stop) {
				stop();
				stop = null;
			}
		};
	}
	return { set, update, subscribe };
}

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 *
 * https://svelte.dev/docs/svelte-store#derived
 * @template {import('./private.js').Stores} S
 * @template T
 * @overload
 * @param {S} stores - input stores
 * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values
 * @param {T} [initial_value] - initial value
 * @returns {import('./public.js').Readable<T>}
 */

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 *
 * https://svelte.dev/docs/svelte-store#derived
 * @template {import('./private.js').Stores} S
 * @template T
 * @overload
 * @param {S} stores - input stores
 * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values
 * @param {T} [initial_value] - initial value
 * @returns {import('./public.js').Readable<T>}
 */

/**
 * @template {import('./private.js').Stores} S
 * @template T
 * @param {S} stores
 * @param {Function} fn
 * @param {T} [initial_value]
 * @returns {import('./public.js').Readable<T>}
 */
function derived(stores, fn, initial_value) {
	const single = !Array.isArray(stores);
	/** @type {Array<import('./public.js').Readable<any>>} */
	const stores_array = single ? [stores] : stores;
	if (!stores_array.every(Boolean)) {
		throw new Error('derived() expects stores as input, got a falsy value');
	}
	const auto = fn.length < 2;
	return readable(initial_value, (set, update) => {
		let started = false;
		const values = [];
		let pending = 0;
		let cleanup = utils_noop;
		const sync = () => {
			if (pending) {
				return;
			}
			cleanup();
			const result = fn(single ? values[0] : values, set, update);
			if (auto) {
				set(result);
			} else {
				cleanup = utils_is_function(result) ? result : utils_noop;
			}
		};
		const unsubscribers = stores_array.map((store, i) =>
			subscribe(
				store,
				(value) => {
					values[i] = value;
					pending &= ~(1 << i);
					if (started) {
						sync();
					}
				},
				() => {
					pending |= 1 << i;
				}
			)
		);
		started = true;
		sync();
		return function stop() {
			utils_run_all(unsubscribers);
			cleanup();
			// We need to set this to false because callbacks can still happen despite having unsubscribed:
			// Callbacks might already be placed in the queue which doesn't know it should no longer
			// invoke this derived store.
			started = false;
		};
	});
}

/**
 * Takes a store and returns a new one derived from the old one that is readable.
 *
 * https://svelte.dev/docs/svelte-store#readonly
 * @template T
 * @param {import('./public.js').Readable<T>} store  - store to make readonly
 * @returns {import('./public.js').Readable<T>}
 */
function readonly(store) {
	return {
		subscribe: store.subscribe.bind(store)
	};
}



;// CONCATENATED MODULE: ./node_modules/svelte-routing/src/history.js
/**
 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
 * https://github.com/reach/router/blob/master/LICENSE
 */


const getLocation = (source) => {
    return {
        ...source.location,
        state: source.history.state,
        key: (source.history.state && source.history.state.key) || "initial",
    };
};
const createHistory = (source) => {
    const listeners = [];
    let location = getLocation(source);

    return {
        get location() {
            return location;
        },

        listen(listener) {
            listeners.push(listener);

            const popstateListener = () => {
                location = getLocation(source);
                listener({ location, action: "POP" });
            };

            source.addEventListener("popstate", popstateListener);

            return () => {
                source.removeEventListener("popstate", popstateListener);
                const index = listeners.indexOf(listener);
                listeners.splice(index, 1);
            };
        },

        navigate(to, { state, replace = false } = {}) {
            state = { ...state, key: Date.now() + "" };
            // try...catch iOS Safari limits to 100 pushState calls
            try {
                if (replace) source.history.replaceState(state, "", to);
                else source.history.pushState(state, "", to);
            } catch (e) {
                source.location[replace ? "replace" : "assign"](to);
            }
            location = getLocation(source);
            listeners.forEach((listener) =>
                listener({ location, action: "PUSH" })
            );
            document.activeElement.blur();
        },
    };
};
// Stores history entries in memory for testing or other platforms like Native
const createMemorySource = (initialPathname = "/") => {
    let index = 0;
    const stack = [{ pathname: initialPathname, search: "" }];
    const states = [];

    return {
        get location() {
            return stack[index];
        },
        addEventListener(name, fn) {},
        removeEventListener(name, fn) {},
        history: {
            get entries() {
                return stack;
            },
            get index() {
                return index;
            },
            get state() {
                return states[index];
            },
            pushState(state, _, uri) {
                const [pathname, search = ""] = uri.split("?");
                index++;
                stack.push({ pathname, search });
                states.push(state);
            },
            replaceState(state, _, uri) {
                const [pathname, search = ""] = uri.split("?");
                stack[index] = { pathname, search };
                states[index] = state;
            },
        },
    };
};
// Global history uses window.history as the source if available,
// otherwise a memory history
const globalHistory = createHistory(
    canUseDOM() ? window : createMemorySource()
);
const { navigate: history_navigate } = globalHistory;



;// CONCATENATED MODULE: ./node_modules/svelte-routing/src/Router.svelte
/* node_modules\svelte-routing\src\Router.svelte generated by Svelte v4.0.1 */


const { Object: Object_1 } = globals;






const Router_svelte_file = "node_modules\\svelte-routing\\src\\Router.svelte";

const Router_svelte_get_default_slot_changes = dirty => ({
	route: dirty & /*$activeRoute*/ 2,
	location: dirty & /*$location*/ 1
});

const Router_svelte_get_default_slot_context = ctx => ({
	route: /*$activeRoute*/ ctx[1] && /*$activeRoute*/ ctx[1].uri,
	location: /*$location*/ ctx[0]
});

function Router_svelte_create_fragment(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], Router_svelte_get_default_slot_context);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, $activeRoute, $location*/ 2051)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, Router_svelte_get_default_slot_changes),
						Router_svelte_get_default_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Router_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Router_svelte_instance($$self, $$props, $$invalidate) {
	let $location;
	let $routes;
	let $base;
	let $activeRoute;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Router', slots, ['default']);
	let { basepath = "/" } = $$props;
	let { url = null } = $$props;
	let { history = globalHistory } = $$props;
	setContext(HISTORY, history);
	const locationContext = lifecycle_getContext(LOCATION);
	const routerContext = lifecycle_getContext(ROUTER);
	const routes = writable([]);
	validate_store(routes, 'routes');
	component_subscribe($$self, routes, value => $$invalidate(9, $routes = value));
	const activeRoute = writable(null);
	validate_store(activeRoute, 'activeRoute');
	component_subscribe($$self, activeRoute, value => $$invalidate(1, $activeRoute = value));
	let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

	// If locationContext is not set, this is the topmost Router in the tree.
	// If the `url` prop is given we force the location to it.
	const location = locationContext || writable(url ? { pathname: url } : history.location);

	validate_store(location, 'location');
	component_subscribe($$self, location, value => $$invalidate(0, $location = value));

	// If routerContext is set, the routerBase of the parent Router
	// will be the base for this Router's descendants.
	// If routerContext is not set, the path and resolved uri will both
	// have the value of the basepath prop.
	const base = routerContext
	? routerContext.routerBase
	: writable({ path: basepath, uri: basepath });

	validate_store(base, 'base');
	component_subscribe($$self, base, value => $$invalidate(10, $base = value));

	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
		// If there is no activeRoute, the routerBase will be identical to the base.
		if (!activeRoute) return base;

		const { path: basepath } = base;
		const { route, uri } = activeRoute;

		// Remove the potential /* or /*splatname from
		// the end of the child Routes relative paths.
		const path = route.default
		? basepath
		: route.path.replace(/\*.*$/, "");

		return { path, uri };
	});

	const registerRoute = route => {
		const { path: basepath } = $base;
		let { path } = route;

		// We store the original path in the _path property so we can reuse
		// it when the basepath changes. The only thing that matters is that
		// the route reference is intact, so mutation is fine.
		route._path = path;

		route.path = combinePaths(basepath, path);

		if (typeof window === "undefined") {
			// In SSR we should set the activeRoute immediately if it is a match.
			// If there are more Routes being registered after a match is found,
			// we just skip them.
			if (hasActiveRoute) return;

			const matchingRoute = pick([route], $location.pathname);

			if (matchingRoute) {
				activeRoute.set(matchingRoute);
				hasActiveRoute = true;
			}
		} else {
			routes.update(rs => [...rs, route]);
		}
	};

	const unregisterRoute = route => {
		routes.update(rs => rs.filter(r => r !== route));
	};

	if (!locationContext) {
		// The topmost Router in the tree is responsible for updating
		// the location store and supplying it through context.
		onMount(() => {
			const unlisten = history.listen(event => {
				location.set(event.location);
			});

			return unlisten;
		});

		setContext(LOCATION, location);
	}

	setContext(ROUTER, {
		activeRoute,
		base,
		routerBase,
		registerRoute,
		unregisterRoute
	});

	const writable_props = ['basepath', 'url', 'history'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Router> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('basepath' in $$props) $$invalidate(6, basepath = $$props.basepath);
		if ('url' in $$props) $$invalidate(7, url = $$props.url);
		if ('history' in $$props) $$invalidate(8, history = $$props.history);
		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext: lifecycle_getContext,
		onMount: onMount,
		setContext: setContext,
		derived: derived,
		writable: writable,
		HISTORY: HISTORY,
		LOCATION: LOCATION,
		ROUTER: ROUTER,
		globalHistory: globalHistory,
		combinePaths: combinePaths,
		pick: pick,
		basepath,
		url,
		history,
		locationContext,
		routerContext,
		routes,
		activeRoute,
		hasActiveRoute,
		location,
		base,
		routerBase,
		registerRoute,
		unregisterRoute,
		$location,
		$routes,
		$base,
		$activeRoute
	});

	$$self.$inject_state = $$props => {
		if ('basepath' in $$props) $$invalidate(6, basepath = $$props.basepath);
		if ('url' in $$props) $$invalidate(7, url = $$props.url);
		if ('history' in $$props) $$invalidate(8, history = $$props.history);
		if ('hasActiveRoute' in $$props) hasActiveRoute = $$props.hasActiveRoute;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$base*/ 1024) {
			// This reactive statement will update all the Routes' path when
			// the basepath changes.
			$: {
				const { path: basepath } = $base;
				routes.update(rs => rs.map(r => Object.assign(r, { path: combinePaths(basepath, r._path) })));
			}
		}

		if ($$self.$$.dirty & /*$routes, $location*/ 513) {
			// This reactive statement will be run when the Router is created
			// when there are no Routes and then again the following tick, so it
			// will not find an active Route in SSR and in the browser it will only
			// pick an active Route after all Routes have been registered.
			$: {
				const bestMatch = pick($routes, $location.pathname);
				activeRoute.set(bestMatch);
			}
		}
	};

	return [
		$location,
		$activeRoute,
		routes,
		activeRoute,
		location,
		base,
		basepath,
		url,
		history,
		$routes,
		$base,
		$$scope,
		slots
	];
}

class Router extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, Router_svelte_instance, Router_svelte_create_fragment, safe_not_equal, { basepath: 6, url: 7, history: 8 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Router",
			options,
			id: Router_svelte_create_fragment.name
		});
	}

	get basepath() {
		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set basepath(value) {
		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get url() {
		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get history() {
		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set history(value) {
		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const Router_svelte = (Router);
;// CONCATENATED MODULE: ./node_modules/svelte-routing/src/actions.js



/**
 * A link action that can be added to <a href=""> tags rather
 * than using the <Link> component.
 *
 * Example:
 * ```html
 * <a href="/post/{postId}" use:link>{post.title}</a>
 * ```
 */
const actions_link = (node) => {
    const onClick = (event) => {
        const anchor = event.currentTarget;

        if (
            anchor.target === "" &&
            hostMatches(anchor) &&
            shouldNavigate(event)
        ) {
            event.preventDefault();
            navigate(anchor.pathname + anchor.search, {
                replace: anchor.hasAttribute("replace"),
            });
        }
    };

    node.addEventListener("click", onClick);

    return {
        destroy() {
            node.removeEventListener("click", onClick);
        },
    };
};

/**
 * An action to be added at a root element of your application to
 * capture all relative links and push them onto the history stack.
 *
 * Example:
 * ```html
 * <div use:links>
 *   <Router>
 *     <Route path="/" component={Home} />
 *     <Route path="/p/:projectId/:docId?" component={ProjectScreen} />
 *     {#each projects as project}
 *       <a href="/p/{project.id}">{project.title}</a>
 *     {/each}
 *   </Router>
 * </div>
 * ```
 */
const links = (node) => {
    const findClosest = (tagName, el) => {
        while (el && el.tagName !== tagName) el = el.parentNode;
        return el;
    };

    const onClick = (event) => {
        const anchor = findClosest("A", event.target);
        if (
            anchor &&
            anchor.target === "" &&
            hostMatches(anchor) &&
            shouldNavigate(event) &&
            !anchor.hasAttribute("noroute")
        ) {
            event.preventDefault();
            navigate(anchor.pathname + anchor.search, {
                replace: anchor.hasAttribute("replace"),
            });
        }
    };

    node.addEventListener("click", onClick);

    return {
        destroy() {
            node.removeEventListener("click", onClick);
        },
    };
};



;// CONCATENATED MODULE: ./node_modules/svelte-routing/src/index.js







// EXTERNAL MODULE: ./public/brightness_6_FILL0_wght400_GRAD0_opsz48.svg
var brightness_6_FILL0_wght400_GRAD0_opsz48 = __webpack_require__(567);
var brightness_6_FILL0_wght400_GRAD0_opsz48_default = /*#__PURE__*/__webpack_require__.n(brightness_6_FILL0_wght400_GRAD0_opsz48);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Footer.svelte.8.css!./src/components/Footer.svelte
var Footer_svelte = __webpack_require__(952);
;// CONCATENATED MODULE: ./src/components/Footer.svelte.8.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Footer.svelte.8.css!./src/components/Footer.svelte

      
      
      
      
      
      
      
      
      

var Footer_svelte_options = {};

Footer_svelte_options.styleTagTransform = (styleTagTransform_default());
Footer_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      Footer_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
Footer_svelte_options.domAPI = (styleDomAPI_default());
Footer_svelte_options.insertStyleElement = (insertStyleElement_default());

var Footer_svelte_update = injectStylesIntoStyleTag_default()(Footer_svelte/* default */.Z, Footer_svelte_options);




       /* harmony default export */ const components_Footer_svelte = (Footer_svelte/* default */.Z && Footer_svelte/* default */.Z.locals ? Footer_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/Footer.svelte
/* src\components\Footer.svelte generated by Svelte v4.0.1 */







const Footer_svelte_file = "src\\components\\Footer.svelte";

function Footer_svelte_create_fragment(ctx) {
	let div1;
	let html_tag;
	let t0;
	let div0;
	let t2;
	let style;
	let t3;

	const block = {
		c: function create() {
			div1 = dom_element("div");
			html_tag = new HtmlTag(false);
			t0 = space();
			div0 = dom_element("div");
			div0.textContent = "Petar Guglev © 2023";
			t2 = space();
			style = dom_element("style");
			t3 = dom_text("html{\r\n\t\t\tfilter: invert(1);\r\n\t\t}\r\n\t\timg{\r\n\t\t\tfilter: invert(1);\r\n\t\t}\r\n\t\t/* Nothing contained in this styles element will be applied */");
			html_tag.a = t0;
			attr_dev(div0, "id", "name");
			attr_dev(div0, "class", "svelte-1pmkho9");
			add_location(div0, Footer_svelte_file, 2, 1, 71);
			attr_dev(style, "media", /*style_media*/ ctx[1]);
			attr_dev(style, "class", "svelte-1pmkho9");
			add_location(style, Footer_svelte_file, 5, 1, 121);
			attr_dev(div1, "id", "bar");
			attr_dev(div1, "class", "svelte-1pmkho9");
			add_location(div1, Footer_svelte_file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			html_tag.m((brightness_6_FILL0_wght400_GRAD0_opsz48_default()), div1);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div1, t2);
			append_dev(div1, style);
			append_dev(style, t3);
			/*div1_binding*/ ctx[3](div1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*style_media*/ 2) {
				attr_dev(style, "media", /*style_media*/ ctx[1]);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			/*div1_binding*/ ctx[3](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Footer_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Footer_svelte_instance($$self, $$props, $$invalidate) {
	let style_media;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Footer', slots, []);
	const is_dev = "production" === 'development';
	let is_dark_mode_toggled = localStorage.getItem("dark-mode") ?? false;
	let bar_element;
	let light_dark_toggle_icon_element;

	onMount(async () => {
		light_dark_toggle_icon_element = bar_element.querySelector("svg");

		light_dark_toggle_icon_element.onclick = () => {
			$$invalidate(2, is_dark_mode_toggled = !is_dark_mode_toggled);
			localStorage.setItem("dark-mode", is_dark_mode_toggled ? "true" : "");
		};
	});

	onDestroy(() => {
		
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Footer> was created with unknown prop '${key}'`);
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			bar_element = $$value;
			$$invalidate(0, bar_element);
		});
	}

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		Link: src_components_Link_svelte,
		LightDarkToggleIcon: (brightness_6_FILL0_wght400_GRAD0_opsz48_default()),
		is_dev,
		is_dark_mode_toggled,
		bar_element,
		light_dark_toggle_icon_element,
		style_media
	});

	$$self.$inject_state = $$props => {
		if ('is_dark_mode_toggled' in $$props) $$invalidate(2, is_dark_mode_toggled = $$props.is_dark_mode_toggled);
		if ('bar_element' in $$props) $$invalidate(0, bar_element = $$props.bar_element);
		if ('light_dark_toggle_icon_element' in $$props) light_dark_toggle_icon_element = $$props.light_dark_toggle_icon_element;
		if ('style_media' in $$props) $$invalidate(1, style_media = $$props.style_media);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*is_dark_mode_toggled*/ 4) {
			$: $$invalidate(1, style_media = is_dark_mode_toggled ? "" : "max-width:1px");
		}
	};

	return [bar_element, style_media, is_dark_mode_toggled, div1_binding];
}

class Footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, Footer_svelte_instance, Footer_svelte_create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Footer",
			options,
			id: Footer_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const src_components_Footer_svelte = (Footer);

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/FavDemos.svelte.2.css!./src/components/FavDemos.svelte
var FavDemos_svelte = __webpack_require__(300);
;// CONCATENATED MODULE: ./src/components/FavDemos.svelte.2.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/FavDemos.svelte.2.css!./src/components/FavDemos.svelte

      
      
      
      
      
      
      
      
      

var FavDemos_svelte_options = {};

FavDemos_svelte_options.styleTagTransform = (styleTagTransform_default());
FavDemos_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      FavDemos_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
FavDemos_svelte_options.domAPI = (styleDomAPI_default());
FavDemos_svelte_options.insertStyleElement = (insertStyleElement_default());

var FavDemos_svelte_update = injectStylesIntoStyleTag_default()(FavDemos_svelte/* default */.Z, FavDemos_svelte_options);




       /* harmony default export */ const components_FavDemos_svelte = (FavDemos_svelte/* default */.Z && FavDemos_svelte/* default */.Z.locals ? FavDemos_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/FavDemos.svelte
/* src\components\FavDemos.svelte generated by Svelte v4.0.1 */


const { Object: FavDemos_svelte_Object_1 } = globals;






const FavDemos_svelte_file = "src\\components\\FavDemos.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	child_ctx[11] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	child_ctx[11] = i;
	return child_ctx;
}

// (8:2) {#each list[year] as demo, i}
function create_each_block_1(ctx) {
	let a;
	let div;
	let a_href_value;
	let mounted;
	let dispose;

	function pointerenter_handler() {
		return /*pointerenter_handler*/ ctx[5](/*demo*/ ctx[12]);
	}

	const block = {
		c: function create() {
			a = dom_element("a");
			div = dom_element("div");
			div.textContent = `${/*demo*/ ctx[12].name}   —   ${/*demo*/ ctx[12].group}`;
			attr_dev(div, "class", "name svelte-1njzqxq");
			add_location(div, FavDemos_svelte_file, 9, 4, 275);
			attr_dev(a, "href", a_href_value = /*demo*/ ctx[12].link);
			attr_dev(a, "target", "”_blank”");
			attr_dev(a, "class", "demo svelte-1njzqxq");
			add_location(a, FavDemos_svelte_file, 8, 3, 148);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, div);

			if (!mounted) {
				dispose = [
					listen_dev(a, "pointerenter", pointerenter_handler, false, false, false, false),
					listen_dev(a, "pointerleave", /*pointerleave_handler*/ ctx[6], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}

			mounted = false;
			utils_run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(8:2) {#each list[year] as demo, i}",
		ctx
	});

	return block;
}

// (4:1) {#each Object.keys(list).reverse() as year, i}
function create_each_block(ctx) {
	let div;
	let t1;
	let each_1_anchor;
	let each_value_1 = ensure_array_like_dev(/*list*/ ctx[3][/*year*/ ctx[9]]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			div = dom_element("div");
			div.textContent = `${/*year*/ ctx[9]}`;
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			attr_dev(div, "class", "year svelte-1njzqxq");
			add_location(div, FavDemos_svelte_file, 4, 2, 71);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			insert_dev(target, t1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*list, Object, showImage, hideImage*/ 14) {
				each_value_1 = ensure_array_like_dev(/*list*/ ctx[3][/*year*/ ctx[9]]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
				detach_dev(t1);
				detach_dev(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(4:1) {#each Object.keys(list).reverse() as year, i}",
		ctx
	});

	return block;
}

function FavDemos_svelte_create_fragment(ctx) {
	let main;
	let bar;
	let t0;
	let t1;
	let img;
	let t2;
	let footer;
	let current;
	bar = new src_components_Bar_svelte({ $$inline: true });
	let each_value = ensure_array_like_dev(Object.keys(/*list*/ ctx[3]).reverse());
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	footer = new src_components_Footer_svelte({ $$inline: true });

	const block = {
		c: function create() {
			main = dom_element("main");
			create_component(bar.$$.fragment);
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			img = dom_element("img");
			t2 = space();
			create_component(footer.$$.fragment);
			attr_dev(img, "class", "hover-image");
			set_style(img, "background", "black");
			set_style(img, "display", "none");
			set_style(img, "position", "fixed");
			set_style(img, "pointer-events", "none");
			set_style(img, "position", "fixed");
			add_location(img, FavDemos_svelte_file, 24, 1, 575);
			attr_dev(main, "class", "svelte-1njzqxq");
			add_location(main, FavDemos_svelte_file, 1, 0, 2);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(bar, main, null);
			append_dev(main, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(main, null);
				}
			}

			append_dev(main, t1);
			append_dev(main, img);
			/*img_binding*/ ctx[7](img);
			append_dev(main, t2);
			mount_component(footer, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*list, Object, showImage, hideImage*/ 14) {
				each_value = ensure_array_like_dev(Object.keys(/*list*/ ctx[3]).reverse());
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(main, t1);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(bar.$$.fragment, local);
			transitions_transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(bar.$$.fragment, local);
			transitions_transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(main);
			}

			destroy_component(bar);
			destroy_each(each_blocks, detaching);
			/*img_binding*/ ctx[7](null);
			destroy_component(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: FavDemos_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function FavDemos_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FavDemos', slots, []);
	let hover_image_element;

	function showImage(demo) {
		$$invalidate(0, hover_image_element.style.display = "block", hover_image_element);
		$$invalidate(0, hover_image_element.src = demo.img_url, hover_image_element);
	}

	function hideImage() {
		$$invalidate(0, hover_image_element.style.display = "none", hover_image_element);
	}

	class Demo {
		name;
		group;
		link;
		img_url;

		constructor(name, group, link, img_url = "") {
			this.name = name;
			this.group = group;
			this.link = link;
			this.img_url = img_url;
		}
	}

	const list = {
		2023: [
			new Demo("0b5vr glsl techno live set", "0b5vr", "https://www.pouet.net/prod.php?which=94135", "https://content.pouet.net/files/screenshots/00094/00094135.jpg"),
			new Demo("seven days", "61Q0", "https://www.pouet.net/prod.php?which=91421", "https://content.pouet.net/files/screenshots/00091/00091421.jpg")
		],
		2022: [
			new Demo("astrophage", "logicoma", "https://www.pouet.net/prod.php?which=90874", "https://content.pouet.net/files/screenshots/00090/00090874.jpg"),
			new Demo("let this darkness be", "Slay Bells", "https://www.pouet.net/prod.php?which=91356", "https://content.pouet.net/files/screenshots/00091/00091356.jpg")
		],
		2021: [
			new Demo("there", "still", "https://www.pouet.net/prod.php?which=88632", "https://content.pouet.net/files/screenshots/00088/00088632.jpg"),
			new Demo("concept", "umlaut design", "https://www.pouet.net/prod.php?which=89840", "https://content.pouet.net/files/screenshots/00089/00089840.jpg")
		],
		2020: [
			new Demo("bossa de cores", "5711 & Farbrausch & Accession", "https://www.pouet.net/prod.php?which=86978", "https://content.pouet.net/files/screenshots/00086/00086978.jpg"),
			new Demo("wackelkontakt", "Alcatraz & Prismbeings", "https://www.pouet.net/prod.php?which=85220", "https://content.pouet.net/files/screenshots/00085/00085220.png"),
			new Demo("la vie opportuniste", "Razor1911", "https://www.pouet.net/prod.php?which=85221", "https://content.pouet.net/files/screenshots/00085/00085221.jpg")
		],
		2019: [
			new Demo("terrarium", "eos", "https://www.pouet.net/prod.php?which=82417", "https://content.pouet.net/files/screenshots/00082/00082417.jpg"),
			new Demo("zebrain", "bC. & Tpolm", "https://www.pouet.net/prod.php?which=83691", "https://content.pouet.net/files/screenshots/00083/00083691.jpg"),
			new Demo("glitch rider", "alcatraz", "https://www.pouet.net/prod.php?which=82612", "https://content.pouet.net/files/screenshots/00082/00082612.jpg")
		],
		2018: [
			new Demo("until", "fms_cat", "https://www.pouet.net/prod.php?which=79365", "https://content.pouet.net/files/screenshots/00079/00079365.jpg"),
			new Demo("dying stars", "orange", "https://www.pouet.net/prod.php?which=77409", "https://content.pouet.net/files/screenshots/00077/00077409.jpg"),
			new Demo("zetsubo", "prismbeings", "https://www.pouet.net/prod.php?which=75720", "https://content.pouet.net/files/screenshots/00075/00075720.png")
		],
		2017: [
			new Demo("otaku", "satori", "https://www.pouet.net/prod.php?which=71719", "https://content.pouet.net/files/screenshots/00071/00071719.gif"),
			new Demo("absolute territory", "prismbeings", "https://www.pouet.net/prod.php?which=69642", "https://content.pouet.net/files/screenshots/00069/00069642.jpg"),
			new Demo("esocentrica", "asd & satori", "https://www.pouet.net/prod.php?which=68795", "https://content.pouet.net/files/screenshots/00068/00068795.gif")
		],
		2016: [
			new Demo("everyway", "hoffman", "https://www.pouet.net/prod.php?which=67790", "https://content.pouet.net/files/screenshots/00067/00067790.png")
		],
		2015: [
			new Demo("hold-and-modify", "flt & cncd", "https://www.pouet.net/prod.php?which=66097", "https://content.pouet.net/files/screenshots/00066/00066097.jpg"),
			new Demo("emix", "epoch ft. trio tampere", "https://www.pouet.net/prod.php?which=66066", "https://content.pouet.net/files/screenshots/00066/00066066.jpg")
		],
		2014: [
			new Demo("black and white lies", "one studio off", "https://www.pouet.net/prod.php?which=63863", "https://content.pouet.net/files/screenshots/00063/00063863.jpg"),
			new Demo("intrinsic gravity", "still", "https://www.pouet.net/prod.php?which=64756", "https://content.pouet.net/files/screenshots/00064/00064756.jpg")
		],
		2013: [],
		2012: [],
		2011: [],
		2010: [
			new Demo("anoxia redux", "asd & minimalartifact", "https://www.pouet.net/prod.php?which=55990", "https://content.pouet.net/files/screenshots/00055/00055990.png")
		],
		2009: [],
		2008: [
			new Demo("passing", "still", "https://www.pouet.net/prod.php?which=51763", "https://content.pouet.net/files/screenshots/00051/00051763.jpg")
		],
		2007: [],
		2006: [
			new Demo("fr-055: 828", "farbrausch", "https://www.pouet.net/prod.php?which=29739", "https://content.pouet.net/files/screenshots/00029/00029739.jpg")
		],
		2005: [
			new Demo("ocean machine", "the black lotus", "https://www.pouet.net/prod.php?which=16337", "https://content.pouet.net/files/screenshots/00016/00016337.jpg")
		],
		2004: [],
		2003: [],
		2002: [
			new Demo("channel 5 sequence", "haujobb", "https://www.pouet.net/prod.php?which=5591", "https://content.pouet.net/files/screenshots/00005/00005591.jpg")
		],
		2001: [
			new Demo("energia", "sunflower", "https://www.pouet.net/prod.php?which=3290", "https://content.pouet.net/files/screenshots/00003/00003290.gif"),
			new Demo("gerbera", "moppi productions", "https://www.pouet.net/prod.php?which=3286", "https://content.pouet.net/files/screenshots/00003/00003286.jpg")
		],
		2000: [
			new Demo("incyber", "satori & aural planet", "https://www.pouet.net/prod.php?which=1164", "https://content.pouet.net/files/screenshots/00001/00001164.jpg")
		],
		1999: [
			new Demo("codename chinadoll", "katastro.fi", "https://www.pouet.net/prod.php?which=119", "https://content.pouet.net/files/screenshots/00000/00000119.jpg"),
			new Demo("zilog", "sunflower", "https://www.pouet.net/prod.php?which=294", "https://content.pouet.net/files/screenshots/00000/00000294.jpg"),
			new Demo("fall equals winter", "replay", "https://www.pouet.net/prod.php?which=501", "https://content.pouet.net/files/screenshots/00000/00000501.gif")
		],
		1998: [
			new Demo("te2-rb", "tpolm", "https://www.pouet.net/prod.php?which=117", "https://content.pouet.net/files/screenshots/00000/00000117.jpg")
		],
		1997: [],
		1996: []
	};

	let { url = "/favdemos" } = $$props;

	onMount(async () => {
		document.addEventListener("pointermove", function (event) {
			$$invalidate(0, hover_image_element.style.left = event.x + "px", hover_image_element);
			$$invalidate(0, hover_image_element.style.top = event.y + "px", hover_image_element);
		});
	});

	onDestroy(() => {
		
	});

	const writable_props = ['url'];

	FavDemos_svelte_Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FavDemos> was created with unknown prop '${key}'`);
	});

	const pointerenter_handler = demo => showImage(demo);
	const pointerleave_handler = () => hideImage();

	function img_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			hover_image_element = $$value;
			$$invalidate(0, hover_image_element);
		});
	}

	$$self.$$set = $$props => {
		if ('url' in $$props) $$invalidate(4, url = $$props.url);
	};

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		Bar: src_components_Bar_svelte,
		Router: Router_svelte,
		Link: src_Link_svelte,
		Route: Route_svelte,
		Footer: src_components_Footer_svelte,
		hover_image_element,
		showImage,
		hideImage,
		Demo,
		list,
		url
	});

	$$self.$inject_state = $$props => {
		if ('hover_image_element' in $$props) $$invalidate(0, hover_image_element = $$props.hover_image_element);
		if ('url' in $$props) $$invalidate(4, url = $$props.url);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		hover_image_element,
		showImage,
		hideImage,
		list,
		url,
		pointerenter_handler,
		pointerleave_handler,
		img_binding
	];
}

class FavDemos extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, FavDemos_svelte_instance, FavDemos_svelte_create_fragment, safe_not_equal, { url: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FavDemos",
			options,
			id: FavDemos_svelte_create_fragment.name
		});
	}

	get url() {
		throw new Error("<FavDemos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<FavDemos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const src_components_FavDemos_svelte = (FavDemos);

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/music.svelte.3.css!./src/components/music.svelte
var music_svelte = __webpack_require__(464);
;// CONCATENATED MODULE: ./src/components/music.svelte.3.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/music.svelte.3.css!./src/components/music.svelte

      
      
      
      
      
      
      
      
      

var music_svelte_options = {};

music_svelte_options.styleTagTransform = (styleTagTransform_default());
music_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      music_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
music_svelte_options.domAPI = (styleDomAPI_default());
music_svelte_options.insertStyleElement = (insertStyleElement_default());

var music_svelte_update = injectStylesIntoStyleTag_default()(music_svelte/* default */.Z, music_svelte_options);




       /* harmony default export */ const components_music_svelte = (music_svelte/* default */.Z && music_svelte/* default */.Z.locals ? music_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/music.svelte
/* src\components\music.svelte generated by Svelte v4.0.1 */


const { Object: music_svelte_Object_1 } = globals;






const music_svelte_file = "src\\components\\music.svelte";

function music_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[6] = i;
	return child_ctx;
}

function music_svelte_get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	child_ctx[9] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	child_ctx[9] = i;
	return child_ctx;
}

// (4:2) {#each Object.keys(audio_folders) as audio_folder, i}
function create_each_block_2(ctx) {
	let a;
	let t0_value = /*audio_folder*/ ctx[10] + "";
	let t0;
	let t1;
	let a_href_value;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[2](/*audio_folder*/ ctx[10]);
	}

	const block = {
		c: function create() {
			a = dom_element("a");
			t0 = dom_text(t0_value);
			t1 = space();
			attr_dev(a, "href", a_href_value = `#${/*audio_folder*/ ctx[10]}`);
			attr_dev(a, "class", "menu-item");
			add_location(a, music_svelte_file, 4, 3, 78);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t0);
			append_dev(a, t1);

			if (!mounted) {
				dispose = listen_dev(a, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(4:2) {#each Object.keys(audio_folders) as audio_folder, i}",
		ctx
	});

	return block;
}

// (3:1) <Bar>
function create_default_slot(ctx) {
	let each_1_anchor;
	let each_value_2 = ensure_array_like_dev(Object.keys(/*audio_folders*/ ctx[0]));
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Object, audio_folders, scroll_to_view*/ 1) {
				each_value_2 = ensure_array_like_dev(Object.keys(/*audio_folders*/ ctx[0]));
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(3:1) <Bar>",
		ctx
	});

	return block;
}

// (18:3) {#each Object.keys(audio_folders[audio_folder_key]) as audio_key, i}
function music_svelte_create_each_block_1(ctx) {
	let div1;
	let wave_audio_path_player;
	let wave_audio_path_player_src_value;
	let t0;
	let div0;

	const block = {
		c: function create() {
			div1 = dom_element("div");
			wave_audio_path_player = dom_element("wave-audio-path-player");
			t0 = space();
			div0 = dom_element("div");
			div0.textContent = `${/*audio_folders*/ ctx[0][/*audio_folder_key*/ ctx[4]][/*audio_key*/ ctx[7]].creation_date}`;
			if (!src_url_equal(wave_audio_path_player.src, wave_audio_path_player_src_value = /*audio_folders*/ ctx[0][/*audio_folder_key*/ ctx[4]][/*audio_key*/ ctx[7]].src)) set_custom_element_data(wave_audio_path_player, "src", wave_audio_path_player_src_value);
			set_custom_element_data(wave_audio_path_player, "class", "player svelte-1d9fbv");
			set_custom_element_data(wave_audio_path_player, "wave-width", "200");
			set_custom_element_data(wave_audio_path_player, "wave-height", "80");
			set_custom_element_data(wave_audio_path_player, "color", "black");
			set_custom_element_data(wave_audio_path_player, "wave-slider", "black");
			add_location(wave_audio_path_player, music_svelte_file, 19, 6, 493);
			attr_dev(div0, "class", "track-date");
			add_location(div0, music_svelte_file, 28, 6, 814);
			attr_dev(div1, "class", "track svelte-1d9fbv");
			add_location(div1, music_svelte_file, 18, 5, 466);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, wave_audio_path_player);
			append_dev(div1, t0);
			append_dev(div1, div0);
		},
		p: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: music_svelte_create_each_block_1.name,
		type: "each",
		source: "(18:3) {#each Object.keys(audio_folders[audio_folder_key]) as audio_key, i}",
		ctx
	});

	return block;
}

// (13:1) {#each Object.keys(audio_folders) as audio_folder_key, k}
function music_svelte_create_each_block(ctx) {
	let div0;
	let t1;
	let div1;
	let each_value_1 = ensure_array_like_dev(Object.keys(/*audio_folders*/ ctx[0][/*audio_folder_key*/ ctx[4]]));
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = music_svelte_create_each_block_1(music_svelte_get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			div0 = dom_element("div");
			div0.textContent = `${/*audio_folder_key*/ ctx[4]}`;
			t1 = space();
			div1 = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div0, "class", "title svelte-1d9fbv");
			add_location(div0, music_svelte_file, 13, 2, 310);
			attr_dev(div1, "class", "tracks svelte-1d9fbv");
			add_location(div1, music_svelte_file, 16, 2, 366);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div1, null);
				}
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*audio_folders, Object*/ 1) {
				each_value_1 = ensure_array_like_dev(Object.keys(/*audio_folders*/ ctx[0][/*audio_folder_key*/ ctx[4]]));
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = music_svelte_get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = music_svelte_create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div0);
				detach_dev(t1);
				detach_dev(div1);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: music_svelte_create_each_block.name,
		type: "each",
		source: "(13:1) {#each Object.keys(audio_folders) as audio_folder_key, k}",
		ctx
	});

	return block;
}

function music_svelte_create_fragment(ctx) {
	let main;
	let bar;
	let t0;
	let t1;
	let footer;
	let current;

	bar = new src_components_Bar_svelte({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let each_value = ensure_array_like_dev(Object.keys(/*audio_folders*/ ctx[0]));
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = music_svelte_create_each_block(music_svelte_get_each_context(ctx, each_value, i));
	}

	footer = new src_components_Footer_svelte({ $$inline: true });

	const block = {
		c: function create() {
			main = dom_element("main");
			create_component(bar.$$.fragment);
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			create_component(footer.$$.fragment);
			attr_dev(main, "class", "svelte-1d9fbv");
			add_location(main, music_svelte_file, 1, 0, 2);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(bar, main, null);
			append_dev(main, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(main, null);
				}
			}

			append_dev(main, t1);
			mount_component(footer, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const bar_changes = {};

			if (dirty & /*$$scope*/ 4096) {
				bar_changes.$$scope = { dirty, ctx };
			}

			bar.$set(bar_changes);

			if (dirty & /*Object, audio_folders*/ 1) {
				each_value = ensure_array_like_dev(Object.keys(/*audio_folders*/ ctx[0]));
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = music_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = music_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(main, t1);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(bar.$$.fragment, local);
			transitions_transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(bar.$$.fragment, local);
			transitions_transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(main);
			}

			destroy_component(bar);
			destroy_each(each_blocks, detaching);
			destroy_component(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: music_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function scroll_to_view(selector) {
	document.querySelector(selector).scrollIntoView({ behavior: 'smooth' });
}

function music_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Music', slots, []);

	class Demo {
		name;
		group;

		constructor(name, group) {
			this.name = name;
			this.group = group;
		}
	}

	const audio_folders = {"public":{"images":{"1690102042507_1[1].png":{"src":"images\\1690102042507_1[1].png","width":1616,"height":1448,"creation_date":"2023-8-12"},"paintings":{"unknown.png":{"src":"images\\paintings\\unknown.png","width":386,"height":381,"creation_date":"2023-8-12"},"adsg.png":{"src":"images\\paintings\\adsg.png","width":826,"height":877,"creation_date":"2023-8-12"},"868.png":{"src":"images\\paintings\\868.png","width":1918,"height":3074,"creation_date":"2023-8-12"},"302-o.png":{"src":"images\\paintings\\302-o.png","width":447,"height":373,"creation_date":"2023-8-12"},"1690102042507_1[1].png":{"src":"images\\paintings\\1690102042507_1[1].png"},"1690037672960_1 (1).png":{"src":"images\\paintings\\1690037672960_1 (1).png"},"1689957895824_2 (1).png":{"src":"images\\paintings\\1689957895824_2 (1).png"},"1137-a.png":{"src":"images\\paintings\\1137-a.png"},"1135-c.png":{"src":"images\\paintings\\1135-c.png"},"1132-a.png":{"src":"images\\paintings\\1132-a.png","width":1920,"height":2580,"creation_date":"2023-8-12"},"1131-a.png":{"src":"images\\paintings\\1131-a.png","width":1920,"height":2880,"creation_date":"2023-8-12"},"1130-b.png":{"src":"images\\paintings\\1130-b.png","width":1920,"height":2680,"creation_date":"2023-8-12"},"1130-a.png":{"src":"images\\paintings\\1130-a.png","width":1920,"height":2580,"creation_date":"2023-8-12"},"1129-pat-a.png":{"src":"images\\paintings\\1129-pat-a.png","width":2020,"height":1280,"creation_date":"2023-8-12"},"1124-2.png":{"src":"images\\paintings\\1124-2.png","width":1920,"height":2680,"creation_date":"2023-8-12"},"1123-e.png":{"src":"images\\paintings\\1123-e.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"1123-c.png":{"src":"images\\paintings\\1123-c.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1119.png":{"src":"images\\paintings\\1119.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1117-2.png":{"src":"images\\paintings\\1117-2.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1112.png":{"src":"images\\paintings\\1112.png","width":1170,"height":1860,"creation_date":"2023-8-12"},"1055.png":{"src":"images\\paintings\\1055.png","width":1920,"height":2600,"creation_date":"2023-8-12"},"1041.png":{"src":"images\\paintings\\1041.png","width":1920,"height":2600,"creation_date":"2023-8-12"},"1033.png":{"src":"images\\paintings\\1033.png","width":1920,"height":1480,"creation_date":"2023-8-12"},"1135-b (1).jpg":{"src":"images\\paintings\\1135-b (1).jpg"}},"graphic_design":{"nextversion952-in.png":{"src":"images\\graphic_design\\nextversion952-in.png","width":6000,"height":3486,"creation_date":"2023-8-12"},"995_out.png":{"src":"images\\graphic_design\\995_out.png","width":4416,"height":6092,"creation_date":"2023-8-12"},"940.png":{"src":"images\\graphic_design\\940.png","width":2495,"height":3230,"creation_date":"2023-8-12"},"938.png":{"src":"images\\graphic_design\\938.png","width":2825,"height":2959,"creation_date":"2023-8-12"},"934 out.png":{"src":"images\\graphic_design\\934 out.png","width":5000,"height":3168,"creation_date":"2023-8-12"},"919.png":{"src":"images\\graphic_design\\919.png","width":2334,"height":3500,"creation_date":"2023-8-12"},"713-output.png":{"src":"images\\graphic_design\\713-output.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"593.png":{"src":"images\\graphic_design\\593.png","width":4000,"height":4788,"creation_date":"2023-8-12"},"592-out.png":{"src":"images\\graphic_design\\592-out.png","width":2256,"height":3300,"creation_date":"2023-8-12"},"591.png":{"src":"images\\graphic_design\\591.png","width":2160,"height":3840,"creation_date":"2023-8-12"},"588.png":{"src":"images\\graphic_design\\588.png","width":3240,"height":2160,"creation_date":"2023-8-12"},"587.png":{"src":"images\\graphic_design\\587.png","width":1620,"height":1080,"creation_date":"2023-8-12"},"583-оут.png":{"src":"images\\graphic_design\\583-оут.png","width":1500,"height":1500,"creation_date":"2023-8-12"},"555.png":{"src":"images\\graphic_design\\555.png","width":2319,"height":3000,"creation_date":"2023-8-12"},"542.png":{"src":"images\\graphic_design\\542.png","width":2500,"height":2503,"creation_date":"2023-8-12"},"509.png":{"src":"images\\graphic_design\\509.png","width":2309,"height":2250,"creation_date":"2023-8-12"},"506-out.png":{"src":"images\\graphic_design\\506-out.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"505-01.png":{"src":"images\\graphic_design\\505-01.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"502.png":{"src":"images\\graphic_design\\502.png","width":2480,"height":2208,"creation_date":"2023-8-12"},"499.png":{"src":"images\\graphic_design\\499.png","width":3370,"height":4000,"creation_date":"2023-8-12"},"493.png":{"src":"images\\graphic_design\\493.png","width":596,"height":657,"creation_date":"2023-8-12"},"1x935_out.png":{"src":"images\\graphic_design\\1x935_out.png","width":3402,"height":5222,"creation_date":"2023-8-12"},"1x933.png":{"src":"images\\graphic_design\\1x933.png","width":5000,"height":3182,"creation_date":"2023-8-12"},"1x929.png":{"src":"images\\graphic_design\\1x929.png","width":5802,"height":8000,"creation_date":"2023-8-12"},"1x925 (1).png":{"src":"images\\graphic_design\\1x925 (1).png","width":2115,"height":3000,"creation_date":"2023-8-12"},"1155-out.png":{"src":"images\\graphic_design\\1155-out.png","width":3840,"height":4710,"creation_date":"2023-8-12"},"1093.png":{"src":"images\\graphic_design\\1093.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1090.png":{"src":"images\\graphic_design\\1090.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1089.png":{"src":"images\\graphic_design\\1089.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1087_out.png":{"src":"images\\graphic_design\\1087_out.png","width":1887,"height":1880,"creation_date":"2023-8-12"},"1052_out.png":{"src":"images\\graphic_design\\1052_out.png","width":4320,"height":4320,"creation_date":"2023-8-12"},"1048_out.png":{"src":"images\\graphic_design\\1048_out.png","width":4290,"height":5400,"creation_date":"2023-8-12"},"1030_in.png":{"src":"images\\graphic_design\\1030_in.png","width":2540,"height":3525,"creation_date":"2023-8-12"},"1013_out.png":{"src":"images\\graphic_design\\1013_out.png","width":4096,"height":4092,"creation_date":"2023-8-12"},"1008_out.png":{"src":"images\\graphic_design\\1008_out.png","width":4000,"height":4000,"creation_date":"2023-8-12"},"1007_out.png":{"src":"images\\graphic_design\\1007_out.png","width":3840,"height":3872,"creation_date":"2023-8-12"},"1006.png":{"src":"images\\graphic_design\\1006.png","width":3084,"height":4316,"creation_date":"2023-8-12"},"1005_out.png":{"src":"images\\graphic_design\\1005_out.png","width":2870,"height":4104,"creation_date":"2023-8-12"},"1004_out.png":{"src":"images\\graphic_design\\1004_out.png","width":2964,"height":4268,"creation_date":"2023-8-12"},"1002.png":{"src":"images\\graphic_design\\1002.png","width":3258,"height":4435,"creation_date":"2023-8-12"},"1001-b.png":{"src":"images\\graphic_design\\1001-b.png","width":4224,"height":4290,"creation_date":"2023-8-12"}},"generative":{"unknown2.png":{"src":"images\\generative\\unknown2.png","width":1104,"height":816,"creation_date":"2023-8-12"},"unknown.png":{"src":"images\\generative\\unknown.png","width":1254,"height":701,"creation_date":"2023-8-12"},"unknown (9).png":{"src":"images\\generative\\unknown (9).png"},"unknown (8).png":{"src":"images\\generative\\unknown (8).png"},"unknown (7).png":{"src":"images\\generative\\unknown (7).png"},"unknown (6).png":{"src":"images\\generative\\unknown (6).png"},"unknown (5).png":{"src":"images\\generative\\unknown (5).png"},"unknown (4).png":{"src":"images\\generative\\unknown (4).png"},"unknown (3).png":{"src":"images\\generative\\unknown (3).png"},"unknown (2).png":{"src":"images\\generative\\unknown (2).png"},"unknown (11).png":{"src":"images\\generative\\unknown (11).png"},"unknown (10).png":{"src":"images\\generative\\unknown (10).png"},"unknown (1).png":{"src":"images\\generative\\unknown (1).png"},"spectracer.png":{"src":"images\\generative\\spectracer.png"},"spectracer (5).png":{"src":"images\\generative\\spectracer (5).png"},"spectracer (4).png":{"src":"images\\generative\\spectracer (4).png"},"spectracer (3).png":{"src":"images\\generative\\spectracer (3).png"},"spectracer (2).png":{"src":"images\\generative\\spectracer (2).png"},"spectracer (1).png":{"src":"images\\generative\\spectracer (1).png"},"S138LuQAAAABJRU5ErkJggg.png":{"src":"images\\generative\\S138LuQAAAABJRU5ErkJggg.png","width":1920,"height":1023,"creation_date":"2023-8-12"},"P0y3BNk6U271AAAAAElFTkSuQmCC.png":{"src":"images\\generative\\P0y3BNk6U271AAAAAElFTkSuQmCC.png","width":640,"height":360,"creation_date":"2023-8-12"},"image (29).png":{"src":"images\\generative\\image (29).png"},"image (27).png":{"src":"images\\generative\\image (27).png"},"image (26).png":{"src":"images\\generative\\image (26).png"},"image (25).png":{"src":"images\\generative\\image (25).png"},"idklol-out.png":{"src":"images\\generative\\idklol-out.png","width":2854,"height":2804,"creation_date":"2023-8-12"},"Hhdk6NsUzCUWqcE4gnJieEEyKSKS8vt737P2VPffLRXxkbz7BZnD8Efmjz5R9f6P8CJBYa1YeaSScAAAAASUVORK5CYII.png":{"src":"images\\generative\\Hhdk6NsUzCUWqcE4gnJieEEyKSKS8vt737P2VPffLRXxkbz7BZnD8Efmjz5R9f6P8CJBYa1YeaSScAAAAASUVORK5CYII.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"Ha2Ch0D.png":{"src":"images\\generative\\Ha2Ch0D.png","width":1064,"height":681,"creation_date":"2023-8-12"},"flowers.png":{"src":"images\\generative\\flowers.png","width":1055,"height":682,"creation_date":"2023-8-12"},"FJ5S5FKWQAMjtjO.png":{"src":"images\\generative\\FJ5S5FKWQAMjtjO.png"},"FbPBBI7XkAIz10q.png":{"src":"images\\generative\\FbPBBI7XkAIz10q.png","width":680,"height":435,"creation_date":"2023-8-12"},"download.png":{"src":"images\\generative\\download.png","width":2560,"height":1440,"creation_date":"2023-8-12"},"767.png":{"src":"images\\generative\\767.png","width":2610,"height":1902,"creation_date":"2023-8-12"},"765.png":{"src":"images\\generative\\765.png"},"757-out.png":{"src":"images\\generative\\757-out.png","width":3000,"height":3000,"creation_date":"2023-8-12"},"746-rc-a.png":{"src":"images\\generative\\746-rc-a.png","width":1280,"height":720,"creation_date":"2023-8-12"},"717.png":{"src":"images\\generative\\717.png","width":2488,"height":1440,"creation_date":"2023-8-12"},"581-v1.png":{"src":"images\\generative\\581-v1.png","width":1155,"height":825,"creation_date":"2023-8-12"},"54.png":{"src":"images\\generative\\54.png","width":881,"height":496,"creation_date":"2023-8-12"},"172-a-toned.png":{"src":"images\\generative\\172-a-toned.png","width":893,"height":1374,"creation_date":"2023-8-12"},"FR56Q9mWQAA7U4X.jpg":{"src":"images\\generative\\FR56Q9mWQAA7U4X.jpg"},"FbPBBI7XkAIz10q.jpg":{"src":"images\\generative\\FbPBBI7XkAIz10q.jpg"},"FbBtUi9XoAEHFrV.jpg":{"src":"images\\generative\\FbBtUi9XoAEHFrV.jpg"},"3tycWV.jpg":{"src":"images\\generative\\3tycWV.jpg","width":640,"height":360,"creation_date":"2023-8-12"},"3lSyRh.jpg":{"src":"images\\generative\\3lSyRh.jpg","width":800,"height":450,"creation_date":"2023-8-12"},"capture - 2021-02-23T161035.355.webm":{"src":"images\\generative\\capture - 2021-02-23T161035.355.webm","width":640,"height":360,"creation_date":"2023-8-12"},"capture (59).webm":{"src":"images\\generative\\capture (59).webm","width":1000,"height":1000,"creation_date":"2023-8-12"},"WQC0rBl.mp4":{"src":"images\\generative\\WQC0rBl.mp4"},"pOiFoUR.mp4":{"src":"images\\generative\\pOiFoUR.mp4"},"OUT (3).mp4":{"src":"images\\generative\\OUT (3).mp4"},"OUT (2).mp4":{"src":"images\\generative\\OUT (2).mp4"},"OUT (1).mp4":{"src":"images\\generative\\OUT (1).mp4"},"chrome_xOHw6iea45.mp4":{"src":"images\\generative\\chrome_xOHw6iea45.mp4"},"chrome_UDlKJV4jdZ.mp4":{"src":"images\\generative\\chrome_UDlKJV4jdZ.mp4"},"chrome_RazqupSsRS.mp4":{"src":"images\\generative\\chrome_RazqupSsRS.mp4"},"chrome_ibz88JN1To.mp4":{"src":"images\\generative\\chrome_ibz88JN1To.mp4"},"chrome_foG6RANRoM.mp4":{"src":"images\\generative\\chrome_foG6RANRoM.mp4"},"capture - 2021-04-01T215056.436.mp4":{"src":"images\\generative\\capture - 2021-04-01T215056.436.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-24T174055.362.mp4":{"src":"images\\generative\\capture - 2021-02-24T174055.362.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-23T161035.355.mp4":{"src":"images\\generative\\capture - 2021-02-23T161035.355.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-23T135750.665.mp4":{"src":"images\\generative\\capture - 2021-02-23T135750.665.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-22T191650.873.mp4":{"src":"images\\generative\\capture - 2021-02-22T191650.873.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-15T183608.531.mp4":{"src":"images\\generative\\capture - 2021-02-15T183608.531.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-06T155448.767.mp4":{"src":"images\\generative\\capture - 2021-02-06T155448.767.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-04T235908.915.mp4":{"src":"images\\generative\\capture - 2021-02-04T235908.915.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-01-25T215853.813.mp4":{"src":"images\\generative\\capture - 2021-01-25T215853.813.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture (71).mp4":{"src":"images\\generative\\capture (71).mp4","width":800,"height":450,"creation_date":"2023-8-12"},"capture (61).mp4":{"src":"images\\generative\\capture (61).mp4","width":1100,"height":900,"creation_date":"2023-8-12"},"capture (60).mp4":{"src":"images\\generative\\capture (60).mp4","width":1100,"height":700,"creation_date":"2023-8-12"},"capture (51).mp4":{"src":"images\\generative\\capture (51).mp4","width":1000,"height":1000,"creation_date":"2023-8-12"},"1XTPsDi.mp4":{"src":"images\\generative\\1XTPsDi.mp4"},"166.mp4":{"src":"images\\generative\\166.mp4","width":640,"height":400,"creation_date":"2023-8-12"},"soDroUS.gif":{"src":"images\\generative\\soDroUS.gif","width":500,"height":500,"creation_date":"2023-8-12"},"129.gif":{"src":"images\\generative\\129.gif","width":400,"height":400,"creation_date":"2023-8-12"},"126.gif":{"src":"images\\generative\\126.gif","width":256,"height":256,"creation_date":"2023-8-12"},"123.gif":{"src":"images\\generative\\123.gif","width":512,"height":512,"creation_date":"2023-8-12"}},"noise_tex.webp":{"src":"images\\noise_tex.webp","width":720,"height":720,"creation_date":"2023-8-9"}},"audio":{"epic":{"hmmm.mp3":{"src":"audio\\epic\\hmmm.mp3","creation_date":"2023-8-12"},"590.mp3":{"src":"audio\\epic\\590.mp3","creation_date":"2023-8-12"},"589.mp3":{"src":"audio\\epic\\589.mp3","creation_date":"2023-8-12"},"576-fuji remix v1.mp3":{"src":"audio\\epic\\576-fuji remix v1.mp3","creation_date":"2023-8-12"},"575-2k.mp3":{"src":"audio\\epic\\575-2k.mp3","creation_date":"2023-8-12"},"574-radiator .mp3":{"src":"audio\\epic\\574-radiator .mp3","creation_date":"2023-8-12"},"570 - mark thing wip.mp3":{"src":"audio\\epic\\570 - mark thing wip.mp3","creation_date":"2023-8-12"},"560-v2.mp3":{"src":"audio\\epic\\560-v2.mp3","creation_date":"2023-8-12"},"527.mp3":{"src":"audio\\epic\\527.mp3","creation_date":"2023-8-12"},"524.mp3":{"src":"audio\\epic\\524.mp3","creation_date":"2023-8-12"},"515.mp3":{"src":"audio\\epic\\515.mp3","creation_date":"2023-8-12"},"481.mp3":{"src":"audio\\epic\\481.mp3","creation_date":"2023-8-12"},"465.mp3":{"src":"audio\\epic\\465.mp3","creation_date":"2023-8-12"},"460.mp3":{"src":"audio\\epic\\460.mp3","creation_date":"2023-8-12"},"330.mp3":{"src":"audio\\epic\\330.mp3","creation_date":"2023-8-12"},"319.mp3":{"src":"audio\\epic\\319.mp3","creation_date":"2023-8-12"},"316.mp3":{"src":"audio\\epic\\316.mp3","creation_date":"2023-8-12"},"309 not te4no.mp3":{"src":"audio\\epic\\309 not te4no.mp3","creation_date":"2023-8-12"},"257-2.mp3":{"src":"audio\\epic\\257-2.mp3","creation_date":"2023-8-12"},"256.mp3":{"src":"audio\\epic\\256.mp3","creation_date":"2023-8-12"},"255-v2 - Copy.mp3":{"src":"audio\\epic\\255-v2 - Copy.mp3","creation_date":"2023-8-12"},"254.mp3":{"src":"audio\\epic\\254.mp3","creation_date":"2023-8-12"},"244.mp3":{"src":"audio\\epic\\244.mp3","creation_date":"2023-8-12"},"236.mp3":{"src":"audio\\epic\\236.mp3","creation_date":"2023-8-12"},"222.mp3":{"src":"audio\\epic\\222.mp3","creation_date":"2023-8-12"},"219.mp3":{"src":"audio\\epic\\219.mp3","creation_date":"2023-8-12"},"138.mp3":{"src":"audio\\epic\\138.mp3","creation_date":"2023-8-12"}},"cool":{"wip4e.mp3":{"src":"audio\\cool\\wip4e.mp3","creation_date":"2023-8-12"},"jajaja.mp3":{"src":"audio\\cool\\jajaja.mp3","creation_date":"2023-8-12"},"932.mp3":{"src":"audio\\cool\\932.mp3","creation_date":"2023-8-12"},"927.mp3":{"src":"audio\\cool\\927.mp3","creation_date":"2023-8-12"},"926.mp3":{"src":"audio\\cool\\926.mp3","creation_date":"2023-8-12"},"836.mp3":{"src":"audio\\cool\\836.mp3","creation_date":"2023-8-12"},"801.mp3":{"src":"audio\\cool\\801.mp3","creation_date":"2023-8-12"},"797-b.mp3":{"src":"audio\\cool\\797-b.mp3","creation_date":"2023-8-12"},"730.mp3":{"src":"audio\\cool\\730.mp3","creation_date":"2023-8-12"},"692.mp3":{"src":"audio\\cool\\692.mp3","creation_date":"2023-8-12"},"691.mp3":{"src":"audio\\cool\\691.mp3","creation_date":"2023-8-12"},"690_unnoised_more.mp3":{"src":"audio\\cool\\690_unnoised_more.mp3","creation_date":"2023-8-12"},"662.mp3":{"src":"audio\\cool\\662.mp3","creation_date":"2023-8-12"},"642 other.mp3":{"src":"audio\\cool\\642 other.mp3","creation_date":"2023-8-12"},"626.mp3":{"src":"audio\\cool\\626.mp3","creation_date":"2023-8-12"},"1244 ok 2023-08-07 1915.mp3":{"src":"audio\\cool\\1244 ok 2023-08-07 1915.mp3","creation_date":"2023-8-12"},"1243 2023-08-07 1919.mp3":{"src":"audio\\cool\\1243 2023-08-07 1919.mp3","creation_date":"2023-8-12"},"1188 2023-08-07 1946.mp3":{"src":"audio\\cool\\1188 2023-08-07 1946.mp3","creation_date":"2023-8-12"},"1187 2023-03-20 2255.mp3":{"src":"audio\\cool\\1187 2023-03-20 2255.mp3","creation_date":"2023-8-12"},"1180 2023-03-13 vcv.mp3":{"src":"audio\\cool\\1180 2023-03-13 vcv.mp3","creation_date":"2023-8-12"},"1162.mp3":{"src":"audio\\cool\\1162.mp3","creation_date":"2023-8-12"},"1140.mp3":{"src":"audio\\cool\\1140.mp3","creation_date":"2023-8-12"},"1121.mp3":{"src":"audio\\cool\\1121.mp3","creation_date":"2023-8-12"},"1116-toomb-ludum-dare.mp3":{"src":"audio\\cool\\1116-toomb-ludum-dare.mp3","creation_date":"2023-8-12"},"1099-toomb4.mp3":{"src":"audio\\cool\\1099-toomb4.mp3","creation_date":"2023-8-12"},"1098-toomb3 (1).mp3":{"src":"audio\\cool\\1098-toomb3 (1).mp3","creation_date":"2023-8-12"},"1096-toomb2.mp3":{"src":"audio\\cool\\1096-toomb2.mp3","creation_date":"2023-8-12"},"1095-toomb.mp3":{"src":"audio\\cool\\1095-toomb.mp3","creation_date":"2023-8-12"},"1071.mp3":{"src":"audio\\cool\\1071.mp3","creation_date":"2023-8-12"},"1069.mp3":{"src":"audio\\cool\\1069.mp3","creation_date":"2023-8-12"},"1034.mp3":{"src":"audio\\cool\\1034.mp3","creation_date":"2023-8-12"},"1025.mp3":{"src":"audio\\cool\\1025.mp3","creation_date":"2023-8-12"},"1021.mp3":{"src":"audio\\cool\\1021.mp3","creation_date":"2023-8-12"},"1014.mp3":{"src":"audio\\cool\\1014.mp3","creation_date":"2023-8-12"}}}}}["public"]["audio"];
	let { url = "/favdemos" } = $$props;

	onMount(async () => {
		
	});

	onDestroy(() => {
		
	});

	const writable_props = ['url'];

	music_svelte_Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Music> was created with unknown prop '${key}'`);
	});

	const click_handler = audio_folder => {
		scroll_to_view(`#${audio_folder}`);
	};

	$$self.$$set = $$props => {
		if ('url' in $$props) $$invalidate(1, url = $$props.url);
	};

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		Bar: src_components_Bar_svelte,
		Router: Router_svelte,
		Link: src_Link_svelte,
		Route: Route_svelte,
		Footer: src_components_Footer_svelte,
		scroll_to_view,
		Demo,
		audio_folders,
		url
	});

	$$self.$inject_state = $$props => {
		if ('url' in $$props) $$invalidate(1, url = $$props.url);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [audio_folders, url, click_handler];
}

class Music extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, music_svelte_instance, music_svelte_create_fragment, safe_not_equal, { url: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Music",
			options,
			id: music_svelte_create_fragment.name
		});
	}

	get url() {
		throw new Error("<Music>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Music>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const src_components_music_svelte = (Music);

;// CONCATENATED MODULE: ./src/components/lib/Img.svelte
/* src\components\lib\Img.svelte generated by Svelte v4.0.1 */



const Img_svelte_file = "src\\components\\lib\\Img.svelte";

function Img_svelte_create_fragment(ctx) {
	let img;
	let img_levels = [/*$$restProps*/ ctx[0]];
	let img_data = {};

	for (let i = 0; i < img_levels.length; i += 1) {
		img_data = utils_assign(img_data, img_levels[i]);
	}

	const block = {
		c: function create() {
			img = dom_element("img");
			set_attributes(img, img_data);
			add_location(img, Img_svelte_file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, [dirty]) {
			set_attributes(img, img_data = get_spread_update(img_levels, [dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0]]));
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Img_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Img_svelte_instance($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Img', slots, []);

	$$self.$$set = $$new_props => {
		$$props = utils_assign(utils_assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
	};

	return [$$restProps];
}

class Img extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, Img_svelte_instance, Img_svelte_create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Img",
			options,
			id: Img_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const Img_svelte = (Img);
;// CONCATENATED MODULE: ./src/components/lib/dijkstra.js
/******************************************************************************
 * Created 2008-08-19.
 *
 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
 *
 * Copyright (C) 2008
 *   Wyatt Baldwin <self@wyattbaldwin.com>
 *   All rights reserved
 *
 * Licensed under the MIT license.
 *
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *****************************************************************************/
const dijkstra = {
  single_source_shortest_paths: function (graph, s, d) {
    // Predecessor map for each node that has been encountered.
    // node ID => predecessor node ID
    var predecessors = {};

    // Costs of shortest paths from s to all nodes encountered.
    // node ID => cost
    var costs = {};
    costs[s] = 0;

    // Costs of shortest paths from s to all nodes encountered; differs from
    // `costs` in that it provides easy access to the node that currently has
    // the known shortest path from s.
    // XXX: Do we actually need both `costs` and `open`?
    var open = new dijkstra_BinaryHeap(function (x) {
      return x.cost;
    });
    open.push({ value: s, cost: 0 });

    var closest,
      u,
      cost_of_s_to_u,
      adjacent_nodes,
      cost_of_e,
      cost_of_s_to_u_plus_cost_of_e,
      cost_of_s_to_v,
      first_visit;
    while (open.size()) {
      // In the nodes remaining in graph that have a known cost from s,
      // find the node, u, that currently has the shortest path from s.
      closest = open.pop();
      u = closest.value;
      cost_of_s_to_u = closest.cost;

      // Get nodes adjacent to u...
      adjacent_nodes = graph(u) || {};

      // ...and explore the edges that connect u to those nodes, updating
      // the cost of the shortest paths to any or all of those nodes as
      // necessary. v is the node across the current edge from u.
      for (var v in adjacent_nodes) {
        // Get the cost of the edge running from u to v.
        cost_of_e = adjacent_nodes[v];

        // Cost of s to u plus the cost of u to v across e--this is *a*
        // cost from s to v that may or may not be less than the current
        // known cost to v.
        cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

        // If we haven't visited v yet OR if the current known cost from s to
        // v is greater than the new cost we just found (cost of s to u plus
        // cost of u to v across e), update v's cost in the cost list and
        // update v's predecessor in the predecessor list (it's now u).
        cost_of_s_to_v = costs[v];
        first_visit = typeof costs[v] === 'undefined';
        if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
          costs[v] = cost_of_s_to_u_plus_cost_of_e;
          open.push({ value: v, cost: cost_of_s_to_u_plus_cost_of_e });
          predecessors[v] = u;
        }
      }
    }

    if (typeof costs[d] === 'undefined') {
      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
      throw new Error(msg);
    }

    return predecessors;
  },

  extract_shortest_path_from_predecessor_list: function (predecessors, d) {
    var nodes = [];
    var u = d;
    var predecessor;
    while (u) {
      nodes.push(u);
      predecessor = predecessors[u];
      u = predecessors[u];
    }
    nodes.reverse();
    return nodes;
  },

  find_path: function (graph, s, d) {
    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
    return dijkstra.extract_shortest_path_from_predecessor_list(
      predecessors,
      d
    );
  }

  // test: function() {
  //   // A B C
  //   // D E F
  //   // G H I
  //   graph = function (key) {
  //     switch (key) {
  //       case 'a': return {b: 10, d: 1};
  //       case 'b': return {a: 1, c: 1, e: 1};
  //       case 'c': return {b: 1, f: 1};
  //       case 'd': return {a: 1, e: 1, g: 1};
  //       case 'e': return {b: 1, d: 1, f: 1, h: 1};
  //       case 'f': return {c: 1, e: 1, i: 1};
  //       case 'g': return {d: 1, h: 1};
  //       case 'h': return {e: 1, g: 1, i: 1};
  //       case 'i': return {f: 1, h: 1};
  //     }
  //   };
  //   var path = dijkstra.find_path(graph, 'a', 'i');
  //   if (path.join() !== ['a', 'd', 'e', 'f', 'i'].join()) {
  //     throw new Error('Path finding error!');
  //   }
  // }
};

function dijkstra_BinaryHeap(scoreFunction) {
  this.content = [];
  this.scoreFunction = scoreFunction;
}

dijkstra_BinaryHeap.prototype = {
  push: function (element) {
    // Add the new element to the end of the array.
    this.content.push(element);
    // Allow it to bubble up.
    this.bubbleUp(this.content.length - 1);
  },

  pop: function () {
    // Store the first element so we can return it later.
    var result = this.content[0];
    // Get the element at the end of the array.
    var end = this.content.pop();
    // If there are any elements left, put the end element at the
    // start, and let it sink down.
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0);
    }
    return result;
  },

  remove: function (node) {
    var len = this.content.length;
    // To remove a value, we must search through the array to find
    // it.
    for (var i = 0; i < len; i++) {
      if (this.content[i] === node) {
        // When it is found, the process seen in 'pop' is repeated
        // to fill up the hole.
        var end = this.content.pop();
        if (i !== len - 1) {
          this.content[i] = end;
          if (this.scoreFunction(end) < this.scoreFunction(node))
            this.bubbleUp(i);
          else this.sinkDown(i);
        }
        return;
      }
    }
    throw new Error('Node not found.');
  },

  size: function () {
    return this.content.length;
  },

  bubbleUp: function (n) {
    // Fetch the element that has to be moved.
    var element = this.content[n];
    // When at 0, an element can not go up any further.
    while (n > 0) {
      // Compute the parent element's index, and fetch it.
      var parentN = Math.floor((n + 1) / 2) - 1,
        parent = this.content[parentN];
      // Swap the elements if the parent is greater.
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
        this.content[parentN] = element;
        this.content[n] = parent;
        // Update 'n' to continue at the new position.
        n = parentN;
      }
      // Found a parent that is less, no need to move it further.
      else {
        break;
      }
    }
  },

  sinkDown: function (n) {
    // Look up the target element and its score.
    var length = this.content.length,
      element = this.content[n],
      elemScore = this.scoreFunction(element);

    while (true) {
      // Compute the indices of the child elements.
      var child2N = (n + 1) * 2,
        child1N = child2N - 1;
      // This is used to store the new position of the element,
      // if any.
      var swap = null;
      // If the first child exists (is inside the array)...
      if (child1N < length) {
        // Look it up and compute its score.
        var child1 = this.content[child1N],
          child1Score = this.scoreFunction(child1);
        // If the score is less than our element's, we need to swap.
        if (child1Score < elemScore) swap = child1N;
      }
      // Do the same checks for the other child.
      if (child2N < length) {
        var child2 = this.content[child2N],
          child2Score = this.scoreFunction(child2);
        if (child2Score < (swap === null ? elemScore : child1Score))
          swap = child2N;
      }

      // If the element needs to be moved, swap it, and continue.
      if (swap != null) {
        this.content[n] = this.content[swap];
        this.content[swap] = element;
        n = swap;
      }
      // Otherwise, we are done.
      else {
        break;
      }
    }
  }
};

;// CONCATENATED MODULE: ./src/components/lib/layout.js


function round(n) {
  return Math.round(n * 100 + Number.EPSILON) / 100;
}

function ratio(width, height) {
  return round(width / height);
}

function scaleHeight(width, ratio) {
  return round(width / ratio);
}

function scaleWidth(height, ratio) {
  return round(height * ratio);
}

function getRowHeight(row, containerWidth, gutter) {
  const rowWidth = containerWidth - (row.length - 1) * gutter;
  const rowAspectRatio = row.reduce((acc, { ratio }) => acc + ratio, 0);
  return scaleHeight(rowWidth, rowAspectRatio);
}

function cost(images, start, end, containerWidth, targetHeight, gutter) {
  const row = images.slice(start, end);
  const rowHeight = getRowHeight(row, containerWidth, gutter);
  return Math.pow(Math.abs(rowHeight - targetHeight), 2);
}

function calcSeekLimit(containerWidth, targetRowHeight) {
  if (containerWidth < 420) {
    // limit to two nodes if the container is narrow
    return 2;
  }

  // find how many 3/4 portrait pictures will fit in an ideal row
  const count = ratio(containerWidth, targetRowHeight) / 0.75;
  return Math.round(count * 1.5);
}

/* harmony default export */ function layout({
  images,
  containerWidth,
  targetHeight,
  gutter = 2,
  seekLimit = calcSeekLimit,
  byRow = false
} = {}) {
  // clone the images, and set ratio and initial scaled width / height
  const _images = images.map((image, index) => {
    return {
      ...image,
      index,
      ratio: ratio(image.width, image.height)
    };
  });

  const nodeSeekLimit = seekLimit(containerWidth, targetHeight);

  const graph = (start) => {
    const results = {};
    start = +start;
    results[start] = 0;
    for (let i = start + 1; i < _images.length + 1; ++i) {
      if (i - start > nodeSeekLimit) {
        break;
      }
      results['' + i] = cost(
        _images,
        start,
        i,
        containerWidth,
        targetHeight,
        gutter
      );
    }
    return results;
  };

  const path = dijkstra.find_path(graph, '0', _images.length);

  const rows = [];
  const scaledImages = [];
  for (let i = 0; i < path.length; i++) {
    if (path[i + 1]) {
      const row = _images.slice(+path[i], +path[i + 1]);
      const isLastRow = i === path.length - 2;

      // scale row
      const rowHeight = getRowHeight(row, containerWidth, gutter);
      row.forEach((image, index) => {
        image.scaledWidth = scaleWidth(rowHeight, image.ratio); //.toFixed(1);
        image.scaledHeight = rowHeight;
        image.scaledWidthPc = round((image.scaledWidth / containerWidth) * 100);

        if (index === row.length - 1) {
          image.isLastInRow = true;
        }
        image.isLastRow = isLastRow;

        scaledImages.push(image);
      });
      rows.push(row);
    }
  }

  if (byRow) {
    return rows;
  } else {
    return scaledImages;
  }
}

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Gallery.svelte.10.css!./src/components/Gallery.svelte
var Gallery_svelte = __webpack_require__(25);
;// CONCATENATED MODULE: ./src/components/Gallery.svelte.10.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Gallery.svelte.10.css!./src/components/Gallery.svelte

      
      
      
      
      
      
      
      
      

var Gallery_svelte_options = {};

Gallery_svelte_options.styleTagTransform = (styleTagTransform_default());
Gallery_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      Gallery_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
Gallery_svelte_options.domAPI = (styleDomAPI_default());
Gallery_svelte_options.insertStyleElement = (insertStyleElement_default());

var Gallery_svelte_update = injectStylesIntoStyleTag_default()(Gallery_svelte/* default */.Z, Gallery_svelte_options);




       /* harmony default export */ const components_Gallery_svelte = (Gallery_svelte/* default */.Z && Gallery_svelte/* default */.Z.locals ? Gallery_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/Gallery.svelte
/* src\components\Gallery.svelte generated by Svelte v4.0.1 */





const Gallery_svelte_file = "src\\components\\Gallery.svelte";

function Gallery_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i].index;
	child_ctx[14] = list[i].ratio;
	child_ctx[15] = list[i].scaledHeight;
	child_ctx[16] = list[i].scaledWidth;
	child_ctx[17] = list[i].isLastInRow;
	child_ctx[18] = list[i].isLastRow;
	child_ctx[19] = list[i].scaledWidthPc;

	child_ctx[20] = object_without_properties(list[i], [
		"index",
		"ratio",
		"scaledHeight",
		"scaledWidth",
		"isLastInRow",
		"isLastRow",
		"scaledWidthPc"
	]);

	return child_ctx;
}

const Gallery_svelte_get_default_slot_changes = dirty => ({
	index: dirty & /*scaledImages*/ 16,
	image: dirty & /*scaledImages*/ 16
});

const Gallery_svelte_get_default_slot_context = ctx => ({
	index: /*index*/ ctx[13],
	image: /*image*/ ctx[20]
});

// (65:30)            
function fallback_block(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*imageComponent*/ ctx[0];

	function switch_props(ctx) {
		return {
			props: {
				class: "lozad",
				"data-src": window.LFS_PREPEND + /*image*/ ctx[20].src,
				width: /*image*/ ctx[20].width,
				height: /*image*/ ctx[20].height
			},
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty & /*scaledImages*/ 16) switch_instance_changes["data-src"] = window.LFS_PREPEND + /*image*/ ctx[20].src;
			if (dirty & /*scaledImages*/ 16) switch_instance_changes.width = /*image*/ ctx[20].width;
			if (dirty & /*scaledImages*/ 16) switch_instance_changes.height = /*image*/ ctx[20].height;

			if (dirty & /*imageComponent*/ 1 && switch_value !== (switch_value = /*imageComponent*/ ctx[0])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transitions_transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transitions_transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transitions_transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transitions_transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(65:30)            ",
		ctx
	});

	return block;
}

// (58:4) {#each scaledImages as { index, ratio, scaledHeight, scaledWidth, isLastInRow, isLastRow, scaledWidthPc, ...image }}
function Gallery_svelte_create_each_block(ctx) {
	let div;
	let t;
	let div_style_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], Gallery_svelte_get_default_slot_context);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[11](/*image*/ ctx[20]);
	}

	const block = {
		c: function create() {
			div = dom_element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			attr_dev(div, "class", "image svelte-1rbj9nr");

			attr_dev(div, "style", div_style_value = /*imgStyle*/ ctx[5]({
				scaledHeight: /*scaledHeight*/ ctx[15],
				scaledWidth: /*scaledWidth*/ ctx[16],
				isLastInRow: /*isLastInRow*/ ctx[17],
				isLastRow: /*isLastRow*/ ctx[18]
			}));

			add_location(div, Gallery_svelte_file, 74, 6, 1482);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div, null);
			}

			append_dev(div, t);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, scaledImages*/ 528)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, Gallery_svelte_get_default_slot_changes),
						Gallery_svelte_get_default_slot_context
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*imageComponent, scaledImages*/ 17)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*scaledImages*/ 16 && div_style_value !== (div_style_value = /*imgStyle*/ ctx[5]({
				scaledHeight: /*scaledHeight*/ ctx[15],
				scaledWidth: /*scaledWidth*/ ctx[16],
				isLastInRow: /*isLastInRow*/ ctx[17],
				isLastRow: /*isLastRow*/ ctx[18]
			}))) {
				attr_dev(div, "style", div_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Gallery_svelte_create_each_block.name,
		type: "each",
		source: "(58:4) {#each scaledImages as { index, ratio, scaledHeight, scaledWidth, isLastInRow, isLastRow, scaledWidthPc, ...image }}",
		ctx
	});

	return block;
}

function Gallery_svelte_create_fragment(ctx) {
	let div1;
	let div0;
	let div1_resize_listener;
	let current;
	let each_value = ensure_array_like_dev(/*scaledImages*/ ctx[4]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = Gallery_svelte_create_each_block(Gallery_svelte_get_each_context(ctx, each_value, i));
	}

	const out = i => transitions_transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div0, "class", "container svelte-1rbj9nr");
			set_style(div0, "width", /*width*/ ctx[3] + "px");
			toggle_class(div0, "hidden", !/*width*/ ctx[3]);
			add_location(div0, Gallery_svelte_file, 71, 2, 1219);
			attr_dev(div1, "class", "masonry svelte-1rbj9nr");
			scheduler_add_render_callback(() => /*div1_elementresize_handler*/ ctx[12].call(div1));
			toggle_class(div1, "stashed", /*hidden*/ ctx[1]);
			add_location(div1, Gallery_svelte_file, 70, 0, 1147);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			div1_resize_listener = add_iframe_resize_listener(div1, /*div1_elementresize_handler*/ ctx[12].bind(div1));
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*imgStyle, scaledImages, open_image_callback, window, imageComponent, $$scope*/ 565) {
				each_value = ensure_array_like_dev(/*scaledImages*/ ctx[4]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = Gallery_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transitions_transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = Gallery_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						transitions_transition_in(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty & /*width*/ 8) {
				set_style(div0, "width", /*width*/ ctx[3] + "px");
			}

			if (!current || dirty & /*width*/ 8) {
				toggle_class(div0, "hidden", !/*width*/ ctx[3]);
			}

			if (!current || dirty & /*hidden*/ 2) {
				toggle_class(div1, "stashed", /*hidden*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transitions_transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transitions_transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			destroy_each(each_blocks, detaching);
			div1_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Gallery_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Gallery_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Gallery', slots, ['default']);
	let { images = [] } = $$props;
	let { rowHeight = 220 } = $$props;
	let { gutter = 8 } = $$props;
	let { imageComponent = Img_svelte } = $$props;
	let { hidden = false } = $$props;
	let { open_image_callback } = $$props;
	let scaledImages = [];
	let width = 0;

	function imgStyle({ scaledWidth, scaledHeight, isLastInRow, isLastRow }) {
		let marginRight = gutter + 'px',
			flex = `0 0 ${scaledWidth}px`,
			marginBottom = isLastRow ? '0' : marginRight;

		if (isLastInRow) {
			marginRight = '0';
			flex = `1 1 ${scaledWidth - 4}px`;
		}

		return `height: ${scaledHeight}px; flex: ${flex}; margin-right: ${marginRight}; margin-bottom: ${marginBottom};`;
	}

	$$self.$$.on_mount.push(function () {
		if (open_image_callback === undefined && !('open_image_callback' in $$props || $$self.$$.bound[$$self.$$.props['open_image_callback']])) {
			console.warn("<Gallery> was created without expected prop 'open_image_callback'");
		}
	});

	const writable_props = [
		'images',
		'rowHeight',
		'gutter',
		'imageComponent',
		'hidden',
		'open_image_callback'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Gallery> was created with unknown prop '${key}'`);
	});

	const click_handler = image => {
		open_image_callback(window.LFS_PREPEND + image.src);
	};

	function div1_elementresize_handler() {
		width = this.clientWidth;
		$$invalidate(3, width);
	}

	$$self.$$set = $$props => {
		if ('images' in $$props) $$invalidate(6, images = $$props.images);
		if ('rowHeight' in $$props) $$invalidate(7, rowHeight = $$props.rowHeight);
		if ('gutter' in $$props) $$invalidate(8, gutter = $$props.gutter);
		if ('imageComponent' in $$props) $$invalidate(0, imageComponent = $$props.imageComponent);
		if ('hidden' in $$props) $$invalidate(1, hidden = $$props.hidden);
		if ('open_image_callback' in $$props) $$invalidate(2, open_image_callback = $$props.open_image_callback);
		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		Img: Img_svelte,
		layout: layout,
		images,
		rowHeight,
		gutter,
		imageComponent,
		hidden,
		open_image_callback,
		scaledImages,
		width,
		imgStyle
	});

	$$self.$inject_state = $$props => {
		if ('images' in $$props) $$invalidate(6, images = $$props.images);
		if ('rowHeight' in $$props) $$invalidate(7, rowHeight = $$props.rowHeight);
		if ('gutter' in $$props) $$invalidate(8, gutter = $$props.gutter);
		if ('imageComponent' in $$props) $$invalidate(0, imageComponent = $$props.imageComponent);
		if ('hidden' in $$props) $$invalidate(1, hidden = $$props.hidden);
		if ('open_image_callback' in $$props) $$invalidate(2, open_image_callback = $$props.open_image_callback);
		if ('scaledImages' in $$props) $$invalidate(4, scaledImages = $$props.scaledImages);
		if ('width' in $$props) $$invalidate(3, width = $$props.width);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*images, width, rowHeight, gutter*/ 456) {
			$: $$invalidate(4, scaledImages = layout({
				images,
				containerWidth: width || 1280,
				targetHeight: rowHeight,
				gutter
			}));
		}
	};

	return [
		imageComponent,
		hidden,
		open_image_callback,
		width,
		scaledImages,
		imgStyle,
		images,
		rowHeight,
		gutter,
		$$scope,
		slots,
		click_handler,
		div1_elementresize_handler
	];
}

class Gallery extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, Gallery_svelte_instance, Gallery_svelte_create_fragment, safe_not_equal, {
			images: 6,
			rowHeight: 7,
			gutter: 8,
			imageComponent: 0,
			hidden: 1,
			open_image_callback: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Gallery",
			options,
			id: Gallery_svelte_create_fragment.name
		});
	}

	get images() {
		throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set images(value) {
		throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rowHeight() {
		throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rowHeight(value) {
		throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gutter() {
		throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gutter(value) {
		throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get imageComponent() {
		throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set imageComponent(value) {
		throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hidden() {
		throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hidden(value) {
		throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open_image_callback() {
		throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open_image_callback(value) {
		throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const src_components_Gallery_svelte = (Gallery);

// EXTERNAL MODULE: ./node_modules/lozad/dist/lozad.min.js
var lozad_min = __webpack_require__(703);
var lozad_min_default = /*#__PURE__*/__webpack_require__.n(lozad_min);
;// CONCATENATED MODULE: ./src/components/svelte-zoom/matrix.js
class Matrix {
  constructor(svg) {
    this.svg = svg || document.createElementNS("http://www.w3.org/2000/svg", "svg")

    this.vtm = this.createSVGMatrix()

    this.x = 0
    this.y = 0

    this.captureScale = 1
  }

  clamp(scale, in_x, in_y, ratio) {
    let xx = (window.innerWidth - ratio.width) / 2
    let yy = (window.innerHeight - ratio.height) / 2

    let limit_max_right_formula = xx * scale + ratio.width * scale - window.innerWidth

    let same_x = Math.min(this.vtm.e * 1.0, 0)
    let same_y = Math.min(this.vtm.f * 1.0, 0)

    let value1 = in_x > 0 ? same_x : -(xx * scale)
    let value2 = in_x > 0 ? same_x : -limit_max_right_formula

    let limit_x_axis = this.vtm.e
    limit_x_axis = Math.max(value2, this.vtm.e)
    limit_x_axis = Math.min(value1, limit_x_axis)

    let limit_max_bottom_formula = yy * scale + ratio.height * scale - window.innerHeight
    let limit_max_top = in_y > 0 ? same_y : -(yy * scale)
    let limit_max_bottom = in_y > 0 ? same_y : -limit_max_bottom_formula

    let limit_y_axis = this.vtm.f
    limit_y_axis = Math.min(limit_max_top, limit_y_axis)
    limit_y_axis = Math.max(limit_y_axis, limit_max_bottom)

    this.vtm = this.createSVGMatrix().translate(limit_x_axis, limit_y_axis).scale(Math.max(this.vtm.a, 1))
  }

  createSVGMatrix() {
    return this.svg.createSVGMatrix()
  }

  move(x, y, in_x, in_y, ratio) {
    this.vtm = this.createSVGMatrix()
      .translate(this.x - x, this.y - y)
      .scale(this.vtm.a)

    this.clamp(this.vtm.a, in_x, in_y, ratio)
    return this.vtm
  }

  scale(xFactor, yFactor, origin, in_x, in_y, ratio, max, value, dir) {
    if ((value >= max || this.stop) && dir === 1) {
      this.stop = true
      if (!this.deb) {
        this.captureScale = this.vtm.a
        this.vtm = this.createSVGMatrix()
          .translate(origin.x, origin.y)
          .scale(max / this.captureScale)
          .translate(-origin.x, -origin.y)
          .translate(this.vtm.e, this.vtm.f)
          .scale(this.captureScale)

        this.deb = true
      }
      return this.vtm
    } else {
      this.stop = false
    }

    this.vtm = this.createSVGMatrix()
      .translate(origin.x, origin.y)
      .scale(xFactor, yFactor)
      .translate(-origin.x, -origin.y)
      .multiply(this.vtm)

    let pre_scale = Math.min(Math.max(1, this.vtm.a), max)

    this.clamp(pre_scale, in_x, in_y, ratio)

    return this.vtm
  }
}

;// CONCATENATED MODULE: ./src/components/svelte-zoom/velocity.js
class MultiTouchVelocity {
  constructor() {
    this.touchA = {
      clientX: 0,
      clientY: 0,
      t: 0,
      velocity: 1,
    }
    this.touchB = {
      clientX: 0,
      clientY: 0,
      t: 0,
      velocity: 1,
    }
  }
  down(touchA, touchB) {
    this.touchA = { clientX: touchA.clientX, clientY: touchA.clientY, t: Date.now(), velocity: 0 }
    this.touchB = { clientX: touchB.clientX, clientY: touchB.clientY, t: Date.now(), veloctiy: 0 }
  }
  calc(touch, ins) {
    var new_x = touch.clientX,
      new_y = touch.clientY,
      new_t = Date.now()

    var x_dist = new_x - ins.clientX,
      y_dist = new_y - ins.clientY,
      interval = new_t - ins.t
    var velocity = Math.sqrt(x_dist * x_dist + y_dist * y_dist) / interval
    ins.velocity = velocity
    // update values:
    ins.clientX = new_x
    ins.clientY = new_y
    ins.t = new_t
  }
  getVelocity(touchA, touchB) {
    this.calc(touchA, this.touchA)
    this.calc(touchB, this.touchB)
    return this.touchA.velocity + this.touchB.velocity
  }
}

// EXTERNAL MODULE: ./public/forbid.svg
var forbid = __webpack_require__(461);
var forbid_default = /*#__PURE__*/__webpack_require__.n(forbid);
;// CONCATENATED MODULE: ./src/components/svelte-zoom/other.js
function calculateAspectRatioFit(srcWidth, srcHeight, maxWidth, maxHeight) {
  var ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight)

  return { width: srcWidth * ratio, height: srcHeight * ratio, ratio }
}

function getDistance(touchA, touchB) {
  return Math.hypot(touchA.pageX - touchB.pageX, touchA.pageY - touchB.pageY)
}



// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/svelte-zoom/index.svelte.11.css!./src/components/svelte-zoom/index.svelte
var index_svelte = __webpack_require__(712);
;// CONCATENATED MODULE: ./src/components/svelte-zoom/index.svelte.11.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/svelte-zoom/index.svelte.11.css!./src/components/svelte-zoom/index.svelte

      
      
      
      
      
      
      
      
      

var index_svelte_options = {};

index_svelte_options.styleTagTransform = (styleTagTransform_default());
index_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      index_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
index_svelte_options.domAPI = (styleDomAPI_default());
index_svelte_options.insertStyleElement = (insertStyleElement_default());

var index_svelte_update = injectStylesIntoStyleTag_default()(index_svelte/* default */.Z, index_svelte_options);




       /* harmony default export */ const svelte_zoom_index_svelte = (index_svelte/* default */.Z && index_svelte/* default */.Z.locals ? index_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/svelte-zoom/index.svelte
/* src\components\svelte-zoom\index.svelte generated by Svelte v4.0.1 */








const index_svelte_file = "src\\components\\svelte-zoom\\index.svelte";

function index_svelte_create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let img_1;
	let img_1_src_value;
	let mounted;
	let dispose;

	let img_1_levels = [
		{ alt: /*alt*/ ctx[0] },
		{ class: "c-svelteZoom" },
		/*$$props*/ ctx[11],
		{ src: img_1_src_value = /*src*/ ctx[4] }
	];

	let img_data = {};

	for (let i = 0; i < img_1_levels.length; i += 1) {
		img_data = utils_assign(img_data, img_1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t = space();
			img_1 = dom_element("img");
			attr_dev(div0, "class", "close-button svelte-bmpzgc");
			add_location(div0, index_svelte_file, 4, 1, 172);
			set_attributes(img_1, img_data);
			toggle_class(img_1, "c-svelteZoom--contain", /*contain*/ ctx[6]);
			toggle_class(img_1, "c-svelteZoom--no-contain", !/*contain*/ ctx[6]);
			toggle_class(img_1, "c-svelteZoom--transition", /*smooth*/ ctx[1]);
			toggle_class(img_1, "c-svelteZoom--visible", /*contain*/ ctx[6]);
			toggle_class(img_1, "c-svelteZoom--hidden", /*contain*/ ctx[6] === null);
			toggle_class(img_1, "c-svelteZoom--willChange", /*willChange*/ ctx[7]);
			toggle_class(img_1, "svelte-bmpzgc", true);
			add_location(img_1, index_svelte_file, 11, 1, 281);
			attr_dev(div1, "class", "container svelte-bmpzgc");
			toggle_class(div1, "hidden", !/*opened*/ ctx[3]);
			add_location(div1, index_svelte_file, 2, 0, 32);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			div0.innerHTML = (forbid_default());
			append_dev(div1, t);
			append_dev(div1, img_1);
			/*img_1_binding*/ ctx[16](img_1);
			/*div1_binding*/ ctx[17](div1);

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*click_handler*/ ctx[15], false, false, false, false),
					listen_dev(img_1, "mousedown", /*mousedown*/ ctx[9], false, false, false, false),
					listen_dev(img_1, "touchstart", /*touchstart*/ ctx[10], false, false, false, false),
					listen_dev(img_1, "load", /*onLoad*/ ctx[8], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(img_1, img_data = get_spread_update(img_1_levels, [
				dirty[0] & /*alt*/ 1 && { alt: /*alt*/ ctx[0] },
				{ class: "c-svelteZoom" },
				dirty[0] & /*$$props*/ 2048 && /*$$props*/ ctx[11],
				dirty[0] & /*src*/ 16 && !src_url_equal(img_1.src, img_1_src_value = /*src*/ ctx[4]) && { src: img_1_src_value }
			]));

			toggle_class(img_1, "c-svelteZoom--contain", /*contain*/ ctx[6]);
			toggle_class(img_1, "c-svelteZoom--no-contain", !/*contain*/ ctx[6]);
			toggle_class(img_1, "c-svelteZoom--transition", /*smooth*/ ctx[1]);
			toggle_class(img_1, "c-svelteZoom--visible", /*contain*/ ctx[6]);
			toggle_class(img_1, "c-svelteZoom--hidden", /*contain*/ ctx[6] === null);
			toggle_class(img_1, "c-svelteZoom--willChange", /*willChange*/ ctx[7]);
			toggle_class(img_1, "svelte-bmpzgc", true);

			if (dirty[0] & /*opened*/ 8) {
				toggle_class(div1, "hidden", !/*opened*/ ctx[3]);
			}
		},
		i: utils_noop,
		o: utils_noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			/*img_1_binding*/ ctx[16](null);
			/*div1_binding*/ ctx[17](null);
			mounted = false;
			utils_run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: index_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function index_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Svelte_zoom', slots, []);
	let { alt } = $$props;
	let smooth = true;
	let touchScreen = false;
	let container_element;
	let opened = false;
	let src = '';
	let prev_mouse = [0, 0];
	let offs = [0, 0];
	let xY = { initX: 0, initY: 0, newX: 0, newY: 0 };
	let ratio, img;
	let matrix;
	let contain = null;
	let willChange = true;
	let velocity = new MultiTouchVelocity();
	let lastTap = { time: 0, x: 0, y: 0 };

	let scale = {
		scaling: false,
		x1: 0,
		x2: 0,
		y1: 0,
		y2: 0,
		lastHypo: 0,
		originX: 0,
		originY: 0,
		value: 1.0,
		max: 1
	};

	const open_image = _src => {
		$$invalidate(3, opened = true);
		$$invalidate(4, src = _src);
		offs[0] = 0;
		offs[1] = 1;
		scale.value = 1;
		let zoom = Math.pow(2, Math.log2(scale.value));
		$$invalidate(5, img.style.transform = `translate(${offs[0]}px, ${offs[1]}px) scale(${zoom})`, img);
		$$invalidate(5, img.style['transform-origin'] = `${0}px ${0}px`, img);
	};

	function fireDown(x, y) {
		xY.initX = x;
		xY.initY = y;
		matrix.x = matrix.vtm.e;
		matrix.y = matrix.vtm.f;
		$$invalidate(7, willChange = true);
	}

	function fireMove(x, y) {
		if (scale.scaling) return;
		let delta_mouse = [x - prev_mouse[0], y - prev_mouse[1]];
		offs[0] += delta_mouse[0];
		offs[1] += delta_mouse[1];
		let zoom = Math.pow(2, Math.log2(scale.value));
		$$invalidate(5, img.style.transform = `translate(${offs[0]}px, ${offs[1]}px) scale(${zoom})`, img);
		$$invalidate(5, img.style['transform-origin'] = `${0}px ${0}px`, img);
	}

	function fireUp() {
		matrix.x -= xY.newX;
		matrix.y -= xY.newY;
		scale.scaling = false;
		scale.lastHypo = 0;
		$$invalidate(1, smooth = true);
		$$invalidate(7, willChange = false);
	}

	function fireScale(touchA, touchB) {
		const xTouch = [Math.min(touchA.pageX, touchB.pageX), Math.max(touchA.pageX, touchB.pageX)];
		const yTouch = [Math.min(touchA.pageY, touchB.pageY), Math.max(touchA.pageY, touchB.pageY)];
		const W = xTouch[1] - xTouch[0];
		const centerX = W / 2 + xTouch[0];
		const H = yTouch[1] - yTouch[0];
		const centerY = H / 2 + yTouch[0];
		scale.originX = centerX;
		scale.originY = centerY;
		scale.lastHypo = Math.trunc(getDistance(touchA, touchB));
		$$invalidate(1, smooth = false);
	}

	function fireTapScale(x, y) {
		let scaleVtm = matrix.vtm.a;
		let scale_value = scaleVtm > 1 ? scaleVtm - 1 : scale.max / 2.5;
		let scale_factor = scaleVtm > 1 ? -1 : 1;
		const xFactor = 1 + scale_value * scale_factor;
		const yFactor = xFactor * window.innerHeight / window.innerWidth;
		let in_x = (window.innerWidth - ratio.width * Math.max(xFactor * scaleVtm, 1)) / 2;
		let in_y = (window.innerHeight - ratio.height * Math.max(xFactor * scaleVtm, 1)) / 2;

		const origin = {
			x: in_x > 0 ? window.innerWidth / 2 : x,
			y: in_y > 0 ? window.innerHeight / 2 : y
		};

		const mat = matrix.scale(xFactor, yFactor, origin, in_x, in_y, ratio, scale.max, scale.value * xFactor, scale_factor);
		scale.value = mat.d;
		$$invalidate(5, img.style.transform = `translate(${mat.e}px, ${mat.f}px) scale(${mat.d})`, img);
	}

	function fireScaleMove(touchA, touchB, e) {
		const hypo = getDistance(touchA, touchB);
		let f = hypo / scale.lastHypo;
		f = f >= 1 ? 1 : -1;
		const ff = velocity.getVelocity(touchA, touchB) || 1;
		const xFactor = 1 + 0.1 * ff * f;
		const yFactor = xFactor * window.innerHeight / window.innerWidth;
		let in_x = (window.innerWidth - ratio.width * matrix.vtm.a) / 2;
		let in_y = (window.innerHeight - ratio.height * matrix.vtm.a) / 2;

		const origin = {
			x: in_x > 0 ? window.innerWidth / 2 : scale.originX,
			y: in_y > 0 ? window.innerHeight / 2 : scale.originY
		};

		const mat = matrix.scale(xFactor, yFactor, origin, in_x, in_y, ratio, scale.max, scale.value * xFactor, f);
		$$invalidate(5, img.style.transform = `translate(${mat.e}px, ${mat.f}px) scale(${mat.d})`, img);
		scale.value = mat.d;
		scale.lastHypo = hypo;
		scale.scaling = true;
	}

	function fireManualZoom(dir) {
		const xFactor = 1 + 0.2 * dir;
		const yFactor = xFactor * window.innerHeight / window.innerWidth;
		let in_x = (window.innerWidth - ratio.width * matrix.vtm.a) / 2;
		let in_y = (window.innerHeight - ratio.height * matrix.vtm.a) / 2;

		const origin = {
			x: window.innerWidth / 2,
			y: window.innerHeight / 2
		};

		const mat = matrix.scale(xFactor, yFactor, origin, in_x, in_y, ratio, scale.max, scale.value * xFactor, dir);
		$$invalidate(5, img.style.transform = `translate(${mat.e}px,${mat.f}px) scale(${mat.d})`, img);
		scale.value = mat.d;
	}

	const zoomIn = () => fireManualZoom(1);
	const zoomOut = () => fireManualZoom(-1);

	function onResize() {
		onLoad();
		fireDown(0, 0);
		fireMove(0, 0);
		fireUp();
	}

	function onWheel(e) {
		e.preventDefault();
		const dir = e.deltaY < 0 ? 1 : -1;
		let prev = Math.pow(2, Math.log2(scale.value));

		if (dir > 0) {
			scale.value *= 1.2;
		} else {
			scale.value /= 1.2;
		}

		let zoom = Math.pow(2, Math.log2(scale.value));
		const ratio = 1 - zoom / prev;
		let img_aspect = img.width / img.height;
		let viewport_aspect = container_element.clientWidth / container_element.clientHeight;
		let mouse_pos = [e.clientX, e.clientY];
		offs[0] += (e.clientX - offs[0]) * ratio;
		offs[1] += (e.clientY - offs[1]) * ratio;
		$$invalidate(5, img.style.transform = `translate(${offs[0]}px, ${offs[1]}px) scale(${zoom})`, img);
		$$invalidate(5, img.style['transform-origin'] = `${0}px ${0}px`, img);
	}

	function onLoad() {
		const { naturalWidth, naturalHeight } = img;
		$$invalidate(6, contain = naturalWidth > window.innerWidth || naturalHeight > window.innerHeight);

		scale.max = naturalWidth > naturalHeight
		? Math.max(naturalWidth / window.innerWidth, 1)
		: Math.max(naturalHeight / window.innerHeight, 1);

		ratio = calculateAspectRatioFit(naturalWidth, naturalHeight, window.innerWidth, window.innerHeight);
	}

	onMount(() => {
		matrix = new Matrix();
		container_element.addEventListener('wheel', onWheel, { passive: false });
		container_element.addEventListener('resize', onResize);

		return () => {
			container_element.removeEventListener('wheel', onWheel);
			container_element.removeEventListener('resize', onResize);
		};
	});

	function onTouchStart(e) {
		touchScreen = true;
		$$invalidate(7, willChange = true);
		const isMultiTouch = e.touches.length === 2;
		const [touchA, touchB] = e.touches;
		scale.scaling = isMultiTouch;
		$$invalidate(1, smooth = false);

		if (isMultiTouch) {
			fireScale(touchA, touchB);
			velocity.down(touchA, touchB);
		} else {
			const { pageX, pageY } = touchA;
			var now = new Date().getTime();

			if (now - lastTap.time < 250 && Math.hypot(lastTap.x - pageX, lastTap.y - pageY) <= 20) {
				$$invalidate(1, smooth = true);
				fireTapScale(pageX, pageY);
			} else {
				fireDown(pageX, pageY);
			}

			lastTap = { time: now, x: pageX, y: pageY };
		}

		window.removeEventListener('touchmove', onTouchMove);
		window.removeEventListener('touchend', onTouchEnd);
		window.addEventListener('touchmove', onTouchMove);
		window.addEventListener('touchend', onTouchEnd);
	}

	function onTouchMove(e) {
		if (scale.scaling) {
			const [touchA, touchB] = e.touches;
			fireScaleMove(touchA, touchB);
		} else {
			fireMove(e.touches[0].pageX, e.touches[0].pageY);
		}
	}

	function onTouchEnd(e) {
		fireUp();
		window.removeEventListener('touchmove', onTouchMove);
		window.removeEventListener('touchend', onTouchEnd);
		window.removeEventListener('touchcancel', onTouchEnd);
	}

	function onMouseDown({ clientX, clientY }) {
		prev_mouse = [clientX, clientY];
		if (touchScreen) return;
		fireDown(clientX, clientY);
		$$invalidate(1, smooth = false);
		window.addEventListener('mousemove', onMouseMove);
		window.addEventListener('mouseup', onMouseUp);
	}

	function onMouseMove({ clientX, clientY }) {
		fireMove(clientX, clientY);
		prev_mouse = [clientX, clientY];
	}

	function onMouseUp() {
		window.removeEventListener('mousemove', onMouseMove);
		fireUp();
	}

	const mousedown = onMouseDown;
	const touchstart = onTouchStart;

	$$self.$$.on_mount.push(function () {
		if (alt === undefined && !('alt' in $$props || $$self.$$.bound[$$self.$$.props['alt']])) {
			console.warn("<Svelte_zoom> was created without expected prop 'alt'");
		}
	});

	const click_handler = () => {
		$$invalidate(3, opened = false);
	};

	function img_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			img = $$value;
			$$invalidate(5, img);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container_element = $$value;
			$$invalidate(2, container_element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = utils_assign(utils_assign({}, $$props), exclude_internal_props($$new_props)));
		if ('alt' in $$new_props) $$invalidate(0, alt = $$new_props.alt);
	};

	$$self.$capture_state = () => ({
		alt,
		Matrix: Matrix,
		MultiTouchVelocity: MultiTouchVelocity,
		ForbidIcon: (forbid_default()),
		calculateAspectRatioFit: calculateAspectRatioFit,
		getDistance: getDistance,
		onMount: onMount,
		smooth,
		touchScreen,
		container_element,
		opened,
		src,
		prev_mouse,
		offs,
		xY,
		ratio,
		img,
		matrix,
		contain,
		willChange,
		velocity,
		lastTap,
		scale,
		open_image,
		fireDown,
		fireMove,
		fireUp,
		fireScale,
		fireTapScale,
		fireScaleMove,
		fireManualZoom,
		zoomIn,
		zoomOut,
		onResize,
		onWheel,
		onLoad,
		onTouchStart,
		onTouchMove,
		onTouchEnd,
		onMouseDown,
		onMouseMove,
		onMouseUp,
		mousedown,
		touchstart
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = utils_assign(utils_assign({}, $$props), $$new_props));
		if ('alt' in $$props) $$invalidate(0, alt = $$new_props.alt);
		if ('smooth' in $$props) $$invalidate(1, smooth = $$new_props.smooth);
		if ('touchScreen' in $$props) touchScreen = $$new_props.touchScreen;
		if ('container_element' in $$props) $$invalidate(2, container_element = $$new_props.container_element);
		if ('opened' in $$props) $$invalidate(3, opened = $$new_props.opened);
		if ('src' in $$props) $$invalidate(4, src = $$new_props.src);
		if ('prev_mouse' in $$props) prev_mouse = $$new_props.prev_mouse;
		if ('offs' in $$props) offs = $$new_props.offs;
		if ('xY' in $$props) xY = $$new_props.xY;
		if ('ratio' in $$props) ratio = $$new_props.ratio;
		if ('img' in $$props) $$invalidate(5, img = $$new_props.img);
		if ('matrix' in $$props) matrix = $$new_props.matrix;
		if ('contain' in $$props) $$invalidate(6, contain = $$new_props.contain);
		if ('willChange' in $$props) $$invalidate(7, willChange = $$new_props.willChange);
		if ('velocity' in $$props) velocity = $$new_props.velocity;
		if ('lastTap' in $$props) lastTap = $$new_props.lastTap;
		if ('scale' in $$props) scale = $$new_props.scale;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		alt,
		smooth,
		container_element,
		opened,
		src,
		img,
		contain,
		willChange,
		onLoad,
		mousedown,
		touchstart,
		$$props,
		open_image,
		zoomIn,
		zoomOut,
		click_handler,
		img_1_binding,
		div1_binding
	];
}

class Svelte_zoom extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			index_svelte_instance,
			index_svelte_create_fragment,
			safe_not_equal,
			{
				alt: 0,
				open_image: 12,
				zoomIn: 13,
				zoomOut: 14
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Svelte_zoom",
			options,
			id: index_svelte_create_fragment.name
		});
	}

	get alt() {
		return this.$$.ctx[0];
	}

	set alt(alt) {
		this.$$set({ alt });
		flush();
	}

	get open_image() {
		return this.$$.ctx[12];
	}

	set open_image(value) {
		throw new Error("<Svelte_zoom>: Cannot set read-only property 'open_image'");
	}

	get zoomIn() {
		return this.$$.ctx[13];
	}

	set zoomIn(value) {
		throw new Error("<Svelte_zoom>: Cannot set read-only property 'zoomIn'");
	}

	get zoomOut() {
		return this.$$.ctx[14];
	}

	set zoomOut(value) {
		throw new Error("<Svelte_zoom>: Cannot set read-only property 'zoomOut'");
	}
}

/* harmony default export */ const components_svelte_zoom_index_svelte = (Svelte_zoom);

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/art.svelte.7.css!./src/components/art.svelte
var art_svelte = __webpack_require__(378);
;// CONCATENATED MODULE: ./src/components/art.svelte.7.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/art.svelte.7.css!./src/components/art.svelte

      
      
      
      
      
      
      
      
      

var art_svelte_options = {};

art_svelte_options.styleTagTransform = (styleTagTransform_default());
art_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      art_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
art_svelte_options.domAPI = (styleDomAPI_default());
art_svelte_options.insertStyleElement = (insertStyleElement_default());

var art_svelte_update = injectStylesIntoStyleTag_default()(art_svelte/* default */.Z, art_svelte_options);




       /* harmony default export */ const components_art_svelte = (art_svelte/* default */.Z && art_svelte/* default */.Z.locals ? art_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/art.svelte
/* src\components\art.svelte generated by Svelte v4.0.1 */


const { Object: art_svelte_Object_1, console: art_svelte_console_1 } = globals;









const art_svelte_file = "src\\components\\art.svelte";

function art_svelte_get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	child_ctx[14] = i;
	return child_ctx;
}

function art_svelte_get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	child_ctx[14] = i;
	return child_ctx;
}

// (4:2) {#each image_cats as image_cat, i}
function art_svelte_create_each_block_1(ctx) {
	let a;
	let t0_value = /*image_cat_names*/ ctx[4][/*i*/ ctx[14]] + "";
	let t0;
	let t1;
	let a_href_value;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[6](/*i*/ ctx[14]);
	}

	const block = {
		c: function create() {
			a = dom_element("a");
			t0 = dom_text(t0_value);
			t1 = space();
			attr_dev(a, "href", a_href_value = `#${/*image_cat_names*/ ctx[4][/*i*/ ctx[14]]}`);
			attr_dev(a, "class", "menu-item");
			add_location(a, art_svelte_file, 4, 3, 59);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t0);
			append_dev(a, t1);

			if (!mounted) {
				dispose = listen_dev(a, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: art_svelte_create_each_block_1.name,
		type: "each",
		source: "(4:2) {#each image_cats as image_cat, i}",
		ctx
	});

	return block;
}

// (3:1) <Bar>
function art_svelte_create_default_slot(ctx) {
	let each_1_anchor;
	let each_value_1 = ensure_array_like_dev(/*image_cats*/ ctx[3]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = art_svelte_create_each_block_1(art_svelte_get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*image_cat_names, scroll_to_view*/ 20) {
				each_value_1 = ensure_array_like_dev(/*image_cats*/ ctx[3]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = art_svelte_get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = art_svelte_create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: art_svelte_create_default_slot.name,
		type: "slot",
		source: "(3:1) <Bar>",
		ctx
	});

	return block;
}

// (14:1) {#each image_cats as image_cat, i}
function art_svelte_create_each_block(ctx) {
	let div1;
	let div0;
	let t0_value = /*image_cat_names*/ ctx[4][/*i*/ ctx[14]] + "";
	let t0;
	let div0_id_value;
	let t1;
	let svg;
	let path;
	let svg_style_value;
	let t2;
	let gallery;
	let current;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[8](/*i*/ ctx[14]);
	}

	gallery = new src_components_Gallery_svelte({
			props: {
				images: /*image_cat*/ ctx[12],
				hidden: /*image_cat_toggled*/ ctx[1][/*i*/ ctx[14]],
				open_image_callback: /*func*/ ctx[9]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = dom_element("div");
			div0 = dom_element("div");
			t0 = dom_text(t0_value);
			t1 = space();
			svg = svg_element("svg");
			path = svg_element("path");
			t2 = space();
			create_component(gallery.$$.fragment);
			attr_dev(div0, "class", "title svelte-1xdostg");
			attr_dev(div0, "id", div0_id_value = /*image_cat_names*/ ctx[4][/*i*/ ctx[14]]);
			add_location(div0, art_svelte_file, 16, 3, 496);
			attr_dev(path, "d", "M480-360 280-559h400L480-360Z");
			add_location(path, art_svelte_file, 23, 4, 752);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "height", "48");
			attr_dev(svg, "viewBox", "0 -960 960 960");
			attr_dev(svg, "width", "48");

			attr_dev(svg, "style", svg_style_value = /*image_cat_toggled*/ ctx[1][/*i*/ ctx[14]]
			? ""
			: "transform: scaleY(-1);");

			attr_dev(svg, "class", "svelte-1xdostg");
			add_location(svg, art_svelte_file, 19, 3, 581);
			attr_dev(div1, "class", "title-container svelte-1xdostg");
			add_location(div1, art_svelte_file, 15, 2, 400);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t0);
			append_dev(div1, t1);
			append_dev(div1, svg);
			append_dev(svg, path);
			insert_dev(target, t2, anchor);
			mount_component(gallery, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div1, "click", click_handler_1, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty & /*image_cat_toggled*/ 2 && svg_style_value !== (svg_style_value = /*image_cat_toggled*/ ctx[1][/*i*/ ctx[14]]
			? ""
			: "transform: scaleY(-1);")) {
				attr_dev(svg, "style", svg_style_value);
			}

			const gallery_changes = {};
			if (dirty & /*image_cat_toggled*/ 2) gallery_changes.hidden = /*image_cat_toggled*/ ctx[1][/*i*/ ctx[14]];
			if (dirty & /*zoom_widget*/ 1) gallery_changes.open_image_callback = /*func*/ ctx[9];
			gallery.$set(gallery_changes);
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(gallery.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(gallery.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
				detach_dev(t2);
			}

			destroy_component(gallery, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: art_svelte_create_each_block.name,
		type: "each",
		source: "(14:1) {#each image_cats as image_cat, i}",
		ctx
	});

	return block;
}

function art_svelte_create_fragment(ctx) {
	let main;
	let bar;
	let t0;
	let zoom;
	let t1;
	let t2;
	let footer;
	let current;

	bar = new src_components_Bar_svelte({
			props: {
				$$slots: { default: [art_svelte_create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let zoom_props = { src: "", alt: "..." };
	zoom = new components_svelte_zoom_index_svelte({ props: zoom_props, $$inline: true });
	/*zoom_binding*/ ctx[7](zoom);
	let each_value = ensure_array_like_dev(/*image_cats*/ ctx[3]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = art_svelte_create_each_block(art_svelte_get_each_context(ctx, each_value, i));
	}

	const out = i => transitions_transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	footer = new src_components_Footer_svelte({ $$inline: true });

	const block = {
		c: function create() {
			main = dom_element("main");
			create_component(bar.$$.fragment);
			t0 = space();
			create_component(zoom.$$.fragment);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			create_component(footer.$$.fragment);
			attr_dev(main, "class", "svelte-1xdostg");
			add_location(main, art_svelte_file, 1, 0, 2);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(bar, main, null);
			append_dev(main, t0);
			mount_component(zoom, main, null);
			append_dev(main, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(main, null);
				}
			}

			append_dev(main, t2);
			mount_component(footer, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const bar_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				bar_changes.$$scope = { dirty, ctx };
			}

			bar.$set(bar_changes);
			const zoom_changes = {};
			zoom.$set(zoom_changes);

			if (dirty & /*image_cats, image_cat_toggled, zoom_widget, image_cat_names*/ 27) {
				each_value = ensure_array_like_dev(/*image_cats*/ ctx[3]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = art_svelte_get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transitions_transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = art_svelte_create_each_block(child_ctx);
						each_blocks[i].c();
						transitions_transition_in(each_blocks[i], 1);
						each_blocks[i].m(main, t2);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(bar.$$.fragment, local);
			transitions_transition_in(zoom.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transitions_transition_in(each_blocks[i]);
			}

			transitions_transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(bar.$$.fragment, local);
			transitions_transition_out(zoom.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transitions_transition_out(each_blocks[i]);
			}

			transitions_transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(main);
			}

			destroy_component(bar);
			/*zoom_binding*/ ctx[7](null);
			destroy_component(zoom);
			destroy_each(each_blocks, detaching);
			destroy_component(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: art_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function art_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Art', slots, []);
	let zoom_widget;
	let observer = lozad_min_default()();
	observer.observe();

	window.addEventListener('DOMContentLoaded', function () {
		observer = lozad_min_default()();
		observer.observe();
	});

	function scroll_to_view(selector) {
		$$invalidate(1, image_cat_toggled[image_cat_names.indexOf(selector.replace("#", ""))] = false, image_cat_toggled);
		document.querySelector(selector).scrollIntoView({ behavior: 'smooth' });
	}

	const image_folders = {"public":{"images":{"1690102042507_1[1].png":{"src":"images\\1690102042507_1[1].png","width":1616,"height":1448,"creation_date":"2023-8-12"},"paintings":{"unknown.png":{"src":"images\\paintings\\unknown.png","width":386,"height":381,"creation_date":"2023-8-12"},"adsg.png":{"src":"images\\paintings\\adsg.png","width":826,"height":877,"creation_date":"2023-8-12"},"868.png":{"src":"images\\paintings\\868.png","width":1918,"height":3074,"creation_date":"2023-8-12"},"302-o.png":{"src":"images\\paintings\\302-o.png","width":447,"height":373,"creation_date":"2023-8-12"},"1690102042507_1[1].png":{"src":"images\\paintings\\1690102042507_1[1].png"},"1690037672960_1 (1).png":{"src":"images\\paintings\\1690037672960_1 (1).png"},"1689957895824_2 (1).png":{"src":"images\\paintings\\1689957895824_2 (1).png"},"1137-a.png":{"src":"images\\paintings\\1137-a.png"},"1135-c.png":{"src":"images\\paintings\\1135-c.png"},"1132-a.png":{"src":"images\\paintings\\1132-a.png","width":1920,"height":2580,"creation_date":"2023-8-12"},"1131-a.png":{"src":"images\\paintings\\1131-a.png","width":1920,"height":2880,"creation_date":"2023-8-12"},"1130-b.png":{"src":"images\\paintings\\1130-b.png","width":1920,"height":2680,"creation_date":"2023-8-12"},"1130-a.png":{"src":"images\\paintings\\1130-a.png","width":1920,"height":2580,"creation_date":"2023-8-12"},"1129-pat-a.png":{"src":"images\\paintings\\1129-pat-a.png","width":2020,"height":1280,"creation_date":"2023-8-12"},"1124-2.png":{"src":"images\\paintings\\1124-2.png","width":1920,"height":2680,"creation_date":"2023-8-12"},"1123-e.png":{"src":"images\\paintings\\1123-e.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"1123-c.png":{"src":"images\\paintings\\1123-c.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1119.png":{"src":"images\\paintings\\1119.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1117-2.png":{"src":"images\\paintings\\1117-2.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1112.png":{"src":"images\\paintings\\1112.png","width":1170,"height":1860,"creation_date":"2023-8-12"},"1055.png":{"src":"images\\paintings\\1055.png","width":1920,"height":2600,"creation_date":"2023-8-12"},"1041.png":{"src":"images\\paintings\\1041.png","width":1920,"height":2600,"creation_date":"2023-8-12"},"1033.png":{"src":"images\\paintings\\1033.png","width":1920,"height":1480,"creation_date":"2023-8-12"},"1135-b (1).jpg":{"src":"images\\paintings\\1135-b (1).jpg"}},"graphic_design":{"nextversion952-in.png":{"src":"images\\graphic_design\\nextversion952-in.png","width":6000,"height":3486,"creation_date":"2023-8-12"},"995_out.png":{"src":"images\\graphic_design\\995_out.png","width":4416,"height":6092,"creation_date":"2023-8-12"},"940.png":{"src":"images\\graphic_design\\940.png","width":2495,"height":3230,"creation_date":"2023-8-12"},"938.png":{"src":"images\\graphic_design\\938.png","width":2825,"height":2959,"creation_date":"2023-8-12"},"934 out.png":{"src":"images\\graphic_design\\934 out.png","width":5000,"height":3168,"creation_date":"2023-8-12"},"919.png":{"src":"images\\graphic_design\\919.png","width":2334,"height":3500,"creation_date":"2023-8-12"},"713-output.png":{"src":"images\\graphic_design\\713-output.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"593.png":{"src":"images\\graphic_design\\593.png","width":4000,"height":4788,"creation_date":"2023-8-12"},"592-out.png":{"src":"images\\graphic_design\\592-out.png","width":2256,"height":3300,"creation_date":"2023-8-12"},"591.png":{"src":"images\\graphic_design\\591.png","width":2160,"height":3840,"creation_date":"2023-8-12"},"588.png":{"src":"images\\graphic_design\\588.png","width":3240,"height":2160,"creation_date":"2023-8-12"},"587.png":{"src":"images\\graphic_design\\587.png","width":1620,"height":1080,"creation_date":"2023-8-12"},"583-оут.png":{"src":"images\\graphic_design\\583-оут.png","width":1500,"height":1500,"creation_date":"2023-8-12"},"555.png":{"src":"images\\graphic_design\\555.png","width":2319,"height":3000,"creation_date":"2023-8-12"},"542.png":{"src":"images\\graphic_design\\542.png","width":2500,"height":2503,"creation_date":"2023-8-12"},"509.png":{"src":"images\\graphic_design\\509.png","width":2309,"height":2250,"creation_date":"2023-8-12"},"506-out.png":{"src":"images\\graphic_design\\506-out.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"505-01.png":{"src":"images\\graphic_design\\505-01.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"502.png":{"src":"images\\graphic_design\\502.png","width":2480,"height":2208,"creation_date":"2023-8-12"},"499.png":{"src":"images\\graphic_design\\499.png","width":3370,"height":4000,"creation_date":"2023-8-12"},"493.png":{"src":"images\\graphic_design\\493.png","width":596,"height":657,"creation_date":"2023-8-12"},"1x935_out.png":{"src":"images\\graphic_design\\1x935_out.png","width":3402,"height":5222,"creation_date":"2023-8-12"},"1x933.png":{"src":"images\\graphic_design\\1x933.png","width":5000,"height":3182,"creation_date":"2023-8-12"},"1x929.png":{"src":"images\\graphic_design\\1x929.png","width":5802,"height":8000,"creation_date":"2023-8-12"},"1x925 (1).png":{"src":"images\\graphic_design\\1x925 (1).png","width":2115,"height":3000,"creation_date":"2023-8-12"},"1155-out.png":{"src":"images\\graphic_design\\1155-out.png","width":3840,"height":4710,"creation_date":"2023-8-12"},"1093.png":{"src":"images\\graphic_design\\1093.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1090.png":{"src":"images\\graphic_design\\1090.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1089.png":{"src":"images\\graphic_design\\1089.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1087_out.png":{"src":"images\\graphic_design\\1087_out.png","width":1887,"height":1880,"creation_date":"2023-8-12"},"1052_out.png":{"src":"images\\graphic_design\\1052_out.png","width":4320,"height":4320,"creation_date":"2023-8-12"},"1048_out.png":{"src":"images\\graphic_design\\1048_out.png","width":4290,"height":5400,"creation_date":"2023-8-12"},"1030_in.png":{"src":"images\\graphic_design\\1030_in.png","width":2540,"height":3525,"creation_date":"2023-8-12"},"1013_out.png":{"src":"images\\graphic_design\\1013_out.png","width":4096,"height":4092,"creation_date":"2023-8-12"},"1008_out.png":{"src":"images\\graphic_design\\1008_out.png","width":4000,"height":4000,"creation_date":"2023-8-12"},"1007_out.png":{"src":"images\\graphic_design\\1007_out.png","width":3840,"height":3872,"creation_date":"2023-8-12"},"1006.png":{"src":"images\\graphic_design\\1006.png","width":3084,"height":4316,"creation_date":"2023-8-12"},"1005_out.png":{"src":"images\\graphic_design\\1005_out.png","width":2870,"height":4104,"creation_date":"2023-8-12"},"1004_out.png":{"src":"images\\graphic_design\\1004_out.png","width":2964,"height":4268,"creation_date":"2023-8-12"},"1002.png":{"src":"images\\graphic_design\\1002.png","width":3258,"height":4435,"creation_date":"2023-8-12"},"1001-b.png":{"src":"images\\graphic_design\\1001-b.png","width":4224,"height":4290,"creation_date":"2023-8-12"}},"generative":{"unknown2.png":{"src":"images\\generative\\unknown2.png","width":1104,"height":816,"creation_date":"2023-8-12"},"unknown.png":{"src":"images\\generative\\unknown.png","width":1254,"height":701,"creation_date":"2023-8-12"},"unknown (9).png":{"src":"images\\generative\\unknown (9).png"},"unknown (8).png":{"src":"images\\generative\\unknown (8).png"},"unknown (7).png":{"src":"images\\generative\\unknown (7).png"},"unknown (6).png":{"src":"images\\generative\\unknown (6).png"},"unknown (5).png":{"src":"images\\generative\\unknown (5).png"},"unknown (4).png":{"src":"images\\generative\\unknown (4).png"},"unknown (3).png":{"src":"images\\generative\\unknown (3).png"},"unknown (2).png":{"src":"images\\generative\\unknown (2).png"},"unknown (11).png":{"src":"images\\generative\\unknown (11).png"},"unknown (10).png":{"src":"images\\generative\\unknown (10).png"},"unknown (1).png":{"src":"images\\generative\\unknown (1).png"},"spectracer.png":{"src":"images\\generative\\spectracer.png"},"spectracer (5).png":{"src":"images\\generative\\spectracer (5).png"},"spectracer (4).png":{"src":"images\\generative\\spectracer (4).png"},"spectracer (3).png":{"src":"images\\generative\\spectracer (3).png"},"spectracer (2).png":{"src":"images\\generative\\spectracer (2).png"},"spectracer (1).png":{"src":"images\\generative\\spectracer (1).png"},"S138LuQAAAABJRU5ErkJggg.png":{"src":"images\\generative\\S138LuQAAAABJRU5ErkJggg.png","width":1920,"height":1023,"creation_date":"2023-8-12"},"P0y3BNk6U271AAAAAElFTkSuQmCC.png":{"src":"images\\generative\\P0y3BNk6U271AAAAAElFTkSuQmCC.png","width":640,"height":360,"creation_date":"2023-8-12"},"image (29).png":{"src":"images\\generative\\image (29).png"},"image (27).png":{"src":"images\\generative\\image (27).png"},"image (26).png":{"src":"images\\generative\\image (26).png"},"image (25).png":{"src":"images\\generative\\image (25).png"},"idklol-out.png":{"src":"images\\generative\\idklol-out.png","width":2854,"height":2804,"creation_date":"2023-8-12"},"Hhdk6NsUzCUWqcE4gnJieEEyKSKS8vt737P2VPffLRXxkbz7BZnD8Efmjz5R9f6P8CJBYa1YeaSScAAAAASUVORK5CYII.png":{"src":"images\\generative\\Hhdk6NsUzCUWqcE4gnJieEEyKSKS8vt737P2VPffLRXxkbz7BZnD8Efmjz5R9f6P8CJBYa1YeaSScAAAAASUVORK5CYII.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"Ha2Ch0D.png":{"src":"images\\generative\\Ha2Ch0D.png","width":1064,"height":681,"creation_date":"2023-8-12"},"flowers.png":{"src":"images\\generative\\flowers.png","width":1055,"height":682,"creation_date":"2023-8-12"},"FJ5S5FKWQAMjtjO.png":{"src":"images\\generative\\FJ5S5FKWQAMjtjO.png"},"FbPBBI7XkAIz10q.png":{"src":"images\\generative\\FbPBBI7XkAIz10q.png","width":680,"height":435,"creation_date":"2023-8-12"},"download.png":{"src":"images\\generative\\download.png","width":2560,"height":1440,"creation_date":"2023-8-12"},"767.png":{"src":"images\\generative\\767.png","width":2610,"height":1902,"creation_date":"2023-8-12"},"765.png":{"src":"images\\generative\\765.png"},"757-out.png":{"src":"images\\generative\\757-out.png","width":3000,"height":3000,"creation_date":"2023-8-12"},"746-rc-a.png":{"src":"images\\generative\\746-rc-a.png","width":1280,"height":720,"creation_date":"2023-8-12"},"717.png":{"src":"images\\generative\\717.png","width":2488,"height":1440,"creation_date":"2023-8-12"},"581-v1.png":{"src":"images\\generative\\581-v1.png","width":1155,"height":825,"creation_date":"2023-8-12"},"54.png":{"src":"images\\generative\\54.png","width":881,"height":496,"creation_date":"2023-8-12"},"172-a-toned.png":{"src":"images\\generative\\172-a-toned.png","width":893,"height":1374,"creation_date":"2023-8-12"},"FR56Q9mWQAA7U4X.jpg":{"src":"images\\generative\\FR56Q9mWQAA7U4X.jpg"},"FbPBBI7XkAIz10q.jpg":{"src":"images\\generative\\FbPBBI7XkAIz10q.jpg"},"FbBtUi9XoAEHFrV.jpg":{"src":"images\\generative\\FbBtUi9XoAEHFrV.jpg"},"3tycWV.jpg":{"src":"images\\generative\\3tycWV.jpg","width":640,"height":360,"creation_date":"2023-8-12"},"3lSyRh.jpg":{"src":"images\\generative\\3lSyRh.jpg","width":800,"height":450,"creation_date":"2023-8-12"},"capture - 2021-02-23T161035.355.webm":{"src":"images\\generative\\capture - 2021-02-23T161035.355.webm","width":640,"height":360,"creation_date":"2023-8-12"},"capture (59).webm":{"src":"images\\generative\\capture (59).webm","width":1000,"height":1000,"creation_date":"2023-8-12"},"WQC0rBl.mp4":{"src":"images\\generative\\WQC0rBl.mp4"},"pOiFoUR.mp4":{"src":"images\\generative\\pOiFoUR.mp4"},"OUT (3).mp4":{"src":"images\\generative\\OUT (3).mp4"},"OUT (2).mp4":{"src":"images\\generative\\OUT (2).mp4"},"OUT (1).mp4":{"src":"images\\generative\\OUT (1).mp4"},"chrome_xOHw6iea45.mp4":{"src":"images\\generative\\chrome_xOHw6iea45.mp4"},"chrome_UDlKJV4jdZ.mp4":{"src":"images\\generative\\chrome_UDlKJV4jdZ.mp4"},"chrome_RazqupSsRS.mp4":{"src":"images\\generative\\chrome_RazqupSsRS.mp4"},"chrome_ibz88JN1To.mp4":{"src":"images\\generative\\chrome_ibz88JN1To.mp4"},"chrome_foG6RANRoM.mp4":{"src":"images\\generative\\chrome_foG6RANRoM.mp4"},"capture - 2021-04-01T215056.436.mp4":{"src":"images\\generative\\capture - 2021-04-01T215056.436.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-24T174055.362.mp4":{"src":"images\\generative\\capture - 2021-02-24T174055.362.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-23T161035.355.mp4":{"src":"images\\generative\\capture - 2021-02-23T161035.355.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-23T135750.665.mp4":{"src":"images\\generative\\capture - 2021-02-23T135750.665.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-22T191650.873.mp4":{"src":"images\\generative\\capture - 2021-02-22T191650.873.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-15T183608.531.mp4":{"src":"images\\generative\\capture - 2021-02-15T183608.531.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-06T155448.767.mp4":{"src":"images\\generative\\capture - 2021-02-06T155448.767.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-04T235908.915.mp4":{"src":"images\\generative\\capture - 2021-02-04T235908.915.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-01-25T215853.813.mp4":{"src":"images\\generative\\capture - 2021-01-25T215853.813.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture (71).mp4":{"src":"images\\generative\\capture (71).mp4","width":800,"height":450,"creation_date":"2023-8-12"},"capture (61).mp4":{"src":"images\\generative\\capture (61).mp4","width":1100,"height":900,"creation_date":"2023-8-12"},"capture (60).mp4":{"src":"images\\generative\\capture (60).mp4","width":1100,"height":700,"creation_date":"2023-8-12"},"capture (51).mp4":{"src":"images\\generative\\capture (51).mp4","width":1000,"height":1000,"creation_date":"2023-8-12"},"1XTPsDi.mp4":{"src":"images\\generative\\1XTPsDi.mp4"},"166.mp4":{"src":"images\\generative\\166.mp4","width":640,"height":400,"creation_date":"2023-8-12"},"soDroUS.gif":{"src":"images\\generative\\soDroUS.gif","width":500,"height":500,"creation_date":"2023-8-12"},"129.gif":{"src":"images\\generative\\129.gif","width":400,"height":400,"creation_date":"2023-8-12"},"126.gif":{"src":"images\\generative\\126.gif","width":256,"height":256,"creation_date":"2023-8-12"},"123.gif":{"src":"images\\generative\\123.gif","width":512,"height":512,"creation_date":"2023-8-12"}},"noise_tex.webp":{"src":"images\\noise_tex.webp","width":720,"height":720,"creation_date":"2023-8-9"}},"audio":{"epic":{"hmmm.mp3":{"src":"audio\\epic\\hmmm.mp3","creation_date":"2023-8-12"},"590.mp3":{"src":"audio\\epic\\590.mp3","creation_date":"2023-8-12"},"589.mp3":{"src":"audio\\epic\\589.mp3","creation_date":"2023-8-12"},"576-fuji remix v1.mp3":{"src":"audio\\epic\\576-fuji remix v1.mp3","creation_date":"2023-8-12"},"575-2k.mp3":{"src":"audio\\epic\\575-2k.mp3","creation_date":"2023-8-12"},"574-radiator .mp3":{"src":"audio\\epic\\574-radiator .mp3","creation_date":"2023-8-12"},"570 - mark thing wip.mp3":{"src":"audio\\epic\\570 - mark thing wip.mp3","creation_date":"2023-8-12"},"560-v2.mp3":{"src":"audio\\epic\\560-v2.mp3","creation_date":"2023-8-12"},"527.mp3":{"src":"audio\\epic\\527.mp3","creation_date":"2023-8-12"},"524.mp3":{"src":"audio\\epic\\524.mp3","creation_date":"2023-8-12"},"515.mp3":{"src":"audio\\epic\\515.mp3","creation_date":"2023-8-12"},"481.mp3":{"src":"audio\\epic\\481.mp3","creation_date":"2023-8-12"},"465.mp3":{"src":"audio\\epic\\465.mp3","creation_date":"2023-8-12"},"460.mp3":{"src":"audio\\epic\\460.mp3","creation_date":"2023-8-12"},"330.mp3":{"src":"audio\\epic\\330.mp3","creation_date":"2023-8-12"},"319.mp3":{"src":"audio\\epic\\319.mp3","creation_date":"2023-8-12"},"316.mp3":{"src":"audio\\epic\\316.mp3","creation_date":"2023-8-12"},"309 not te4no.mp3":{"src":"audio\\epic\\309 not te4no.mp3","creation_date":"2023-8-12"},"257-2.mp3":{"src":"audio\\epic\\257-2.mp3","creation_date":"2023-8-12"},"256.mp3":{"src":"audio\\epic\\256.mp3","creation_date":"2023-8-12"},"255-v2 - Copy.mp3":{"src":"audio\\epic\\255-v2 - Copy.mp3","creation_date":"2023-8-12"},"254.mp3":{"src":"audio\\epic\\254.mp3","creation_date":"2023-8-12"},"244.mp3":{"src":"audio\\epic\\244.mp3","creation_date":"2023-8-12"},"236.mp3":{"src":"audio\\epic\\236.mp3","creation_date":"2023-8-12"},"222.mp3":{"src":"audio\\epic\\222.mp3","creation_date":"2023-8-12"},"219.mp3":{"src":"audio\\epic\\219.mp3","creation_date":"2023-8-12"},"138.mp3":{"src":"audio\\epic\\138.mp3","creation_date":"2023-8-12"}},"cool":{"wip4e.mp3":{"src":"audio\\cool\\wip4e.mp3","creation_date":"2023-8-12"},"jajaja.mp3":{"src":"audio\\cool\\jajaja.mp3","creation_date":"2023-8-12"},"932.mp3":{"src":"audio\\cool\\932.mp3","creation_date":"2023-8-12"},"927.mp3":{"src":"audio\\cool\\927.mp3","creation_date":"2023-8-12"},"926.mp3":{"src":"audio\\cool\\926.mp3","creation_date":"2023-8-12"},"836.mp3":{"src":"audio\\cool\\836.mp3","creation_date":"2023-8-12"},"801.mp3":{"src":"audio\\cool\\801.mp3","creation_date":"2023-8-12"},"797-b.mp3":{"src":"audio\\cool\\797-b.mp3","creation_date":"2023-8-12"},"730.mp3":{"src":"audio\\cool\\730.mp3","creation_date":"2023-8-12"},"692.mp3":{"src":"audio\\cool\\692.mp3","creation_date":"2023-8-12"},"691.mp3":{"src":"audio\\cool\\691.mp3","creation_date":"2023-8-12"},"690_unnoised_more.mp3":{"src":"audio\\cool\\690_unnoised_more.mp3","creation_date":"2023-8-12"},"662.mp3":{"src":"audio\\cool\\662.mp3","creation_date":"2023-8-12"},"642 other.mp3":{"src":"audio\\cool\\642 other.mp3","creation_date":"2023-8-12"},"626.mp3":{"src":"audio\\cool\\626.mp3","creation_date":"2023-8-12"},"1244 ok 2023-08-07 1915.mp3":{"src":"audio\\cool\\1244 ok 2023-08-07 1915.mp3","creation_date":"2023-8-12"},"1243 2023-08-07 1919.mp3":{"src":"audio\\cool\\1243 2023-08-07 1919.mp3","creation_date":"2023-8-12"},"1188 2023-08-07 1946.mp3":{"src":"audio\\cool\\1188 2023-08-07 1946.mp3","creation_date":"2023-8-12"},"1187 2023-03-20 2255.mp3":{"src":"audio\\cool\\1187 2023-03-20 2255.mp3","creation_date":"2023-8-12"},"1180 2023-03-13 vcv.mp3":{"src":"audio\\cool\\1180 2023-03-13 vcv.mp3","creation_date":"2023-8-12"},"1162.mp3":{"src":"audio\\cool\\1162.mp3","creation_date":"2023-8-12"},"1140.mp3":{"src":"audio\\cool\\1140.mp3","creation_date":"2023-8-12"},"1121.mp3":{"src":"audio\\cool\\1121.mp3","creation_date":"2023-8-12"},"1116-toomb-ludum-dare.mp3":{"src":"audio\\cool\\1116-toomb-ludum-dare.mp3","creation_date":"2023-8-12"},"1099-toomb4.mp3":{"src":"audio\\cool\\1099-toomb4.mp3","creation_date":"2023-8-12"},"1098-toomb3 (1).mp3":{"src":"audio\\cool\\1098-toomb3 (1).mp3","creation_date":"2023-8-12"},"1096-toomb2.mp3":{"src":"audio\\cool\\1096-toomb2.mp3","creation_date":"2023-8-12"},"1095-toomb.mp3":{"src":"audio\\cool\\1095-toomb.mp3","creation_date":"2023-8-12"},"1071.mp3":{"src":"audio\\cool\\1071.mp3","creation_date":"2023-8-12"},"1069.mp3":{"src":"audio\\cool\\1069.mp3","creation_date":"2023-8-12"},"1034.mp3":{"src":"audio\\cool\\1034.mp3","creation_date":"2023-8-12"},"1025.mp3":{"src":"audio\\cool\\1025.mp3","creation_date":"2023-8-12"},"1021.mp3":{"src":"audio\\cool\\1021.mp3","creation_date":"2023-8-12"},"1014.mp3":{"src":"audio\\cool\\1014.mp3","creation_date":"2023-8-12"}}}}}["public"]["images"];
	const image_cats = [];
	const image_cat_names = [];
	const image_cat_toggled = [];

	for (let image_folder_name of Object.keys(image_folders)) {
		if (typeof image_folders[image_folder_name] === "object" && !image_folders[image_folder_name]["src"]) {
			let folder = [];
			let image_keys = Object.keys(image_folders[image_folder_name]);
			image_cats.push(folder);

			if (image_keys.length > 0) {
				image_cat_names.push(image_folder_name);
				image_cat_toggled.push(true);
			}

			for (let image_key of image_keys) {
				let image = image_folders[image_folder_name][image_key];

				folder.push({
					src: image["src"],
					width: image["width"],
					height: image["height"]
				});
			}
		}
	}

	console.log("CAAAAAAAAAAAAAAAAAAAAATS");
	console.log(image_cats);
	let { url = "/favdemos" } = $$props;

	onMount(async () => {
		const hash = window.location.hash;

		setTimeout(
			() => {
				try {
					scroll_to_view(hash);
				} catch(e) {
					
				}
			},
			200
		);
	});

	onDestroy(() => {
		
	});

	const writable_props = ['url'];

	art_svelte_Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') art_svelte_console_1.warn(`<Art> was created with unknown prop '${key}'`);
	});

	const click_handler = i => {
		scroll_to_view(`#${image_cat_names[i]}`);
	};

	function zoom_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			zoom_widget = $$value;
			$$invalidate(0, zoom_widget);
		});
	}

	const click_handler_1 = i => {
		$$invalidate(1, image_cat_toggled[i] = !image_cat_toggled[i], image_cat_toggled);
	};

	const func = // @ts-ignore
	src => {
		zoom_widget.open_image(src);
	};

	$$self.$$set = $$props => {
		if ('url' in $$props) $$invalidate(5, url = $$props.url);
	};

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		Bar: src_components_Bar_svelte,
		Gallery: src_components_Gallery_svelte,
		Footer: src_components_Footer_svelte,
		Router: Router_svelte,
		Link: src_Link_svelte,
		Route: Route_svelte,
		lozad: (lozad_min_default()),
		Zoom: components_svelte_zoom_index_svelte,
		zoom_widget,
		observer,
		scroll_to_view,
		image_folders,
		image_cats,
		image_cat_names,
		image_cat_toggled,
		url
	});

	$$self.$inject_state = $$props => {
		if ('zoom_widget' in $$props) $$invalidate(0, zoom_widget = $$props.zoom_widget);
		if ('observer' in $$props) observer = $$props.observer;
		if ('url' in $$props) $$invalidate(5, url = $$props.url);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		zoom_widget,
		image_cat_toggled,
		scroll_to_view,
		image_cats,
		image_cat_names,
		url,
		click_handler,
		zoom_binding,
		click_handler_1,
		func
	];
}

class Art extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, art_svelte_instance, art_svelte_create_fragment, safe_not_equal, { url: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Art",
			options,
			id: art_svelte_create_fragment.name
		});
	}

	get url() {
		throw new Error("<Art>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Art>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const src_components_art_svelte = (Art);

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Projects.svx.6.css!./src/components/Projects.svx
var Projects = __webpack_require__(926);
;// CONCATENATED MODULE: ./src/components/Projects.svx.6.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Projects.svx.6.css!./src/components/Projects.svx

      
      
      
      
      
      
      
      
      

var Projects_options = {};

Projects_options.styleTagTransform = (styleTagTransform_default());
Projects_options.setAttributes = (setAttributesWithoutAttributes_default());

      Projects_options.insert = insertBySelector_default().bind(null, "head");
    
Projects_options.domAPI = (styleDomAPI_default());
Projects_options.insertStyleElement = (insertStyleElement_default());

var Projects_update = injectStylesIntoStyleTag_default()(Projects/* default */.Z, Projects_options);




       /* harmony default export */ const components_Projects = (Projects/* default */.Z && Projects/* default */.Z.locals ? Projects/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/Projects.svx
/* src\components\Projects.svx generated by Svelte v4.0.1 */








const Projects_file = "src\\components\\Projects.svx";

function Projects_create_fragment(ctx) {
	let main;
	let bar;
	let t0;
	let div0;
	let t2;
	let div4;
	let div1;
	let a0;
	let t4;
	let a1;
	let t6;
	let t7;
	let wbr0;
	let t8;
	let div2;
	let t9;
	let a2;
	let t11;
	let a3;
	let t13;
	let t14;
	let wbr1;
	let t15;
	let div3;
	let t17;
	let wbr2;
	let t18;
	let div5;
	let img0;
	let img0_src_value;
	let t19;
	let img1;
	let img1_src_value;
	let t20;
	let img2;
	let img2_src_value;
	let t21;
	let img3;
	let img3_src_value;
	let t22;
	let footer;
	let current;
	bar = new src_components_Bar_svelte({ $$inline: true });
	footer = new src_components_Footer_svelte({ $$inline: true });

	const block = {
		c: function create() {
			main = dom_element("main");
			create_component(bar.$$.fragment);
			t0 = space();
			div0 = dom_element("div");
			div0.textContent = "Splunge";
			t2 = space();
			div4 = dom_element("div");
			div1 = dom_element("div");
			a0 = dom_element("a");
			a0.textContent = "Splunge";
			t4 = dom_text(" is a painting software inspired by the lovely app ");
			a1 = dom_element("a");
			a1.textContent = "HeavyPaint";
			t6 = dom_text(".");
			t7 = space();
			wbr0 = dom_element("wbr");
			t8 = space();
			div2 = dom_element("div");
			t9 = dom_text("The UI has common actions like brush size and HSV adjustments as gestures, triggered by the pen button. \r\n\t\t\t\tFeatures include user gallery and infinite undo.  \r\n\t\t\t\tI wrote it using ");
			a2 = dom_element("a");
			a2.textContent = "Svelte";
			t11 = dom_text(" and ");
			a3 = dom_element("a");
			a3.textContent = "WebGL";
			t13 = dom_text(", targeting my budget Galaxy Tab S6 Lite tablet. \r\n\t\t\t\tThis created the need of a lot of micro optimizations and profiling, but ended up running nicely!");
			t14 = space();
			wbr1 = dom_element("wbr");
			t15 = space();
			div3 = dom_element("div");
			div3.textContent = "Here are some paintings I made with it:";
			t17 = space();
			wbr2 = dom_element("wbr");
			t18 = space();
			div5 = dom_element("div");
			img0 = dom_element("img");
			t19 = space();
			img1 = dom_element("img");
			t20 = space();
			img2 = dom_element("img");
			t21 = space();
			img3 = dom_element("img");
			t22 = space();
			create_component(footer.$$.fragment);
			attr_dev(div0, "class", "name svelte-1pobciu");
			add_location(div0, Projects_file, 3, 2, 22);
			attr_dev(a0, "href", "https://github.com/wrightwriter/splunge");
			attr_dev(a0, "target", "_blank");
			attr_dev(a0, "class", "svelte-1pobciu");
			add_location(a0, Projects_file, 8, 4, 107);
			attr_dev(a1, "href", "https://www.heavypaint.com");
			attr_dev(a1, "target", "_blank");
			attr_dev(a1, "class", "svelte-1pobciu");
			add_location(a1, Projects_file, 8, 132, 235);
			attr_dev(div1, "class", "svelte-1pobciu");
			add_location(div1, Projects_file, 7, 3, 96);
			attr_dev(wbr0, "class", "svelte-1pobciu");
			add_location(wbr0, Projects_file, 10, 3, 321);
			attr_dev(a2, "href", "https://svelte.dev/");
			attr_dev(a2, "target", "_blank");
			attr_dev(a2, "class", "svelte-1pobciu");
			add_location(a2, Projects_file, 14, 21, 527);
			attr_dev(a3, "href", "https://www.youtube.com/watch?v=3lOptjAeA2w");
			attr_dev(a3, "target", "_blank");
			attr_dev(a3, "class", "svelte-1pobciu");
			add_location(a3, Projects_file, 14, 84, 590);
			attr_dev(div2, "class", "svelte-1pobciu");
			add_location(div2, Projects_file, 11, 3, 333);
			attr_dev(wbr1, "class", "svelte-1pobciu");
			add_location(wbr1, Projects_file, 17, 3, 840);
			attr_dev(div3, "class", "svelte-1pobciu");
			add_location(div3, Projects_file, 18, 3, 852);
			attr_dev(wbr2, "class", "svelte-1pobciu");
			add_location(wbr2, Projects_file, 21, 3, 918);
			attr_dev(div4, "class", "description svelte-1pobciu");
			add_location(div4, Projects_file, 6, 2, 66);
			if (!src_url_equal(img0.src, img0_src_value = window.LFS_PREPEND + "./images/paintings/adsg.png")) attr_dev(img0, "src", img0_src_value);
			attr_dev(img0, "height", "345.5rem");
			add_location(img0, Projects_file, 24, 3, 965);
			if (!src_url_equal(img1.src, img1_src_value = window.LFS_PREPEND + "./images/paintings/1689957895824_2 (1).png")) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "height", "345.5rem");
			add_location(img1, Projects_file, 25, 3, 1051);
			if (!src_url_equal(img2.src, img2_src_value = window.LFS_PREPEND + "./images/paintings/1690037672960_1 (1).png")) attr_dev(img2, "src", img2_src_value);
			attr_dev(img2, "height", "290.5rem");
			add_location(img2, Projects_file, 26, 3, 1153);
			if (!src_url_equal(img3.src, img3_src_value = window.LFS_PREPEND + "./images/paintings/1690102042507_1[1].png")) attr_dev(img3, "src", img3_src_value);
			attr_dev(img3, "height", "290.5rem");
			add_location(img3, Projects_file, 27, 3, 1256);
			attr_dev(div5, "class", "gallery svelte-1pobciu");
			add_location(div5, Projects_file, 23, 2, 939);
			attr_dev(main, "class", "svelte-1pobciu");
			add_location(main, Projects_file, 1, 0, 2);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(bar, main, null);
			append_dev(main, t0);
			append_dev(main, div0);
			append_dev(main, t2);
			append_dev(main, div4);
			append_dev(div4, div1);
			append_dev(div1, a0);
			append_dev(div1, t4);
			append_dev(div1, a1);
			append_dev(div1, t6);
			append_dev(div4, t7);
			append_dev(div4, wbr0);
			append_dev(div4, t8);
			append_dev(div4, div2);
			append_dev(div2, t9);
			append_dev(div2, a2);
			append_dev(div2, t11);
			append_dev(div2, a3);
			append_dev(div2, t13);
			append_dev(div4, t14);
			append_dev(div4, wbr1);
			append_dev(div4, t15);
			append_dev(div4, div3);
			append_dev(div4, t17);
			append_dev(div4, wbr2);
			append_dev(main, t18);
			append_dev(main, div5);
			append_dev(div5, img0);
			append_dev(div5, t19);
			append_dev(div5, img1);
			append_dev(div5, t20);
			append_dev(div5, img2);
			append_dev(div5, t21);
			append_dev(div5, img3);
			append_dev(main, t22);
			mount_component(footer, main, null);
			current = true;
		},
		p: utils_noop,
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(bar.$$.fragment, local);
			transitions_transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(bar.$$.fragment, local);
			transitions_transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(main);
			}

			destroy_component(bar);
			destroy_component(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Projects_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Projects_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Projects', slots, []);

	onDestroy(() => {
		
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Projects> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		Bar: src_components_Bar_svelte,
		Footer: src_components_Footer_svelte,
		Router: Router_svelte,
		Link: src_Link_svelte,
		Route: Route_svelte
	});

	return [];
}

class Projects_Projects extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, Projects_instance, Projects_create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Projects",
			options,
			id: Projects_create_fragment.name
		});
	}
}

/* harmony default export */ const src_components_Projects = (Projects_Projects);

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/About.svelte.4.css!./src/components/About.svelte
var About_svelte = __webpack_require__(602);
;// CONCATENATED MODULE: ./src/components/About.svelte.4.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/About.svelte.4.css!./src/components/About.svelte

      
      
      
      
      
      
      
      
      

var About_svelte_options = {};

About_svelte_options.styleTagTransform = (styleTagTransform_default());
About_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      About_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
About_svelte_options.domAPI = (styleDomAPI_default());
About_svelte_options.insertStyleElement = (insertStyleElement_default());

var About_svelte_update = injectStylesIntoStyleTag_default()(About_svelte/* default */.Z, About_svelte_options);




       /* harmony default export */ const components_About_svelte = (About_svelte/* default */.Z && About_svelte/* default */.Z.locals ? About_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/About.svelte
/* src\components\About.svelte generated by Svelte v4.0.1 */








const About_svelte_file = "src\\components\\About.svelte";

function About_svelte_create_fragment(ctx) {
	let main;
	let bar;
	let t0;
	let div3;
	let div0;
	let t2;
	let wbr0;
	let t3;
	let div1;
	let t5;
	let wbr1;
	let t6;
	let div2;
	let t8;
	let footer;
	let current;
	bar = new src_components_Bar_svelte({ $$inline: true });
	footer = new src_components_Footer_svelte({ $$inline: true });

	const block = {
		c: function create() {
			main = dom_element("main");
			create_component(bar.$$.fragment);
			t0 = space();
			div3 = dom_element("div");
			div0 = dom_element("div");
			div0.textContent = "Hey, I’m Pètar.";
			t2 = space();
			wbr0 = dom_element("wbr");
			t3 = space();
			div1 = dom_element("div");
			div1.textContent = "I'm a musician, coder and visual artist.";
			t5 = space();
			wbr1 = dom_element("wbr");
			t6 = space();
			div2 = dom_element("div");
			div2.textContent = "Feel free to hit me up on discord, or check out my socials.";
			t8 = space();
			create_component(footer.$$.fragment);
			attr_dev(div0, "class", "svelte-1r35zme");
			add_location(div0, About_svelte_file, 4, 3, 52);
			attr_dev(wbr0, "class", "svelte-1r35zme");
			add_location(wbr0, About_svelte_file, 7, 3, 95);
			attr_dev(div1, "class", "svelte-1r35zme");
			add_location(div1, About_svelte_file, 9, 3, 109);
			attr_dev(wbr1, "class", "svelte-1r35zme");
			add_location(wbr1, About_svelte_file, 12, 3, 176);
			attr_dev(div2, "class", "svelte-1r35zme");
			add_location(div2, About_svelte_file, 13, 3, 188);
			attr_dev(div3, "class", "description svelte-1r35zme");
			add_location(div3, About_svelte_file, 3, 2, 22);
			attr_dev(main, "class", "svelte-1r35zme");
			add_location(main, About_svelte_file, 1, 0, 2);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(bar, main, null);
			append_dev(main, t0);
			append_dev(main, div3);
			append_dev(div3, div0);
			append_dev(div3, t2);
			append_dev(div3, wbr0);
			append_dev(div3, t3);
			append_dev(div3, div1);
			append_dev(div3, t5);
			append_dev(div3, wbr1);
			append_dev(div3, t6);
			append_dev(div3, div2);
			append_dev(main, t8);
			mount_component(footer, main, null);
			current = true;
		},
		p: utils_noop,
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(bar.$$.fragment, local);
			transitions_transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(bar.$$.fragment, local);
			transitions_transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(main);
			}

			destroy_component(bar);
			destroy_component(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: About_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function About_svelte_instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('About', slots, []);

	onDestroy(() => {
		
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<About> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		Bar: src_components_Bar_svelte,
		Footer: src_components_Footer_svelte,
		Router: Router_svelte,
		Link: src_Link_svelte,
		Route: Route_svelte
	});

	return [];
}

class About extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, About_svelte_instance, About_svelte_create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "About",
			options,
			id: About_svelte_create_fragment.name
		});
	}
}

/* harmony default export */ const src_components_About_svelte = (About);

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Splash.svelte.5.css!./src/components/Splash.svelte
var Splash_svelte = __webpack_require__(16);
;// CONCATENATED MODULE: ./src/components/Splash.svelte.5.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/Splash.svelte.5.css!./src/components/Splash.svelte

      
      
      
      
      
      
      
      
      

var Splash_svelte_options = {};

Splash_svelte_options.styleTagTransform = (styleTagTransform_default());
Splash_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      Splash_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
Splash_svelte_options.domAPI = (styleDomAPI_default());
Splash_svelte_options.insertStyleElement = (insertStyleElement_default());

var Splash_svelte_update = injectStylesIntoStyleTag_default()(Splash_svelte/* default */.Z, Splash_svelte_options);




       /* harmony default export */ const components_Splash_svelte = (Splash_svelte/* default */.Z && Splash_svelte/* default */.Z.locals ? Splash_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/Splash.svelte
/* src\components\Splash.svelte generated by Svelte v4.0.1 */


const { Object: Splash_svelte_Object_1, console: Splash_svelte_console_1 } = globals;
















const Splash_svelte_file = "src\\components\\Splash.svelte";

function Splash_svelte_create_fragment(ctx) {
	let div;
	let main;
	let bar;
	let t0;
	let footer;
	let t1;
	let canvas;
	let current;
	bar = new src_components_Bar_svelte({ $$inline: true });
	footer = new src_components_Footer_svelte({ $$inline: true });

	const block = {
		c: function create() {
			div = dom_element("div");
			main = dom_element("main");
			create_component(bar.$$.fragment);
			t0 = space();
			create_component(footer.$$.fragment);
			t1 = space();
			canvas = dom_element("canvas");
			attr_dev(main, "class", "svelte-v3tjz9");
			add_location(main, Splash_svelte_file, 1, 1, 43);
			attr_dev(canvas, "draggable", "false");
			attr_dev(canvas, "id", "canvas");
			attr_dev(canvas, "class", "svelte-v3tjz9");
			add_location(canvas, Splash_svelte_file, 5, 1, 89);
			set_style(div, "width", "100%");
			set_style(div, "height", "100%");
			add_location(div, Splash_svelte_file, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, main);
			mount_component(bar, main, null);
			append_dev(main, t0);
			mount_component(footer, main, null);
			append_dev(div, t1);
			append_dev(div, canvas);
			/*canvas_binding*/ ctx[2](canvas);
			current = true;
		},
		p: utils_noop,
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(bar.$$.fragment, local);
			transitions_transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(bar.$$.fragment, local);
			transitions_transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(bar);
			destroy_component(footer);
			/*canvas_binding*/ ctx[2](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: Splash_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function Splash_svelte_instance($$self, $$props, $$invalidate) {
	let path_name;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Splash', slots, []);
	console.log({"public":{"images":{"1690102042507_1[1].png":{"src":"images\\1690102042507_1[1].png","width":1616,"height":1448,"creation_date":"2023-8-12"},"paintings":{"unknown.png":{"src":"images\\paintings\\unknown.png","width":386,"height":381,"creation_date":"2023-8-12"},"adsg.png":{"src":"images\\paintings\\adsg.png","width":826,"height":877,"creation_date":"2023-8-12"},"868.png":{"src":"images\\paintings\\868.png","width":1918,"height":3074,"creation_date":"2023-8-12"},"302-o.png":{"src":"images\\paintings\\302-o.png","width":447,"height":373,"creation_date":"2023-8-12"},"1690102042507_1[1].png":{"src":"images\\paintings\\1690102042507_1[1].png"},"1690037672960_1 (1).png":{"src":"images\\paintings\\1690037672960_1 (1).png"},"1689957895824_2 (1).png":{"src":"images\\paintings\\1689957895824_2 (1).png"},"1137-a.png":{"src":"images\\paintings\\1137-a.png"},"1135-c.png":{"src":"images\\paintings\\1135-c.png"},"1132-a.png":{"src":"images\\paintings\\1132-a.png","width":1920,"height":2580,"creation_date":"2023-8-12"},"1131-a.png":{"src":"images\\paintings\\1131-a.png","width":1920,"height":2880,"creation_date":"2023-8-12"},"1130-b.png":{"src":"images\\paintings\\1130-b.png","width":1920,"height":2680,"creation_date":"2023-8-12"},"1130-a.png":{"src":"images\\paintings\\1130-a.png","width":1920,"height":2580,"creation_date":"2023-8-12"},"1129-pat-a.png":{"src":"images\\paintings\\1129-pat-a.png","width":2020,"height":1280,"creation_date":"2023-8-12"},"1124-2.png":{"src":"images\\paintings\\1124-2.png","width":1920,"height":2680,"creation_date":"2023-8-12"},"1123-e.png":{"src":"images\\paintings\\1123-e.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"1123-c.png":{"src":"images\\paintings\\1123-c.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1119.png":{"src":"images\\paintings\\1119.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1117-2.png":{"src":"images\\paintings\\1117-2.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1112.png":{"src":"images\\paintings\\1112.png","width":1170,"height":1860,"creation_date":"2023-8-12"},"1055.png":{"src":"images\\paintings\\1055.png","width":1920,"height":2600,"creation_date":"2023-8-12"},"1041.png":{"src":"images\\paintings\\1041.png","width":1920,"height":2600,"creation_date":"2023-8-12"},"1033.png":{"src":"images\\paintings\\1033.png","width":1920,"height":1480,"creation_date":"2023-8-12"},"1135-b (1).jpg":{"src":"images\\paintings\\1135-b (1).jpg"}},"graphic_design":{"nextversion952-in.png":{"src":"images\\graphic_design\\nextversion952-in.png","width":6000,"height":3486,"creation_date":"2023-8-12"},"995_out.png":{"src":"images\\graphic_design\\995_out.png","width":4416,"height":6092,"creation_date":"2023-8-12"},"940.png":{"src":"images\\graphic_design\\940.png","width":2495,"height":3230,"creation_date":"2023-8-12"},"938.png":{"src":"images\\graphic_design\\938.png","width":2825,"height":2959,"creation_date":"2023-8-12"},"934 out.png":{"src":"images\\graphic_design\\934 out.png","width":5000,"height":3168,"creation_date":"2023-8-12"},"919.png":{"src":"images\\graphic_design\\919.png","width":2334,"height":3500,"creation_date":"2023-8-12"},"713-output.png":{"src":"images\\graphic_design\\713-output.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"593.png":{"src":"images\\graphic_design\\593.png","width":4000,"height":4788,"creation_date":"2023-8-12"},"592-out.png":{"src":"images\\graphic_design\\592-out.png","width":2256,"height":3300,"creation_date":"2023-8-12"},"591.png":{"src":"images\\graphic_design\\591.png","width":2160,"height":3840,"creation_date":"2023-8-12"},"588.png":{"src":"images\\graphic_design\\588.png","width":3240,"height":2160,"creation_date":"2023-8-12"},"587.png":{"src":"images\\graphic_design\\587.png","width":1620,"height":1080,"creation_date":"2023-8-12"},"583-оут.png":{"src":"images\\graphic_design\\583-оут.png","width":1500,"height":1500,"creation_date":"2023-8-12"},"555.png":{"src":"images\\graphic_design\\555.png","width":2319,"height":3000,"creation_date":"2023-8-12"},"542.png":{"src":"images\\graphic_design\\542.png","width":2500,"height":2503,"creation_date":"2023-8-12"},"509.png":{"src":"images\\graphic_design\\509.png","width":2309,"height":2250,"creation_date":"2023-8-12"},"506-out.png":{"src":"images\\graphic_design\\506-out.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"505-01.png":{"src":"images\\graphic_design\\505-01.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"502.png":{"src":"images\\graphic_design\\502.png","width":2480,"height":2208,"creation_date":"2023-8-12"},"499.png":{"src":"images\\graphic_design\\499.png","width":3370,"height":4000,"creation_date":"2023-8-12"},"493.png":{"src":"images\\graphic_design\\493.png","width":596,"height":657,"creation_date":"2023-8-12"},"1x935_out.png":{"src":"images\\graphic_design\\1x935_out.png","width":3402,"height":5222,"creation_date":"2023-8-12"},"1x933.png":{"src":"images\\graphic_design\\1x933.png","width":5000,"height":3182,"creation_date":"2023-8-12"},"1x929.png":{"src":"images\\graphic_design\\1x929.png","width":5802,"height":8000,"creation_date":"2023-8-12"},"1x925 (1).png":{"src":"images\\graphic_design\\1x925 (1).png","width":2115,"height":3000,"creation_date":"2023-8-12"},"1155-out.png":{"src":"images\\graphic_design\\1155-out.png","width":3840,"height":4710,"creation_date":"2023-8-12"},"1093.png":{"src":"images\\graphic_design\\1093.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1090.png":{"src":"images\\graphic_design\\1090.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1089.png":{"src":"images\\graphic_design\\1089.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1087_out.png":{"src":"images\\graphic_design\\1087_out.png","width":1887,"height":1880,"creation_date":"2023-8-12"},"1052_out.png":{"src":"images\\graphic_design\\1052_out.png","width":4320,"height":4320,"creation_date":"2023-8-12"},"1048_out.png":{"src":"images\\graphic_design\\1048_out.png","width":4290,"height":5400,"creation_date":"2023-8-12"},"1030_in.png":{"src":"images\\graphic_design\\1030_in.png","width":2540,"height":3525,"creation_date":"2023-8-12"},"1013_out.png":{"src":"images\\graphic_design\\1013_out.png","width":4096,"height":4092,"creation_date":"2023-8-12"},"1008_out.png":{"src":"images\\graphic_design\\1008_out.png","width":4000,"height":4000,"creation_date":"2023-8-12"},"1007_out.png":{"src":"images\\graphic_design\\1007_out.png","width":3840,"height":3872,"creation_date":"2023-8-12"},"1006.png":{"src":"images\\graphic_design\\1006.png","width":3084,"height":4316,"creation_date":"2023-8-12"},"1005_out.png":{"src":"images\\graphic_design\\1005_out.png","width":2870,"height":4104,"creation_date":"2023-8-12"},"1004_out.png":{"src":"images\\graphic_design\\1004_out.png","width":2964,"height":4268,"creation_date":"2023-8-12"},"1002.png":{"src":"images\\graphic_design\\1002.png","width":3258,"height":4435,"creation_date":"2023-8-12"},"1001-b.png":{"src":"images\\graphic_design\\1001-b.png","width":4224,"height":4290,"creation_date":"2023-8-12"}},"generative":{"unknown2.png":{"src":"images\\generative\\unknown2.png","width":1104,"height":816,"creation_date":"2023-8-12"},"unknown.png":{"src":"images\\generative\\unknown.png","width":1254,"height":701,"creation_date":"2023-8-12"},"unknown (9).png":{"src":"images\\generative\\unknown (9).png"},"unknown (8).png":{"src":"images\\generative\\unknown (8).png"},"unknown (7).png":{"src":"images\\generative\\unknown (7).png"},"unknown (6).png":{"src":"images\\generative\\unknown (6).png"},"unknown (5).png":{"src":"images\\generative\\unknown (5).png"},"unknown (4).png":{"src":"images\\generative\\unknown (4).png"},"unknown (3).png":{"src":"images\\generative\\unknown (3).png"},"unknown (2).png":{"src":"images\\generative\\unknown (2).png"},"unknown (11).png":{"src":"images\\generative\\unknown (11).png"},"unknown (10).png":{"src":"images\\generative\\unknown (10).png"},"unknown (1).png":{"src":"images\\generative\\unknown (1).png"},"spectracer.png":{"src":"images\\generative\\spectracer.png"},"spectracer (5).png":{"src":"images\\generative\\spectracer (5).png"},"spectracer (4).png":{"src":"images\\generative\\spectracer (4).png"},"spectracer (3).png":{"src":"images\\generative\\spectracer (3).png"},"spectracer (2).png":{"src":"images\\generative\\spectracer (2).png"},"spectracer (1).png":{"src":"images\\generative\\spectracer (1).png"},"S138LuQAAAABJRU5ErkJggg.png":{"src":"images\\generative\\S138LuQAAAABJRU5ErkJggg.png","width":1920,"height":1023,"creation_date":"2023-8-12"},"P0y3BNk6U271AAAAAElFTkSuQmCC.png":{"src":"images\\generative\\P0y3BNk6U271AAAAAElFTkSuQmCC.png","width":640,"height":360,"creation_date":"2023-8-12"},"image (29).png":{"src":"images\\generative\\image (29).png"},"image (27).png":{"src":"images\\generative\\image (27).png"},"image (26).png":{"src":"images\\generative\\image (26).png"},"image (25).png":{"src":"images\\generative\\image (25).png"},"idklol-out.png":{"src":"images\\generative\\idklol-out.png","width":2854,"height":2804,"creation_date":"2023-8-12"},"Hhdk6NsUzCUWqcE4gnJieEEyKSKS8vt737P2VPffLRXxkbz7BZnD8Efmjz5R9f6P8CJBYa1YeaSScAAAAASUVORK5CYII.png":{"src":"images\\generative\\Hhdk6NsUzCUWqcE4gnJieEEyKSKS8vt737P2VPffLRXxkbz7BZnD8Efmjz5R9f6P8CJBYa1YeaSScAAAAASUVORK5CYII.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"Ha2Ch0D.png":{"src":"images\\generative\\Ha2Ch0D.png","width":1064,"height":681,"creation_date":"2023-8-12"},"flowers.png":{"src":"images\\generative\\flowers.png","width":1055,"height":682,"creation_date":"2023-8-12"},"FJ5S5FKWQAMjtjO.png":{"src":"images\\generative\\FJ5S5FKWQAMjtjO.png"},"FbPBBI7XkAIz10q.png":{"src":"images\\generative\\FbPBBI7XkAIz10q.png","width":680,"height":435,"creation_date":"2023-8-12"},"download.png":{"src":"images\\generative\\download.png","width":2560,"height":1440,"creation_date":"2023-8-12"},"767.png":{"src":"images\\generative\\767.png","width":2610,"height":1902,"creation_date":"2023-8-12"},"765.png":{"src":"images\\generative\\765.png"},"757-out.png":{"src":"images\\generative\\757-out.png","width":3000,"height":3000,"creation_date":"2023-8-12"},"746-rc-a.png":{"src":"images\\generative\\746-rc-a.png","width":1280,"height":720,"creation_date":"2023-8-12"},"717.png":{"src":"images\\generative\\717.png","width":2488,"height":1440,"creation_date":"2023-8-12"},"581-v1.png":{"src":"images\\generative\\581-v1.png","width":1155,"height":825,"creation_date":"2023-8-12"},"54.png":{"src":"images\\generative\\54.png","width":881,"height":496,"creation_date":"2023-8-12"},"172-a-toned.png":{"src":"images\\generative\\172-a-toned.png","width":893,"height":1374,"creation_date":"2023-8-12"},"FR56Q9mWQAA7U4X.jpg":{"src":"images\\generative\\FR56Q9mWQAA7U4X.jpg"},"FbPBBI7XkAIz10q.jpg":{"src":"images\\generative\\FbPBBI7XkAIz10q.jpg"},"FbBtUi9XoAEHFrV.jpg":{"src":"images\\generative\\FbBtUi9XoAEHFrV.jpg"},"3tycWV.jpg":{"src":"images\\generative\\3tycWV.jpg","width":640,"height":360,"creation_date":"2023-8-12"},"3lSyRh.jpg":{"src":"images\\generative\\3lSyRh.jpg","width":800,"height":450,"creation_date":"2023-8-12"},"capture - 2021-02-23T161035.355.webm":{"src":"images\\generative\\capture - 2021-02-23T161035.355.webm","width":640,"height":360,"creation_date":"2023-8-12"},"capture (59).webm":{"src":"images\\generative\\capture (59).webm","width":1000,"height":1000,"creation_date":"2023-8-12"},"WQC0rBl.mp4":{"src":"images\\generative\\WQC0rBl.mp4"},"pOiFoUR.mp4":{"src":"images\\generative\\pOiFoUR.mp4"},"OUT (3).mp4":{"src":"images\\generative\\OUT (3).mp4"},"OUT (2).mp4":{"src":"images\\generative\\OUT (2).mp4"},"OUT (1).mp4":{"src":"images\\generative\\OUT (1).mp4"},"chrome_xOHw6iea45.mp4":{"src":"images\\generative\\chrome_xOHw6iea45.mp4"},"chrome_UDlKJV4jdZ.mp4":{"src":"images\\generative\\chrome_UDlKJV4jdZ.mp4"},"chrome_RazqupSsRS.mp4":{"src":"images\\generative\\chrome_RazqupSsRS.mp4"},"chrome_ibz88JN1To.mp4":{"src":"images\\generative\\chrome_ibz88JN1To.mp4"},"chrome_foG6RANRoM.mp4":{"src":"images\\generative\\chrome_foG6RANRoM.mp4"},"capture - 2021-04-01T215056.436.mp4":{"src":"images\\generative\\capture - 2021-04-01T215056.436.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-24T174055.362.mp4":{"src":"images\\generative\\capture - 2021-02-24T174055.362.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-23T161035.355.mp4":{"src":"images\\generative\\capture - 2021-02-23T161035.355.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-23T135750.665.mp4":{"src":"images\\generative\\capture - 2021-02-23T135750.665.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-22T191650.873.mp4":{"src":"images\\generative\\capture - 2021-02-22T191650.873.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-15T183608.531.mp4":{"src":"images\\generative\\capture - 2021-02-15T183608.531.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-06T155448.767.mp4":{"src":"images\\generative\\capture - 2021-02-06T155448.767.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-04T235908.915.mp4":{"src":"images\\generative\\capture - 2021-02-04T235908.915.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-01-25T215853.813.mp4":{"src":"images\\generative\\capture - 2021-01-25T215853.813.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture (71).mp4":{"src":"images\\generative\\capture (71).mp4","width":800,"height":450,"creation_date":"2023-8-12"},"capture (61).mp4":{"src":"images\\generative\\capture (61).mp4","width":1100,"height":900,"creation_date":"2023-8-12"},"capture (60).mp4":{"src":"images\\generative\\capture (60).mp4","width":1100,"height":700,"creation_date":"2023-8-12"},"capture (51).mp4":{"src":"images\\generative\\capture (51).mp4","width":1000,"height":1000,"creation_date":"2023-8-12"},"1XTPsDi.mp4":{"src":"images\\generative\\1XTPsDi.mp4"},"166.mp4":{"src":"images\\generative\\166.mp4","width":640,"height":400,"creation_date":"2023-8-12"},"soDroUS.gif":{"src":"images\\generative\\soDroUS.gif","width":500,"height":500,"creation_date":"2023-8-12"},"129.gif":{"src":"images\\generative\\129.gif","width":400,"height":400,"creation_date":"2023-8-12"},"126.gif":{"src":"images\\generative\\126.gif","width":256,"height":256,"creation_date":"2023-8-12"},"123.gif":{"src":"images\\generative\\123.gif","width":512,"height":512,"creation_date":"2023-8-12"}},"noise_tex.webp":{"src":"images\\noise_tex.webp","width":720,"height":720,"creation_date":"2023-8-9"}},"audio":{"epic":{"hmmm.mp3":{"src":"audio\\epic\\hmmm.mp3","creation_date":"2023-8-12"},"590.mp3":{"src":"audio\\epic\\590.mp3","creation_date":"2023-8-12"},"589.mp3":{"src":"audio\\epic\\589.mp3","creation_date":"2023-8-12"},"576-fuji remix v1.mp3":{"src":"audio\\epic\\576-fuji remix v1.mp3","creation_date":"2023-8-12"},"575-2k.mp3":{"src":"audio\\epic\\575-2k.mp3","creation_date":"2023-8-12"},"574-radiator .mp3":{"src":"audio\\epic\\574-radiator .mp3","creation_date":"2023-8-12"},"570 - mark thing wip.mp3":{"src":"audio\\epic\\570 - mark thing wip.mp3","creation_date":"2023-8-12"},"560-v2.mp3":{"src":"audio\\epic\\560-v2.mp3","creation_date":"2023-8-12"},"527.mp3":{"src":"audio\\epic\\527.mp3","creation_date":"2023-8-12"},"524.mp3":{"src":"audio\\epic\\524.mp3","creation_date":"2023-8-12"},"515.mp3":{"src":"audio\\epic\\515.mp3","creation_date":"2023-8-12"},"481.mp3":{"src":"audio\\epic\\481.mp3","creation_date":"2023-8-12"},"465.mp3":{"src":"audio\\epic\\465.mp3","creation_date":"2023-8-12"},"460.mp3":{"src":"audio\\epic\\460.mp3","creation_date":"2023-8-12"},"330.mp3":{"src":"audio\\epic\\330.mp3","creation_date":"2023-8-12"},"319.mp3":{"src":"audio\\epic\\319.mp3","creation_date":"2023-8-12"},"316.mp3":{"src":"audio\\epic\\316.mp3","creation_date":"2023-8-12"},"309 not te4no.mp3":{"src":"audio\\epic\\309 not te4no.mp3","creation_date":"2023-8-12"},"257-2.mp3":{"src":"audio\\epic\\257-2.mp3","creation_date":"2023-8-12"},"256.mp3":{"src":"audio\\epic\\256.mp3","creation_date":"2023-8-12"},"255-v2 - Copy.mp3":{"src":"audio\\epic\\255-v2 - Copy.mp3","creation_date":"2023-8-12"},"254.mp3":{"src":"audio\\epic\\254.mp3","creation_date":"2023-8-12"},"244.mp3":{"src":"audio\\epic\\244.mp3","creation_date":"2023-8-12"},"236.mp3":{"src":"audio\\epic\\236.mp3","creation_date":"2023-8-12"},"222.mp3":{"src":"audio\\epic\\222.mp3","creation_date":"2023-8-12"},"219.mp3":{"src":"audio\\epic\\219.mp3","creation_date":"2023-8-12"},"138.mp3":{"src":"audio\\epic\\138.mp3","creation_date":"2023-8-12"}},"cool":{"wip4e.mp3":{"src":"audio\\cool\\wip4e.mp3","creation_date":"2023-8-12"},"jajaja.mp3":{"src":"audio\\cool\\jajaja.mp3","creation_date":"2023-8-12"},"932.mp3":{"src":"audio\\cool\\932.mp3","creation_date":"2023-8-12"},"927.mp3":{"src":"audio\\cool\\927.mp3","creation_date":"2023-8-12"},"926.mp3":{"src":"audio\\cool\\926.mp3","creation_date":"2023-8-12"},"836.mp3":{"src":"audio\\cool\\836.mp3","creation_date":"2023-8-12"},"801.mp3":{"src":"audio\\cool\\801.mp3","creation_date":"2023-8-12"},"797-b.mp3":{"src":"audio\\cool\\797-b.mp3","creation_date":"2023-8-12"},"730.mp3":{"src":"audio\\cool\\730.mp3","creation_date":"2023-8-12"},"692.mp3":{"src":"audio\\cool\\692.mp3","creation_date":"2023-8-12"},"691.mp3":{"src":"audio\\cool\\691.mp3","creation_date":"2023-8-12"},"690_unnoised_more.mp3":{"src":"audio\\cool\\690_unnoised_more.mp3","creation_date":"2023-8-12"},"662.mp3":{"src":"audio\\cool\\662.mp3","creation_date":"2023-8-12"},"642 other.mp3":{"src":"audio\\cool\\642 other.mp3","creation_date":"2023-8-12"},"626.mp3":{"src":"audio\\cool\\626.mp3","creation_date":"2023-8-12"},"1244 ok 2023-08-07 1915.mp3":{"src":"audio\\cool\\1244 ok 2023-08-07 1915.mp3","creation_date":"2023-8-12"},"1243 2023-08-07 1919.mp3":{"src":"audio\\cool\\1243 2023-08-07 1919.mp3","creation_date":"2023-8-12"},"1188 2023-08-07 1946.mp3":{"src":"audio\\cool\\1188 2023-08-07 1946.mp3","creation_date":"2023-8-12"},"1187 2023-03-20 2255.mp3":{"src":"audio\\cool\\1187 2023-03-20 2255.mp3","creation_date":"2023-8-12"},"1180 2023-03-13 vcv.mp3":{"src":"audio\\cool\\1180 2023-03-13 vcv.mp3","creation_date":"2023-8-12"},"1162.mp3":{"src":"audio\\cool\\1162.mp3","creation_date":"2023-8-12"},"1140.mp3":{"src":"audio\\cool\\1140.mp3","creation_date":"2023-8-12"},"1121.mp3":{"src":"audio\\cool\\1121.mp3","creation_date":"2023-8-12"},"1116-toomb-ludum-dare.mp3":{"src":"audio\\cool\\1116-toomb-ludum-dare.mp3","creation_date":"2023-8-12"},"1099-toomb4.mp3":{"src":"audio\\cool\\1099-toomb4.mp3","creation_date":"2023-8-12"},"1098-toomb3 (1).mp3":{"src":"audio\\cool\\1098-toomb3 (1).mp3","creation_date":"2023-8-12"},"1096-toomb2.mp3":{"src":"audio\\cool\\1096-toomb2.mp3","creation_date":"2023-8-12"},"1095-toomb.mp3":{"src":"audio\\cool\\1095-toomb.mp3","creation_date":"2023-8-12"},"1071.mp3":{"src":"audio\\cool\\1071.mp3","creation_date":"2023-8-12"},"1069.mp3":{"src":"audio\\cool\\1069.mp3","creation_date":"2023-8-12"},"1034.mp3":{"src":"audio\\cool\\1034.mp3","creation_date":"2023-8-12"},"1025.mp3":{"src":"audio\\cool\\1025.mp3","creation_date":"2023-8-12"},"1021.mp3":{"src":"audio\\cool\\1021.mp3","creation_date":"2023-8-12"},"1014.mp3":{"src":"audio\\cool\\1014.mp3","creation_date":"2023-8-12"}}}}});
	let { url = "/" } = $$props;
	let canvasElement;
	let gl;
	let default_framebuffer;
	let fb_a;
	let fb_b;
	let fb_c;
	let ubo;
	let t = 0;
	console.log(path_name);

	const init_web_gl = () => {
		window.gl = gl = canvasElement.getContext('webgl2', {
			preserveDrawingBuffer: false,
			alpha: false,
			premultipliedAlpha: false,
			antialias: true
		});

		gl.getExtension('OES_texture_float');
		gl.getExtension('OES_texture_float_linear');
		gl.getExtension('EXT_color_buffer_float');
		gl.debugEnabled = "production" === 'development';
		gl.debugEnabled = false;
		init_gl_error_handling();
		const user_agent_res = [canvasElement.clientWidth, canvasElement.clientWidth];
		default_framebuffer = Object.create(Framebuffer.prototype);
		default_framebuffer.default = true;
		default_framebuffer.pongable = false;
		default_framebuffer.needs_pong = false;
		default_framebuffer.pong_idx = 0;
		default_framebuffer._fb = null;
		default_framebuffer._textures = [Object.create(Texture.prototype)];
		default_framebuffer.textures[0].res = [...user_agent_res];
		default_framebuffer.bind();
		fb_a = new Framebuffer([new Texture([...user_agent_res], gl.RGBA8)], true);
		fb_b = new Framebuffer([new Texture([...user_agent_res], gl.RGBA8)], false);
		fb_c = new Framebuffer([new Texture([...user_agent_res], gl.RGBA16F)], true);
		ubo = new UBO();
		window.ubo = ubo;
		resizeIfNeeded(canvasElement, default_framebuffer, user_agent_res);
		gl.disable(gl.CULL_FACE);
		gl.disable(gl.DEPTH_TEST);
		gl.enable(gl.BLEND);
		gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
		gl.clearColor(0, 0, 0, 0);
	};

	onMount(async () => {
		init_web_gl();
		const blobs_program = new ShaderProgram(__webpack_require__(165), __webpack_require__(809));
		const lines_program = new ShaderProgram(__webpack_require__(643), __webpack_require__(911));
		const feedback_program = new ShaderProgram(__webpack_require__(165), __webpack_require__(804));
		const post_program = new ShaderProgram(__webpack_require__(165), __webpack_require__(975));
		post_program.use();
		gl.uniform1i(gl.getUniformLocation(post_program.program, "fb_a"), 0);
		gl.uniform1i(gl.getUniformLocation(post_program.program, "fb_b"), 1);
		gl.uniform1i(gl.getUniformLocation(post_program.program, "noise_tex"), 2);
		blobs_program.use();
		gl.uniform1i(gl.getUniformLocation(blobs_program.program, "fb_a"), 0);
		gl.uniform1i(gl.getUniformLocation(blobs_program.program, "fb_b"), 1);
		feedback_program.use();
		gl.uniform1i(gl.getUniformLocation(feedback_program.program, "fb_a"), 0);
		gl.uniform1i(gl.getUniformLocation(feedback_program.program, "fb_b"), 1);
		const noise_tex = await Texture.from_image_path(window.LFS_PREPEND + (__webpack_require__(304)/* ["default"] */ .Z));
		noise_tex.bind_to_unit(2);
		const lines_buff = new VertexBuffer(4, gl.FLOAT, 10000);
		const lines_thing = new Thing([lines_buff], gl.TRIANGLES, lines_program);
		const desired_mouse_pos = [0, 0];
		const mouse_pos = [0, 0];
		let pointer_pressure = 0.;
		let pointer_down = false;

		canvasElement.addEventListener("pointerdown", e => {
			e.stopPropagation();
		});

		window.addEventListener('pointerdown', e => {
			pointer_down = true;
		});

		window.addEventListener('pointerup', e => {
			pointer_down = false;
		});

		window.addEventListener('pointerrawupdate', e => {
			const gl = window.gl;
			const rect = gl.canvas.getBoundingClientRect();
			let pos_x = (e.clientX - rect.left) * gl.canvas.width / gl.canvas.clientWidth;
			let pos_y = (e.clientY - rect.top) * gl.canvas.height / gl.canvas.clientHeight;
			const x = pos_x / gl.canvas.width * 2 - 1;
			const y = pos_y / gl.canvas.height * -2 + 1;
			desired_mouse_pos[0] = x;
			desired_mouse_pos[1] = y;
		});

		const set_shared_uniforms = () => {
			ubo.buff.sz = 0;
			ubo.buff.cpu_buff[0] = canvasElement.width;
			ubo.buff.cpu_buff[1] = canvasElement.height;
			ubo.buff.cpu_buff[4] = t;
			ubo.buff.cpu_buff[5] = pointer_pressure;
			ubo.buff.cpu_buff[6] = mouse_pos[0];
			ubo.buff.cpu_buff[7] = mouse_pos[1];
			ubo.buff.upload();
		};

		let frame = 0;
		const hash = new Hash();
		let delta_t = 0;

		const gl_draw = _t => {
			const new_t = _t / 1000;
			delta_t = new_t - t;
			t = new_t;
			hash.seed = 125125;
			mouse_pos[0] = wmath_lerp(mouse_pos[0], desired_mouse_pos[0], min(delta_t, 1));
			mouse_pos[1] = wmath_lerp(mouse_pos[1], desired_mouse_pos[1], min(delta_t, 1));

			if (pointer_down) {
				pointer_pressure = wmath_lerp(pointer_pressure, 1., min(delta_t * 4, 1));
			} else {
				pointer_pressure = wmath_lerp(pointer_pressure, 0., min(delta_t * 4, 1));
			}

			const get_circ_pos_from_ang = a => {
				const c = Math.cos(-a);
				const s = Math.sin(-a);
				return [c, s];
			};

			const add_ang_to_pos = (pos, ang_offs, positive, amt) => {
				if (positive) {
					pos[0] += ang_offs[0] * amt;
					pos[1] += ang_offs[1] * amt;
				} else {
					pos[0] -= ang_offs[0] * amt;
					pos[1] -= ang_offs[1] * amt;
				}

				return pos;
			};

			const positions = new Float32Array(lines_buff.cpu_buff.length / 3 + 1);

			for (let i = 0; i < positions.length / 2 + 1; i++) {
				const pos = [
					hash.valueNoise(i * 0.26 + mouse_pos[0] + hash.valueNoise(t * 0.25 + Math.sin(t * 0.25))) * 2. - 1.,
					hash.valueNoise(i * 0.26 + 12512 + hash.valueNoise(t * 0.5)) * 2. - 1.0
				];

				if (pointer_pressure > 0.002) {
					const dir_vec_x = pos[0] - mouse_pos[0];
					const dir_vec_y = pos[1] - mouse_pos[1];
					const dir_vec_len = Math.sqrt(dir_vec_x * dir_vec_x + dir_vec_y * dir_vec_y);
					const dir_vec_factor = wmath_smoothstep(0.4, 0., dir_vec_len);
					pos[0] += dir_vec_factor * dir_vec_x * pointer_pressure * 4;
					pos[1] += dir_vec_factor * dir_vec_y * pointer_pressure * 4;
				}

				positions[i * 2] = pos[0];
				positions[i * 2 + 1] = pos[1];
			}

			const prev_pos = [0, 0];

			for (let i = 0; i < lines_buff.cpu_buff.length / 3 / 4 / 2; i++) {
				const step = 4 * 3 * 2;
				let idx = i * step;
				let curr_sz = hash.valueNoise(i) * 0.04;
				let next_sz = hash.valueNoise(i) * 0.04;
				let curr_ang = get_circ_pos_from_ang(0.4 + mouse_pos[1] * 6);
				let next_ang = get_circ_pos_from_ang(0.2 + mouse_pos[1] * 6);
				let curr_pos = [positions[i * 2], positions[i * 2 + 1]];
				let next_pos = [positions[i * 2 + 2], positions[i * 2 + 3]];
				let curr_pos_left = add_ang_to_pos([...curr_pos], curr_ang, true, curr_sz);
				let curr_pos_right = add_ang_to_pos([...curr_pos], curr_ang, false, curr_sz);
				let next_pos_left = add_ang_to_pos([...next_pos], next_ang, true, next_sz);
				let next_pos_right = add_ang_to_pos([...next_pos], next_ang, false, next_sz);
				lines_buff.cpu_buff[idx] = curr_pos_left[0];
				lines_buff.cpu_buff[idx + 1] = curr_pos_left[1];
				lines_buff.cpu_buff[idx + 2] = 0;
				lines_buff.cpu_buff[idx + 3] = 0;
				lines_buff.cpu_buff[idx + 4] = curr_pos_right[0];
				lines_buff.cpu_buff[idx + 4 + 1] = curr_pos_right[1];
				lines_buff.cpu_buff[idx + 4 + 2] = 1;
				lines_buff.cpu_buff[idx + 4 + 3] = 0;
				lines_buff.cpu_buff[idx + 8] = next_pos_left[0];
				lines_buff.cpu_buff[idx + 8 + 1] = next_pos_left[1];
				lines_buff.cpu_buff[idx + 8 + 2] = 0;
				lines_buff.cpu_buff[idx + 8 + 3] = 1;
				idx += 12;
				lines_buff.cpu_buff[idx] = next_pos_left[0];
				lines_buff.cpu_buff[idx + 1] = next_pos_left[1];
				lines_buff.cpu_buff[idx + 2] = 0;
				lines_buff.cpu_buff[idx + 3] = 1;
				lines_buff.cpu_buff[idx + 4] = curr_pos_right[0];
				lines_buff.cpu_buff[idx + 4 + 1] = curr_pos_right[1];
				lines_buff.cpu_buff[idx + 4 + 2] = 1;
				lines_buff.cpu_buff[idx + 4 + 3] = 0;
				const mid_p_x = wmath_lerp(next_pos_left[0], curr_pos_right[0], 0.5);
				const mid_p_y = wmath_lerp(next_pos_left[1], curr_pos_right[1], 0.5);
				lines_buff.cpu_buff[idx + 8] = wmath_lerp(next_pos_right[0], mid_p_x, 0.9);
				lines_buff.cpu_buff[idx + 8 + 1] = wmath_lerp(next_pos_right[1], mid_p_y, 0.9);
				lines_buff.cpu_buff[idx + 8 + 2] = 1;
				lines_buff.cpu_buff[idx + 8 + 3] = 1;
			}

			lines_buff.upload();
			set_shared_uniforms();
			resizeIfNeeded(canvasElement, default_framebuffer, default_framebuffer._textures[0].res);
			gl.viewport(0, 0, canvasElement.width, canvasElement.height);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fb_a.fb);
			gl.clear(gl.COLOR_BUFFER_BIT);
			gl.useProgram(blobs_program.program);
			fb_a.back_textures[0].bind_to_unit(0);
			fb_c.textures[0].bind_to_unit(1);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fb_b.fb);
			gl.clear(gl.COLOR_BUFFER_BIT);
			lines_thing.draw();
			gl.bindFramebuffer(gl.FRAMEBUFFER, fb_c.fb);
			gl.clear(gl.COLOR_BUFFER_BIT);
			gl.useProgram(feedback_program.program);
			fb_c.back_textures[0].bind_to_unit(0);
			fb_b.textures[0].bind_to_unit(1);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.clear(gl.COLOR_BUFFER_BIT);
			gl.useProgram(post_program.program);
			fb_a.textures[0].bind_to_unit(0);
			fb_b.textures[0].bind_to_unit(1);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			frame++;

			for (let framebuffer of Framebuffer.framebuffers) {
				if (framebuffer.pongable) {
					framebuffer.pong();
				}
			}

			requestAnimationFrame(gl_draw);
		};

		(() => {
			gl_draw(0);
		})();
	});

	onDestroy(() => {
		
	});

	const writable_props = ['url'];

	Splash_svelte_Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') Splash_svelte_console_1.warn(`<Splash> was created with unknown prop '${key}'`);
	});

	function canvas_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvasElement = $$value;
			$$invalidate(0, canvasElement);
		});
	}

	$$self.$$set = $$props => {
		if ('url' in $$props) $$invalidate(1, url = $$props.url);
	};

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		resizeFramebuffersIfNeeded: resizeIfNeeded,
		init_gl_error_handling: init_gl_error_handling,
		Framebuffer: Framebuffer,
		VertexBuffer: VertexBuffer,
		UBO: UBO,
		Texture: Texture,
		ShaderProgram: ShaderProgram,
		Thing: Thing,
		Bar: src_components_Bar_svelte,
		Footer: src_components_Footer_svelte,
		Router: Router_svelte,
		Link: src_Link_svelte,
		Route: Route_svelte,
		Hash: Hash,
		lerp: wmath_lerp,
		min: min,
		smoothstep: wmath_smoothstep,
		url,
		canvasElement,
		gl,
		default_framebuffer,
		fb_a,
		fb_b,
		fb_c,
		ubo,
		t,
		init_web_gl,
		path_name
	});

	$$self.$inject_state = $$props => {
		if ('url' in $$props) $$invalidate(1, url = $$props.url);
		if ('canvasElement' in $$props) $$invalidate(0, canvasElement = $$props.canvasElement);
		if ('gl' in $$props) gl = $$props.gl;
		if ('default_framebuffer' in $$props) default_framebuffer = $$props.default_framebuffer;
		if ('fb_a' in $$props) fb_a = $$props.fb_a;
		if ('fb_b' in $$props) fb_b = $$props.fb_b;
		if ('fb_c' in $$props) fb_c = $$props.fb_c;
		if ('ubo' in $$props) ubo = $$props.ubo;
		if ('t' in $$props) t = $$props.t;
		if ('path_name' in $$props) path_name = $$props.path_name;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$: path_name = location.pathname;
	return [canvasElement, url, canvas_binding];
}

class Splash extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, Splash_svelte_instance, Splash_svelte_create_fragment, safe_not_equal, { url: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Splash",
			options,
			id: Splash_svelte_create_fragment.name
		});
	}

	get url() {
		throw new Error("<Splash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Splash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const src_components_Splash_svelte = (Splash);

// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/App.svelte.0.css!./src/components/App.svelte
var App_svelte = __webpack_require__(435);
;// CONCATENATED MODULE: ./src/components/App.svelte.0.css!=!./node_modules/svelte-loader/index.js?cssPath=D:/Programming/Web Development/wrighter.design/src/components/App.svelte.0.css!./src/components/App.svelte

      
      
      
      
      
      
      
      
      

var App_svelte_options = {};

App_svelte_options.styleTagTransform = (styleTagTransform_default());
App_svelte_options.setAttributes = (setAttributesWithoutAttributes_default());

      App_svelte_options.insert = insertBySelector_default().bind(null, "head");
    
App_svelte_options.domAPI = (styleDomAPI_default());
App_svelte_options.insertStyleElement = (insertStyleElement_default());

var App_svelte_update = injectStylesIntoStyleTag_default()(App_svelte/* default */.Z, App_svelte_options);




       /* harmony default export */ const components_App_svelte = (App_svelte/* default */.Z && App_svelte/* default */.Z.locals ? App_svelte/* default */.Z.locals : undefined);

;// CONCATENATED MODULE: ./src/components/App.svelte
/* src\components\App.svelte generated by Svelte v4.0.1 */


const { console: App_svelte_console_1 } = globals;





















const App_svelte_file = "src\\components\\App.svelte";

// (15:1) {:else}
function App_svelte_create_else_block(ctx) {
	let splash;
	let current;
	splash = new src_components_Splash_svelte({ $$inline: true });

	const block = {
		c: function create() {
			create_component(splash.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(splash, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(splash.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(splash.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(splash, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: App_svelte_create_else_block.name,
		type: "else",
		source: "(15:1) {:else}",
		ctx
	});

	return block;
}

// (13:66) 
function create_if_block_4(ctx) {
	let about;
	let current;
	about = new src_components_About_svelte({ $$inline: true });

	const block = {
		c: function create() {
			create_component(about.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(about, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(about.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(about.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(about, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(13:66) ",
		ctx
	});

	return block;
}

// (11:72) 
function create_if_block_3(ctx) {
	let projects;
	let current;
	projects = new src_components_Projects({ $$inline: true });

	const block = {
		c: function create() {
			create_component(projects.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(projects, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(projects.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(projects.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(projects, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(11:72) ",
		ctx
	});

	return block;
}

// (9:62) 
function create_if_block_2(ctx) {
	let art;
	let current;
	art = new src_components_art_svelte({ $$inline: true });

	const block = {
		c: function create() {
			create_component(art.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(art, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(art.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(art.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(art, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(9:62) ",
		ctx
	});

	return block;
}

// (7:66) 
function App_svelte_create_if_block_1(ctx) {
	let music;
	let current;
	music = new src_components_music_svelte({ $$inline: true });

	const block = {
		c: function create() {
			create_component(music.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(music, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(music.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(music.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(music, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: App_svelte_create_if_block_1.name,
		type: "if",
		source: "(7:66) ",
		ctx
	});

	return block;
}

// (5:1) {#if path_name === "/favdemos" || path_name === "/favdemos.html" }
function App_svelte_create_if_block(ctx) {
	let favdemos;
	let current;
	favdemos = new src_components_FavDemos_svelte({ $$inline: true });

	const block = {
		c: function create() {
			create_component(favdemos.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(favdemos, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(favdemos.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(favdemos.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(favdemos, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: App_svelte_create_if_block.name,
		type: "if",
		source: "(5:1) {#if path_name === \\\"/favdemos\\\" || path_name === \\\"/favdemos.html\\\" }",
		ctx
	});

	return block;
}

function App_svelte_create_fragment(ctx) {
	let title_value;
	let t;
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	document.title = title_value = /*head_title*/ ctx[1];

	const if_block_creators = [
		App_svelte_create_if_block,
		App_svelte_create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		App_svelte_create_else_block
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*path_name*/ ctx[0] === "/favdemos" || /*path_name*/ ctx[0] === "/favdemos.html") return 0;
		if (/*path_name*/ ctx[0] === "/music" || /*path_name*/ ctx[0] === "/music.html") return 1;
		if (/*path_name*/ ctx[0] === "/art" || /*path_name*/ ctx[0] === "/art.html") return 2;
		if (/*path_name*/ ctx[0] === "/projects" || /*path_name*/ ctx[0] === "/projects.html") return 3;
		if (/*path_name*/ ctx[0] === "/about" || /*path_name*/ ctx[0] === "/about.html") return 4;
		return 5;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			t = space();
			div = dom_element("div");
			if_block.c();
			set_style(div, "width", "100%");
			set_style(div, "height", "100%");
			add_location(div, App_svelte_file, 3, 0, 61);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*head_title*/ 2) && title_value !== (title_value = /*head_title*/ ctx[1])) {
				document.title = title_value;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transitions_transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					
				}

				transitions_transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transitions_transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transitions_transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(div);
			}

			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: App_svelte_create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function App_svelte_instance($$self, $$props, $$invalidate) {
	let head_title;
	let path_name;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('App', slots, []);
	console.log({"public":{"images":{"1690102042507_1[1].png":{"src":"images\\1690102042507_1[1].png","width":1616,"height":1448,"creation_date":"2023-8-12"},"paintings":{"unknown.png":{"src":"images\\paintings\\unknown.png","width":386,"height":381,"creation_date":"2023-8-12"},"adsg.png":{"src":"images\\paintings\\adsg.png","width":826,"height":877,"creation_date":"2023-8-12"},"868.png":{"src":"images\\paintings\\868.png","width":1918,"height":3074,"creation_date":"2023-8-12"},"302-o.png":{"src":"images\\paintings\\302-o.png","width":447,"height":373,"creation_date":"2023-8-12"},"1690102042507_1[1].png":{"src":"images\\paintings\\1690102042507_1[1].png"},"1690037672960_1 (1).png":{"src":"images\\paintings\\1690037672960_1 (1).png"},"1689957895824_2 (1).png":{"src":"images\\paintings\\1689957895824_2 (1).png"},"1137-a.png":{"src":"images\\paintings\\1137-a.png"},"1135-c.png":{"src":"images\\paintings\\1135-c.png"},"1132-a.png":{"src":"images\\paintings\\1132-a.png","width":1920,"height":2580,"creation_date":"2023-8-12"},"1131-a.png":{"src":"images\\paintings\\1131-a.png","width":1920,"height":2880,"creation_date":"2023-8-12"},"1130-b.png":{"src":"images\\paintings\\1130-b.png","width":1920,"height":2680,"creation_date":"2023-8-12"},"1130-a.png":{"src":"images\\paintings\\1130-a.png","width":1920,"height":2580,"creation_date":"2023-8-12"},"1129-pat-a.png":{"src":"images\\paintings\\1129-pat-a.png","width":2020,"height":1280,"creation_date":"2023-8-12"},"1124-2.png":{"src":"images\\paintings\\1124-2.png","width":1920,"height":2680,"creation_date":"2023-8-12"},"1123-e.png":{"src":"images\\paintings\\1123-e.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"1123-c.png":{"src":"images\\paintings\\1123-c.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1119.png":{"src":"images\\paintings\\1119.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1117-2.png":{"src":"images\\paintings\\1117-2.png","width":1920,"height":1920,"creation_date":"2023-8-12"},"1112.png":{"src":"images\\paintings\\1112.png","width":1170,"height":1860,"creation_date":"2023-8-12"},"1055.png":{"src":"images\\paintings\\1055.png","width":1920,"height":2600,"creation_date":"2023-8-12"},"1041.png":{"src":"images\\paintings\\1041.png","width":1920,"height":2600,"creation_date":"2023-8-12"},"1033.png":{"src":"images\\paintings\\1033.png","width":1920,"height":1480,"creation_date":"2023-8-12"},"1135-b (1).jpg":{"src":"images\\paintings\\1135-b (1).jpg"}},"graphic_design":{"nextversion952-in.png":{"src":"images\\graphic_design\\nextversion952-in.png","width":6000,"height":3486,"creation_date":"2023-8-12"},"995_out.png":{"src":"images\\graphic_design\\995_out.png","width":4416,"height":6092,"creation_date":"2023-8-12"},"940.png":{"src":"images\\graphic_design\\940.png","width":2495,"height":3230,"creation_date":"2023-8-12"},"938.png":{"src":"images\\graphic_design\\938.png","width":2825,"height":2959,"creation_date":"2023-8-12"},"934 out.png":{"src":"images\\graphic_design\\934 out.png","width":5000,"height":3168,"creation_date":"2023-8-12"},"919.png":{"src":"images\\graphic_design\\919.png","width":2334,"height":3500,"creation_date":"2023-8-12"},"713-output.png":{"src":"images\\graphic_design\\713-output.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"593.png":{"src":"images\\graphic_design\\593.png","width":4000,"height":4788,"creation_date":"2023-8-12"},"592-out.png":{"src":"images\\graphic_design\\592-out.png","width":2256,"height":3300,"creation_date":"2023-8-12"},"591.png":{"src":"images\\graphic_design\\591.png","width":2160,"height":3840,"creation_date":"2023-8-12"},"588.png":{"src":"images\\graphic_design\\588.png","width":3240,"height":2160,"creation_date":"2023-8-12"},"587.png":{"src":"images\\graphic_design\\587.png","width":1620,"height":1080,"creation_date":"2023-8-12"},"583-оут.png":{"src":"images\\graphic_design\\583-оут.png","width":1500,"height":1500,"creation_date":"2023-8-12"},"555.png":{"src":"images\\graphic_design\\555.png","width":2319,"height":3000,"creation_date":"2023-8-12"},"542.png":{"src":"images\\graphic_design\\542.png","width":2500,"height":2503,"creation_date":"2023-8-12"},"509.png":{"src":"images\\graphic_design\\509.png","width":2309,"height":2250,"creation_date":"2023-8-12"},"506-out.png":{"src":"images\\graphic_design\\506-out.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"505-01.png":{"src":"images\\graphic_design\\505-01.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"502.png":{"src":"images\\graphic_design\\502.png","width":2480,"height":2208,"creation_date":"2023-8-12"},"499.png":{"src":"images\\graphic_design\\499.png","width":3370,"height":4000,"creation_date":"2023-8-12"},"493.png":{"src":"images\\graphic_design\\493.png","width":596,"height":657,"creation_date":"2023-8-12"},"1x935_out.png":{"src":"images\\graphic_design\\1x935_out.png","width":3402,"height":5222,"creation_date":"2023-8-12"},"1x933.png":{"src":"images\\graphic_design\\1x933.png","width":5000,"height":3182,"creation_date":"2023-8-12"},"1x929.png":{"src":"images\\graphic_design\\1x929.png","width":5802,"height":8000,"creation_date":"2023-8-12"},"1x925 (1).png":{"src":"images\\graphic_design\\1x925 (1).png","width":2115,"height":3000,"creation_date":"2023-8-12"},"1155-out.png":{"src":"images\\graphic_design\\1155-out.png","width":3840,"height":4710,"creation_date":"2023-8-12"},"1093.png":{"src":"images\\graphic_design\\1093.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1090.png":{"src":"images\\graphic_design\\1090.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1089.png":{"src":"images\\graphic_design\\1089.png","width":3584,"height":4684,"creation_date":"2023-8-12"},"1087_out.png":{"src":"images\\graphic_design\\1087_out.png","width":1887,"height":1880,"creation_date":"2023-8-12"},"1052_out.png":{"src":"images\\graphic_design\\1052_out.png","width":4320,"height":4320,"creation_date":"2023-8-12"},"1048_out.png":{"src":"images\\graphic_design\\1048_out.png","width":4290,"height":5400,"creation_date":"2023-8-12"},"1030_in.png":{"src":"images\\graphic_design\\1030_in.png","width":2540,"height":3525,"creation_date":"2023-8-12"},"1013_out.png":{"src":"images\\graphic_design\\1013_out.png","width":4096,"height":4092,"creation_date":"2023-8-12"},"1008_out.png":{"src":"images\\graphic_design\\1008_out.png","width":4000,"height":4000,"creation_date":"2023-8-12"},"1007_out.png":{"src":"images\\graphic_design\\1007_out.png","width":3840,"height":3872,"creation_date":"2023-8-12"},"1006.png":{"src":"images\\graphic_design\\1006.png","width":3084,"height":4316,"creation_date":"2023-8-12"},"1005_out.png":{"src":"images\\graphic_design\\1005_out.png","width":2870,"height":4104,"creation_date":"2023-8-12"},"1004_out.png":{"src":"images\\graphic_design\\1004_out.png","width":2964,"height":4268,"creation_date":"2023-8-12"},"1002.png":{"src":"images\\graphic_design\\1002.png","width":3258,"height":4435,"creation_date":"2023-8-12"},"1001-b.png":{"src":"images\\graphic_design\\1001-b.png","width":4224,"height":4290,"creation_date":"2023-8-12"}},"generative":{"unknown2.png":{"src":"images\\generative\\unknown2.png","width":1104,"height":816,"creation_date":"2023-8-12"},"unknown.png":{"src":"images\\generative\\unknown.png","width":1254,"height":701,"creation_date":"2023-8-12"},"unknown (9).png":{"src":"images\\generative\\unknown (9).png"},"unknown (8).png":{"src":"images\\generative\\unknown (8).png"},"unknown (7).png":{"src":"images\\generative\\unknown (7).png"},"unknown (6).png":{"src":"images\\generative\\unknown (6).png"},"unknown (5).png":{"src":"images\\generative\\unknown (5).png"},"unknown (4).png":{"src":"images\\generative\\unknown (4).png"},"unknown (3).png":{"src":"images\\generative\\unknown (3).png"},"unknown (2).png":{"src":"images\\generative\\unknown (2).png"},"unknown (11).png":{"src":"images\\generative\\unknown (11).png"},"unknown (10).png":{"src":"images\\generative\\unknown (10).png"},"unknown (1).png":{"src":"images\\generative\\unknown (1).png"},"spectracer.png":{"src":"images\\generative\\spectracer.png"},"spectracer (5).png":{"src":"images\\generative\\spectracer (5).png"},"spectracer (4).png":{"src":"images\\generative\\spectracer (4).png"},"spectracer (3).png":{"src":"images\\generative\\spectracer (3).png"},"spectracer (2).png":{"src":"images\\generative\\spectracer (2).png"},"spectracer (1).png":{"src":"images\\generative\\spectracer (1).png"},"S138LuQAAAABJRU5ErkJggg.png":{"src":"images\\generative\\S138LuQAAAABJRU5ErkJggg.png","width":1920,"height":1023,"creation_date":"2023-8-12"},"P0y3BNk6U271AAAAAElFTkSuQmCC.png":{"src":"images\\generative\\P0y3BNk6U271AAAAAElFTkSuQmCC.png","width":640,"height":360,"creation_date":"2023-8-12"},"image (29).png":{"src":"images\\generative\\image (29).png"},"image (27).png":{"src":"images\\generative\\image (27).png"},"image (26).png":{"src":"images\\generative\\image (26).png"},"image (25).png":{"src":"images\\generative\\image (25).png"},"idklol-out.png":{"src":"images\\generative\\idklol-out.png","width":2854,"height":2804,"creation_date":"2023-8-12"},"Hhdk6NsUzCUWqcE4gnJieEEyKSKS8vt737P2VPffLRXxkbz7BZnD8Efmjz5R9f6P8CJBYa1YeaSScAAAAASUVORK5CYII.png":{"src":"images\\generative\\Hhdk6NsUzCUWqcE4gnJieEEyKSKS8vt737P2VPffLRXxkbz7BZnD8Efmjz5R9f6P8CJBYa1YeaSScAAAAASUVORK5CYII.png","width":1920,"height":1080,"creation_date":"2023-8-12"},"Ha2Ch0D.png":{"src":"images\\generative\\Ha2Ch0D.png","width":1064,"height":681,"creation_date":"2023-8-12"},"flowers.png":{"src":"images\\generative\\flowers.png","width":1055,"height":682,"creation_date":"2023-8-12"},"FJ5S5FKWQAMjtjO.png":{"src":"images\\generative\\FJ5S5FKWQAMjtjO.png"},"FbPBBI7XkAIz10q.png":{"src":"images\\generative\\FbPBBI7XkAIz10q.png","width":680,"height":435,"creation_date":"2023-8-12"},"download.png":{"src":"images\\generative\\download.png","width":2560,"height":1440,"creation_date":"2023-8-12"},"767.png":{"src":"images\\generative\\767.png","width":2610,"height":1902,"creation_date":"2023-8-12"},"765.png":{"src":"images\\generative\\765.png"},"757-out.png":{"src":"images\\generative\\757-out.png","width":3000,"height":3000,"creation_date":"2023-8-12"},"746-rc-a.png":{"src":"images\\generative\\746-rc-a.png","width":1280,"height":720,"creation_date":"2023-8-12"},"717.png":{"src":"images\\generative\\717.png","width":2488,"height":1440,"creation_date":"2023-8-12"},"581-v1.png":{"src":"images\\generative\\581-v1.png","width":1155,"height":825,"creation_date":"2023-8-12"},"54.png":{"src":"images\\generative\\54.png","width":881,"height":496,"creation_date":"2023-8-12"},"172-a-toned.png":{"src":"images\\generative\\172-a-toned.png","width":893,"height":1374,"creation_date":"2023-8-12"},"FR56Q9mWQAA7U4X.jpg":{"src":"images\\generative\\FR56Q9mWQAA7U4X.jpg"},"FbPBBI7XkAIz10q.jpg":{"src":"images\\generative\\FbPBBI7XkAIz10q.jpg"},"FbBtUi9XoAEHFrV.jpg":{"src":"images\\generative\\FbBtUi9XoAEHFrV.jpg"},"3tycWV.jpg":{"src":"images\\generative\\3tycWV.jpg","width":640,"height":360,"creation_date":"2023-8-12"},"3lSyRh.jpg":{"src":"images\\generative\\3lSyRh.jpg","width":800,"height":450,"creation_date":"2023-8-12"},"capture - 2021-02-23T161035.355.webm":{"src":"images\\generative\\capture - 2021-02-23T161035.355.webm","width":640,"height":360,"creation_date":"2023-8-12"},"capture (59).webm":{"src":"images\\generative\\capture (59).webm","width":1000,"height":1000,"creation_date":"2023-8-12"},"WQC0rBl.mp4":{"src":"images\\generative\\WQC0rBl.mp4"},"pOiFoUR.mp4":{"src":"images\\generative\\pOiFoUR.mp4"},"OUT (3).mp4":{"src":"images\\generative\\OUT (3).mp4"},"OUT (2).mp4":{"src":"images\\generative\\OUT (2).mp4"},"OUT (1).mp4":{"src":"images\\generative\\OUT (1).mp4"},"chrome_xOHw6iea45.mp4":{"src":"images\\generative\\chrome_xOHw6iea45.mp4"},"chrome_UDlKJV4jdZ.mp4":{"src":"images\\generative\\chrome_UDlKJV4jdZ.mp4"},"chrome_RazqupSsRS.mp4":{"src":"images\\generative\\chrome_RazqupSsRS.mp4"},"chrome_ibz88JN1To.mp4":{"src":"images\\generative\\chrome_ibz88JN1To.mp4"},"chrome_foG6RANRoM.mp4":{"src":"images\\generative\\chrome_foG6RANRoM.mp4"},"capture - 2021-04-01T215056.436.mp4":{"src":"images\\generative\\capture - 2021-04-01T215056.436.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-24T174055.362.mp4":{"src":"images\\generative\\capture - 2021-02-24T174055.362.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-23T161035.355.mp4":{"src":"images\\generative\\capture - 2021-02-23T161035.355.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-23T135750.665.mp4":{"src":"images\\generative\\capture - 2021-02-23T135750.665.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-22T191650.873.mp4":{"src":"images\\generative\\capture - 2021-02-22T191650.873.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-15T183608.531.mp4":{"src":"images\\generative\\capture - 2021-02-15T183608.531.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-06T155448.767.mp4":{"src":"images\\generative\\capture - 2021-02-06T155448.767.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-02-04T235908.915.mp4":{"src":"images\\generative\\capture - 2021-02-04T235908.915.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture - 2021-01-25T215853.813.mp4":{"src":"images\\generative\\capture - 2021-01-25T215853.813.mp4","width":640,"height":360,"creation_date":"2023-8-12"},"capture (71).mp4":{"src":"images\\generative\\capture (71).mp4","width":800,"height":450,"creation_date":"2023-8-12"},"capture (61).mp4":{"src":"images\\generative\\capture (61).mp4","width":1100,"height":900,"creation_date":"2023-8-12"},"capture (60).mp4":{"src":"images\\generative\\capture (60).mp4","width":1100,"height":700,"creation_date":"2023-8-12"},"capture (51).mp4":{"src":"images\\generative\\capture (51).mp4","width":1000,"height":1000,"creation_date":"2023-8-12"},"1XTPsDi.mp4":{"src":"images\\generative\\1XTPsDi.mp4"},"166.mp4":{"src":"images\\generative\\166.mp4","width":640,"height":400,"creation_date":"2023-8-12"},"soDroUS.gif":{"src":"images\\generative\\soDroUS.gif","width":500,"height":500,"creation_date":"2023-8-12"},"129.gif":{"src":"images\\generative\\129.gif","width":400,"height":400,"creation_date":"2023-8-12"},"126.gif":{"src":"images\\generative\\126.gif","width":256,"height":256,"creation_date":"2023-8-12"},"123.gif":{"src":"images\\generative\\123.gif","width":512,"height":512,"creation_date":"2023-8-12"}},"noise_tex.webp":{"src":"images\\noise_tex.webp","width":720,"height":720,"creation_date":"2023-8-9"}},"audio":{"epic":{"hmmm.mp3":{"src":"audio\\epic\\hmmm.mp3","creation_date":"2023-8-12"},"590.mp3":{"src":"audio\\epic\\590.mp3","creation_date":"2023-8-12"},"589.mp3":{"src":"audio\\epic\\589.mp3","creation_date":"2023-8-12"},"576-fuji remix v1.mp3":{"src":"audio\\epic\\576-fuji remix v1.mp3","creation_date":"2023-8-12"},"575-2k.mp3":{"src":"audio\\epic\\575-2k.mp3","creation_date":"2023-8-12"},"574-radiator .mp3":{"src":"audio\\epic\\574-radiator .mp3","creation_date":"2023-8-12"},"570 - mark thing wip.mp3":{"src":"audio\\epic\\570 - mark thing wip.mp3","creation_date":"2023-8-12"},"560-v2.mp3":{"src":"audio\\epic\\560-v2.mp3","creation_date":"2023-8-12"},"527.mp3":{"src":"audio\\epic\\527.mp3","creation_date":"2023-8-12"},"524.mp3":{"src":"audio\\epic\\524.mp3","creation_date":"2023-8-12"},"515.mp3":{"src":"audio\\epic\\515.mp3","creation_date":"2023-8-12"},"481.mp3":{"src":"audio\\epic\\481.mp3","creation_date":"2023-8-12"},"465.mp3":{"src":"audio\\epic\\465.mp3","creation_date":"2023-8-12"},"460.mp3":{"src":"audio\\epic\\460.mp3","creation_date":"2023-8-12"},"330.mp3":{"src":"audio\\epic\\330.mp3","creation_date":"2023-8-12"},"319.mp3":{"src":"audio\\epic\\319.mp3","creation_date":"2023-8-12"},"316.mp3":{"src":"audio\\epic\\316.mp3","creation_date":"2023-8-12"},"309 not te4no.mp3":{"src":"audio\\epic\\309 not te4no.mp3","creation_date":"2023-8-12"},"257-2.mp3":{"src":"audio\\epic\\257-2.mp3","creation_date":"2023-8-12"},"256.mp3":{"src":"audio\\epic\\256.mp3","creation_date":"2023-8-12"},"255-v2 - Copy.mp3":{"src":"audio\\epic\\255-v2 - Copy.mp3","creation_date":"2023-8-12"},"254.mp3":{"src":"audio\\epic\\254.mp3","creation_date":"2023-8-12"},"244.mp3":{"src":"audio\\epic\\244.mp3","creation_date":"2023-8-12"},"236.mp3":{"src":"audio\\epic\\236.mp3","creation_date":"2023-8-12"},"222.mp3":{"src":"audio\\epic\\222.mp3","creation_date":"2023-8-12"},"219.mp3":{"src":"audio\\epic\\219.mp3","creation_date":"2023-8-12"},"138.mp3":{"src":"audio\\epic\\138.mp3","creation_date":"2023-8-12"}},"cool":{"wip4e.mp3":{"src":"audio\\cool\\wip4e.mp3","creation_date":"2023-8-12"},"jajaja.mp3":{"src":"audio\\cool\\jajaja.mp3","creation_date":"2023-8-12"},"932.mp3":{"src":"audio\\cool\\932.mp3","creation_date":"2023-8-12"},"927.mp3":{"src":"audio\\cool\\927.mp3","creation_date":"2023-8-12"},"926.mp3":{"src":"audio\\cool\\926.mp3","creation_date":"2023-8-12"},"836.mp3":{"src":"audio\\cool\\836.mp3","creation_date":"2023-8-12"},"801.mp3":{"src":"audio\\cool\\801.mp3","creation_date":"2023-8-12"},"797-b.mp3":{"src":"audio\\cool\\797-b.mp3","creation_date":"2023-8-12"},"730.mp3":{"src":"audio\\cool\\730.mp3","creation_date":"2023-8-12"},"692.mp3":{"src":"audio\\cool\\692.mp3","creation_date":"2023-8-12"},"691.mp3":{"src":"audio\\cool\\691.mp3","creation_date":"2023-8-12"},"690_unnoised_more.mp3":{"src":"audio\\cool\\690_unnoised_more.mp3","creation_date":"2023-8-12"},"662.mp3":{"src":"audio\\cool\\662.mp3","creation_date":"2023-8-12"},"642 other.mp3":{"src":"audio\\cool\\642 other.mp3","creation_date":"2023-8-12"},"626.mp3":{"src":"audio\\cool\\626.mp3","creation_date":"2023-8-12"},"1244 ok 2023-08-07 1915.mp3":{"src":"audio\\cool\\1244 ok 2023-08-07 1915.mp3","creation_date":"2023-8-12"},"1243 2023-08-07 1919.mp3":{"src":"audio\\cool\\1243 2023-08-07 1919.mp3","creation_date":"2023-8-12"},"1188 2023-08-07 1946.mp3":{"src":"audio\\cool\\1188 2023-08-07 1946.mp3","creation_date":"2023-8-12"},"1187 2023-03-20 2255.mp3":{"src":"audio\\cool\\1187 2023-03-20 2255.mp3","creation_date":"2023-8-12"},"1180 2023-03-13 vcv.mp3":{"src":"audio\\cool\\1180 2023-03-13 vcv.mp3","creation_date":"2023-8-12"},"1162.mp3":{"src":"audio\\cool\\1162.mp3","creation_date":"2023-8-12"},"1140.mp3":{"src":"audio\\cool\\1140.mp3","creation_date":"2023-8-12"},"1121.mp3":{"src":"audio\\cool\\1121.mp3","creation_date":"2023-8-12"},"1116-toomb-ludum-dare.mp3":{"src":"audio\\cool\\1116-toomb-ludum-dare.mp3","creation_date":"2023-8-12"},"1099-toomb4.mp3":{"src":"audio\\cool\\1099-toomb4.mp3","creation_date":"2023-8-12"},"1098-toomb3 (1).mp3":{"src":"audio\\cool\\1098-toomb3 (1).mp3","creation_date":"2023-8-12"},"1096-toomb2.mp3":{"src":"audio\\cool\\1096-toomb2.mp3","creation_date":"2023-8-12"},"1095-toomb.mp3":{"src":"audio\\cool\\1095-toomb.mp3","creation_date":"2023-8-12"},"1071.mp3":{"src":"audio\\cool\\1071.mp3","creation_date":"2023-8-12"},"1069.mp3":{"src":"audio\\cool\\1069.mp3","creation_date":"2023-8-12"},"1034.mp3":{"src":"audio\\cool\\1034.mp3","creation_date":"2023-8-12"},"1025.mp3":{"src":"audio\\cool\\1025.mp3","creation_date":"2023-8-12"},"1021.mp3":{"src":"audio\\cool\\1021.mp3","creation_date":"2023-8-12"},"1014.mp3":{"src":"audio\\cool\\1014.mp3","creation_date":"2023-8-12"}}}}});
	window.is_dev = "production" === 'development';

	window.LFS_PREPEND = is_dev
	? ""
	: "https://media.githubusercontent.com/media/wrightwriter/wrightwriter.github.io/master/";

	let { url = "/" } = $$props;
	const writable_props = ['url'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') App_svelte_console_1.warn(`<App> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('url' in $$props) $$invalidate(2, url = $$props.url);
	};

	$$self.$capture_state = () => ({
		onMount: onMount,
		onDestroy: onDestroy,
		resizeFramebuffersIfNeeded: resizeIfNeeded,
		init_gl_error_handling: init_gl_error_handling,
		Framebuffer: Framebuffer,
		VertexBuffer: VertexBuffer,
		UBO: UBO,
		Texture: Texture,
		ShaderProgram: ShaderProgram,
		Thing: Thing,
		Bar: src_components_Bar_svelte,
		Router: Router_svelte,
		Link: src_Link_svelte,
		Route: Route_svelte,
		FavDemos: src_components_FavDemos_svelte,
		Music: src_components_music_svelte,
		Art: src_components_art_svelte,
		Projects: src_components_Projects,
		About: src_components_About_svelte,
		Splash: src_components_Splash_svelte,
		Hash: Hash,
		lerp: wmath_lerp,
		min: min,
		smoothstep: wmath_smoothstep,
		url,
		path_name,
		head_title
	});

	$$self.$inject_state = $$props => {
		if ('url' in $$props) $$invalidate(2, url = $$props.url);
		if ('path_name' in $$props) $$invalidate(0, path_name = $$props.path_name);
		if ('head_title' in $$props) $$invalidate(1, head_title = $$props.head_title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$: $$invalidate(1, head_title = "wrighter" + location.pathname + location.hash);
	$: $$invalidate(0, path_name = location.pathname);
	return [path_name, head_title, url];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, App_svelte_instance, App_svelte_create_fragment, safe_not_equal, { url: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: App_svelte_create_fragment.name
		});
	}

	get url() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const src_components_App_svelte = (App);

;// CONCATENATED MODULE: ./src/index.ts




const app = new src_components_App_svelte({
    target: document.body,
    props: {},
});
/* harmony default export */ const src = ((/* unused pure expression or super */ null && (app)));

})();

/******/ })()
;
//# sourceMappingURL=bundle.js.map